{"version":3,"sources":["src/leaflet.extension.js","src/Leaflet.draw.js","src/Leaflet.Draw.Event.js","src/draw/handler/Draw.Feature.js","src/draw/handler/Draw.Polyline.js","src/draw/handler/Draw.Polygon.js","src/draw/handler/Draw.SimpleShape.js","src/draw/handler/Draw.Rectangle.js","src/draw/handler/Draw.Marker.js","src/draw/handler/Draw.CircleMarker.js","src/draw/handler/Draw.Circle.js","src/draw/handler/Draw.DuongDay.js","src/draw/handler/Draw.ThanhCai.js","src/draw/handler/Draw.Role.js","src/draw/handler/Draw.MayBienAp.js","src/edit/handler/Edit.Marker.js","src/edit/handler/Edit.Poly.js","src/edit/handler/Edit.SimpleShape.js","src/edit/handler/Edit.SimpleShapeSnap.js","src/edit/handler/Edit.Rectangle.js","src/edit/handler/Edit.CircleMarker.js","src/edit/handler/Edit.Circle.js","src/edit/handler/Edit.ThanhCai.js","src/edit/handler/Edit.Role.js","src/edit/handler/Edit.MayBienAp.js","src/edit/handler/Edit.DuongDay.js","src/ext/TouchEvents.js","src/ext/LatLngUtil.js","src/ext/GeometryUtil.js","src/ext/LineUtil.Intersect.js","src/ext/Polyline.Intersect.js","src/ext/Polygon.Intersect.js","src/Control.Draw.js","src/Toolbar.js","src/Tooltip.js","src/draw/DrawToolbar.js","src/edit/EditToolbar.js","src/edit/handler/EditToolbar.Edit.js","src/edit/handler/EditToolbar.Delete.js"],"names":[],"mappings":";;;;;;;yCAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACpxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACxNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACnMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACxGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACtqBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACjIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACvHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AClGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC/HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACpIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACpIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACnIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC1hBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC1PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC7HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC/EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AChFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC/EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AChRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACn0BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC1GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC/HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC7WA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACtHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACrIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AChNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AChUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["L.Renderer.include({\r\n\t_updateMayBienAp: function (layer) {\r\n\t\tconst o1 = layer._xuLy(layer._getLatLngI1(), layer._getRadiusR1());\r\n\t\tconst i1 = o1[0];\r\n\t\tconst r1x = Math.max(Math.round(o1[1]), 1);\r\n\t\tconst r1y = Math.max(Math.round(o1[2]), 1) || r1x;\r\n\r\n\t\tconst o2 = layer._xuLy(layer._getLatLngI2(), layer._getRadiusR2());\r\n\t\tconst i2 = o2[0];\r\n\t\tconst r2x = Math.max(Math.round(o2[1]), 1);\r\n\t\tconst r2y = Math.max(Math.round(o2[2]), 1) || r2x;\r\n\r\n\t\tconst arc1 = \"a\" + r1x + \",\" + r1y + \" 0 1,0 \";\r\n\r\n\t\tconst arc2 = \"a\" + r2x + \",\" + r2y + \" 0 1,0 \";\r\n\r\n\t\tconst pA = layer._xuLy(layer._getLatLngA(), layer._getRadiusR1())[0];\r\n\t\tconst pN = layer._xuLy(layer._getLatLngN(), layer._getRadiusR1())[0];\r\n\t\tconst pB = layer._xuLy(layer._getLatLngB(), layer._getRadiusR1())[0];\r\n\r\n\t\tconst arc3 =\r\n\t\t\t\"M\" +\r\n\t\t\tpA.x +\r\n\t\t\t\" \" +\r\n\t\t\tpA.y +\r\n\t\t\t\" Q \" +\r\n\t\t\tpN.x +\r\n\t\t\t\" \" +\r\n\t\t\tpN.y +\r\n\t\t\t\" \" +\r\n\t\t\tpB.x +\r\n\t\t\t\" \" +\r\n\t\t\tpB.y;\r\n\r\n\t\tvar d = layer._empty()\r\n\t\t\t? \"M0 0\"\r\n\t\t\t: \"M\" +\r\n\t\t\t  (i1.x - r1x) +\r\n\t\t\t  \",\" +\r\n\t\t\t  i1.y +\r\n\t\t\t  arc1 +\r\n\t\t\t  r1x * 2 +\r\n\t\t\t  \",0 \" +\r\n\t\t\t  arc1 +\r\n\t\t\t  -r1y * 2 +\r\n\t\t\t  \",0 \" +\r\n\t\t\t  \"M\" +\r\n\t\t\t  (i2.x - r2x) +\r\n\t\t\t  \",\" +\r\n\t\t\t  i2.y +\r\n\t\t\t  arc2 +\r\n\t\t\t  r2x * 2 +\r\n\t\t\t  \",0 \" +\r\n\t\t\t  arc2 +\r\n\t\t\t  -r2y * 2 +\r\n\t\t\t  \",0 \" +\r\n\t\t\t  arc3;\r\n\r\n\t\tthis._setPath(layer, d);\r\n\t},\r\n});\r\n\r\nL.Layer.include({\r\n\t_processAngle: function (angle) {\r\n\t\tvar ret = 0;\r\n\t\tif (angle >= 0 && angle <= 90) {\r\n\t\t\tret = 0;\r\n\t\t} else if (angle > 90 && angle <= 180) {\r\n\t\t\tret = 90;\r\n\t\t} else if (angle > 180 && angle <= 270) {\r\n\t\t\tret = 180;\r\n\t\t} else {\r\n\t\t\tret = 270;\r\n\t\t}\r\n\t\treturn ret;\r\n\t},\r\n});\r\n\r\n//#region L.DuongDay\r\nL.DuongDay = L.Polyline.extend({\r\n\tinitialize: function (latlngs, options) {\r\n\t\tL.Polyline.prototype.initialize.call(this, latlngs, options);\r\n\t},\r\n});\r\n\r\nL.duongDay = function (latlngs, options) {\r\n\treturn new L.DuongDay(latlngs, options);\r\n};\r\n//#endregion\r\n\r\n//#region L.MayBienAp\r\nL.MayBienAp = L.Path.extend({\r\n\toptions: {\r\n\t\tfill: false,\r\n\t\tchieuDai: 150,\r\n\t\tgocXoay: 0,\r\n\t},\r\n\r\n\tinitialize: function (latlng, options) {\r\n\t\tL.setOptions(this, options);\r\n\t\tthis._latlng = L.latLng(latlng);\r\n\t},\r\n\r\n\t// @method setLatLng(latLng: LatLng): this\r\n\t// Sets the position of a circle marker to a new location.\r\n\tsetLatLng: function (latlng) {\r\n\t\tthis._latlng = L.latLng(latlng);\r\n\t\tthis.redraw();\r\n\t\treturn this.fire(\"move\", { latlng: this._latlng });\r\n\t},\r\n\r\n\t// @method getLatLng(): LatLng\r\n\t// Returns the current geographical position of the circle marker\r\n\tgetLatLng: function () {\r\n\t\treturn this._latlng;\r\n\t},\r\n\r\n\t_getRadiusR1: function () {\r\n\t\treturn (\r\n\t\t\t(this.options.chieuDai * 4) / (2 + 3 * Math.sin(Math.acos(1 / 3)) * 4)\r\n\t\t);\r\n\t},\r\n\r\n\t_getLatLngI1: function () {\r\n\t\treturn L.GeometryUtil.destination(\r\n\t\t\tthis._latlng,\r\n\t\t\tthis.options.gocXoay - 90,\r\n\t\t\tthis._getRadiusR1() / 4\r\n\t\t);\r\n\t},\r\n\r\n\t_getRadiusR2: function () {\r\n\t\treturn 0.6 * this._getRadiusR1();\r\n\t},\r\n\r\n\t_getLatLngI2: function () {\r\n\t\treturn L.GeometryUtil.destination(\r\n\t\t\tthis._getLatLngC(),\r\n\t\t\tthis.options.gocXoay - 90,\r\n\t\t\tthis._getRadiusR2()\r\n\t\t);\r\n\t},\r\n\r\n\t_getLatLngA: function () {\r\n\t\treturn L.GeometryUtil.destination(\r\n\t\t\tthis._latlng,\r\n\t\t\tthis.options.gocXoay - 90,\r\n\t\t\tthis.options.chieuDai / 2\r\n\t\t);\r\n\t},\r\n\r\n\t_getLatLngB: function () {\r\n\t\treturn L.GeometryUtil.destination(\r\n\t\t\tthis._getLatLngI1(),\r\n\t\t\tthis.options.gocXoay,\r\n\t\t\tthis._getRadiusR1()\r\n\t\t);\r\n\t},\r\n\r\n\t_getLatLngC: function () {\r\n\t\treturn L.GeometryUtil.destination(\r\n\t\t\tthis._latlng,\r\n\t\t\tthis.options.gocXoay + 90,\r\n\t\t\tthis.options.chieuDai / 2\r\n\t\t);\r\n\t},\r\n\r\n\t_getLatLngD: function () {\r\n\t\treturn L.GeometryUtil.destination(\r\n\t\t\tthis._getLatLngI1(),\r\n\t\t\tthis.options.gocXoay + 180,\r\n\t\t\tthis._getRadiusR1()\r\n\t\t);\r\n\t},\r\n\r\n\t_getLatLngE: function () {\r\n\t\treturn L.GeometryUtil.destination(\r\n\t\t\tthis._getLatLngI2(),\r\n\t\t\tthis.options.gocXoay,\r\n\t\t\tthis._getRadiusR2()\r\n\t\t);\r\n\t},\r\n\r\n\t_getLatLngF: function () {\r\n\t\treturn L.GeometryUtil.destination(\r\n\t\t\tthis._getLatLngI2(),\r\n\t\t\tthis.options.gocXoay + 180,\r\n\t\t\tthis._getRadiusR2()\r\n\t\t);\r\n\t},\r\n\r\n\t_getLatLngM: function () {\r\n\t\tconst angleAB = L.GeometryUtil.angle(\r\n\t\t\tthis._map,\r\n\t\t\tthis._getLatLngA(),\r\n\t\t\tthis._getLatLngB()\r\n\t\t);\r\n\t\tconst d = this._getLatLngA().distanceTo(this._getLatLngB());\r\n\t\treturn L.GeometryUtil.destination(this._getLatLngA(), angleAB, d / 2);\r\n\t},\r\n\r\n\t_getLatLngN: function () {\r\n\t\tconst pM = this._getLatLngM();\r\n\t\tconst pI1 = this._getLatLngI1();\r\n\t\tconst angleMB = L.GeometryUtil.angle(this._map, pM, this._getLatLngB());\r\n\t\tconst angleMI1 = L.GeometryUtil.angle(this._map, pM, pI1);\r\n\t\tconst angleMBMI1 = angleMI1 - angleMB;\r\n\t\tconst d = pM.distanceTo(pI1);\r\n\t\tconst dI1AB = Math.sin((angleMBMI1 * Math.PI) / 180) * d;\r\n\t\treturn L.GeometryUtil.destination(\r\n\t\t\tthis._getLatLngM(),\r\n\t\t\tangleMB - 90,\r\n\t\t\t(3 * dI1AB) / 4\r\n\t\t);\r\n\t},\r\n\r\n\tgetRotateMarker: function () {\r\n\t\treturn L.GeometryUtil.destination(\r\n\t\t\tthis._latlng,\r\n\t\t\tthis.options.gocXoay,\r\n\t\t\t(3 * this._getRadiusR1()) / 2\r\n\t\t);\r\n\t},\r\n\r\n\t_xuLy: function (latlng, radius) {\r\n\t\tvar lng = latlng.lng,\r\n\t\t\tlat = latlng.lat,\r\n\t\t\tmap = this._map,\r\n\t\t\tcrs = map.options.crs,\r\n\t\t\tretP,\r\n\t\t\tretRadiusX,\r\n\t\t\tretRadiusY;\r\n\r\n\t\tif (crs.distance === L.CRS.Earth.distance) {\r\n\t\t\tvar d = Math.PI / 180,\r\n\t\t\t\tlatR = radius / L.CRS.Earth.R / d,\r\n\t\t\t\ttop = map.project([lat + latR, lng]),\r\n\t\t\t\tbottom = map.project([lat - latR, lng]),\r\n\t\t\t\tp = top.add(bottom).divideBy(2),\r\n\t\t\t\tlat2 = map.unproject(p).lat,\r\n\t\t\t\tlngR =\r\n\t\t\t\t\tMath.acos(\r\n\t\t\t\t\t\t(Math.cos(latR * d) - Math.sin(lat * d) * Math.sin(lat2 * d)) /\r\n\t\t\t\t\t\t\t(Math.cos(lat * d) * Math.cos(lat2 * d))\r\n\t\t\t\t\t) / d;\r\n\r\n\t\t\tif (isNaN(lngR) || lngR === 0) {\r\n\t\t\t\tlngR = latR / Math.cos((Math.PI / 180) * lat); // Fallback for edge case, #2425\r\n\t\t\t}\r\n\r\n\t\t\tretP = p.subtract(map.getPixelOrigin());\r\n\t\t\tretRadiusX = isNaN(lngR) ? 0 : p.x - map.project([lat2, lng - lngR]).x;\r\n\t\t\tretRadiusY = p.y - top.y;\r\n\t\t} else {\r\n\t\t\tvar latlng2 = crs.unproject(crs.project(latlng).subtract([radius, 0]));\r\n\r\n\t\t\tretP = map.latLngToLayerPoint(latlng);\r\n\t\t\tretRadiusX = retP.x - map.latLngToLayerPoint(latlng2).x;\r\n\t\t\tretRadiusY = radius;\r\n\t\t}\r\n\r\n\t\treturn [retP, retRadiusX, retRadiusY];\r\n\t},\r\n\r\n\t_project: function () {\r\n\t\tthis._updateBounds();\r\n\t},\r\n\r\n\tgetLayerSnap: function () {\r\n\t\treturn L.layerGroup([\r\n\t\t\tL.circleMarker(this._getLatLngA(), { opacity: 0, weight: 0.5 }),\r\n\t\t\tL.circleMarker(this._getLatLngB(), { opacity: 0, weight: 0.5 }),\r\n\t\t\tL.circleMarker(this._getLatLngC(), { opacity: 0, weight: 0.5 }),\r\n\t\t\tL.circleMarker(this._getLatLngD(), { opacity: 0, weight: 0.5 }),\r\n\t\t\tL.circleMarker(this._getLatLngE(), { opacity: 0, weight: 0.5 }),\r\n\t\t\tL.circleMarker(this._getLatLngF(), { opacity: 0, weight: 0.5 }),\r\n\t\t]);\r\n\t},\r\n\r\n\t_updateBounds: function () {\r\n\t\tconst bounds = this.getBounds();\r\n\t\tthis._pxBounds = L.bounds(\r\n\t\t\tthis._map.latLngToLayerPoint(bounds._northEast),\r\n\t\t\tthis._map.latLngToLayerPoint(bounds._southWest)\r\n\t\t);\r\n\t},\r\n\r\n\t_update: function () {\r\n\t\tif (this._map) {\r\n\t\t\tthis._updatePath();\r\n\t\t}\r\n\t},\r\n\r\n\t_updatePath: function () {\r\n\t\tthis._renderer._updateMayBienAp(this);\r\n\t},\r\n\r\n\t_empty: function () {\r\n\t\treturn this._radius && !this._renderer._bounds.intersects(this._pxBounds);\r\n\t},\r\n\r\n\t// Needed by the `Canvas` renderer for interactivity\r\n\t_containsPoint: function (p) {\r\n\t\treturn p.distanceTo(this._point) <= this._radius + this._clickTolerance();\r\n\t},\r\n\r\n\t// @method getBounds(): LatLngBounds\r\n\t// Returns the `LatLngBounds` of the path.\r\n\tgetBounds: function () {\r\n\t\tconst pA = this._getLatLngA();\r\n\t\tconst pC = this._getLatLngC();\r\n\r\n\t\treturn L.latLngBounds(\r\n\t\t\tL.GeometryUtil.destination(\r\n\t\t\t\tpC,\r\n\t\t\t\t-this.options.gocXoay,\r\n\t\t\t\tthis._getRadiusR1()\r\n\t\t\t),\r\n\t\t\tL.GeometryUtil.destination(\r\n\t\t\t\tpA,\r\n\t\t\t\tthis.options.gocXoay + 180,\r\n\t\t\t\tthis._getRadiusR1()\r\n\t\t\t)\r\n\t\t);\r\n\t},\r\n\r\n\trotate: function (latlng) {\r\n\t\tconst map = this._map;\r\n\t\tconst centerPoint = this._latlng;\r\n\t\tconst angle = L.GeometryUtil.angle(map, centerPoint, latlng);\r\n\t\tthis.options.gocXoay = angle;\r\n\t\tthis.redraw();\r\n\t},\r\n\r\n\tresize: function (latlng) {\r\n\t\tconst map = this._map;\r\n\t\tconst pC = this._getLatLngC();\r\n\t\tconst centerPoint = this._latlng;\r\n\t\tconst angleMC = L.GeometryUtil.angle(map, centerPoint, pC);\r\n\t\tconst angleMCDetal = L.GeometryUtil.angle(map, centerPoint, latlng);\r\n\t\tconst angle = Math.abs(angleMCDetal - angleMC);\r\n\t\tconst d =\r\n\t\t\tMath.cos((angle * Math.PI) / 180) * centerPoint.distanceTo(latlng);\r\n\t\tthis.options.chieuDai = Math.abs(2 * d);\r\n\t\tthis.redraw();\r\n\t},\r\n\r\n\tmove: function (latlng) {\r\n\t\tthis._latlng = latlng;\r\n\t\tthis.redraw();\r\n\t},\r\n});\r\n\r\nL.mayBienAp = function (latlng, options) {\r\n\treturn new L.MayBienAp(latlng, options);\r\n};\r\n//#endregion\r\n\r\n// Thêm hàm/thuộc tính vào lớp Layer đã tồn tại.\r\nL.Layer.include({\r\n\t// Hàm trả về centerPoint của layer\r\n\tgetCenterCus: function () {\r\n\t\tconst pNE = this._map.project(this._bounds._northEast, this._map.getZoom());\r\n\t\tconst pSW = this._map.project(this._bounds._southWest, this._map.getZoom());\r\n\t\treturn this._map.unproject(\r\n\t\t\tL.point((pNE.x + pSW.x) / 2, (pNE.y + pSW.y) / 2),\r\n\t\t\tthis._map.getZoom()\r\n\t\t);\r\n\t},\r\n});\r\n\r\n//#region L.ThanhCai\r\nL.ThanhCai = L.Polyline.extend({\r\n\toptions: {\r\n\t\tchieuDai: 300,\r\n\t\tgocXoay: 0,\r\n\t\tdistanceRotateMarker: 20,\r\n\t},\r\n\tinitialize: function (centerPoint, options) {\r\n\t\tL.setOptions(this, options);\r\n\t\tconst latlngs = this._thanhCaiLatLngs(centerPoint);\r\n\t\tL.Polyline.prototype.initialize.call(this, latlngs, options);\r\n\t},\r\n\t_thanhCaiLatLngs: function (centerPoint) {\r\n\t\tconst gocXoayA = this.options.gocXoay;\r\n\t\tconst gocXoayB = gocXoayA + 180;\r\n\t\tconst diemA = L.GeometryUtil.destination(\r\n\t\t\tcenterPoint,\r\n\t\t\tgocXoayA,\r\n\t\t\tthis.options.chieuDai / 2\r\n\t\t);\r\n\t\tconst diemB = L.GeometryUtil.destination(\r\n\t\t\tcenterPoint,\r\n\t\t\tgocXoayB,\r\n\t\t\tthis.options.chieuDai / 2\r\n\t\t);\r\n\t\treturn [diemA, diemB];\r\n\t},\r\n\tgetLayerSnap: function () {\r\n\t\treturn L.polyline(this.getLatLngs(), { opacity: 0 });\r\n\t},\r\n\tgetRotateMarker: function () {\r\n\t\tconst centerPoint = this.getCenterCus();\r\n\t\treturn L.GeometryUtil.destination(\r\n\t\t\tcenterPoint,\r\n\t\t\tthis.options.gocXoay - 90,\r\n\t\t\tthis.options.distanceRotateMarker\r\n\t\t);\r\n\t},\r\n\trotate: function (latlng) {\r\n\t\tconst map = this._map;\r\n\t\tconst centerPoint = this.getCenterCus();\r\n\t\tconst angle = L.GeometryUtil.angle(map, centerPoint, latlng);\r\n\t\tthis.options.gocXoay = angle + 90;\r\n\t\tthis.setLatLngs(this._thanhCaiLatLngs(centerPoint));\r\n\t},\r\n\tresize: function (latlng) {\r\n\t\tconst map = this._map;\r\n\t\tconst latLngs = this.getLatLngs();\r\n\t\tconst centerPoint = this.getCenterCus();\r\n\t\tconst pA = latLngs[0];\r\n\t\tconst angleMA = L.GeometryUtil.angle(map, centerPoint, pA);\r\n\t\tconst angleMADetal = L.GeometryUtil.angle(map, centerPoint, latlng);\r\n\t\tconst angle = Math.abs(angleMADetal - angleMA);\r\n\t\tconst d =\r\n\t\t\tMath.cos((angle * Math.PI) / 180) * centerPoint.distanceTo(latlng);\r\n\t\tthis.options.chieuDai = Math.abs(2 * d);\r\n\t\tthis.setLatLngs(this._thanhCaiLatLngs(centerPoint));\r\n\t},\r\n\tmove: function (latlng) {\r\n\t\tthis.setLatLngs(this._thanhCaiLatLngs(latlng));\r\n\t},\r\n});\r\n\r\nL.thanhCai = function (latlng, map, options) {\r\n\treturn new L.ThanhCai(latlng, map, options);\r\n};\r\n//#endregion\r\n\r\n//#region L.Role\r\nL.Role = L.Polyline.extend({\r\n\toptions: {\r\n\t\tchieuDai: 50,\r\n\t\tchieuRong: 25,\r\n\t\tgocXoay: 0,\r\n\t},\r\n\tinitialize: function (centerPoint, options) {\r\n\t\tthis._centerPoint = centerPoint;\r\n\t\tL.setOptions(this, options);\r\n\t\tconst latlngs = this._roleLatLngs(centerPoint);\r\n\t\tL.Polyline.prototype.initialize.call(this, latlngs, options);\r\n\t},\r\n\t_roleLatLngs: function (centerPoint) {\r\n\t\tconst gocXoayM = -this.options.gocXoay;\r\n\t\tconst gocXoayA = -90 - this.options.gocXoay;\r\n\t\tconst gocXoayB = gocXoayA + 180;\r\n\t\tconst gocXoayC = 180 + gocXoayM;\r\n\t\tconst gocXoayD = 180 + gocXoayM;\r\n\t\tconst trungDiemAB = L.GeometryUtil.destination(\r\n\t\t\tcenterPoint,\r\n\t\t\t-gocXoayM,\r\n\t\t\tthis.options.chieuRong / 2\r\n\t\t);\r\n\t\tconst diemA = L.GeometryUtil.destination(\r\n\t\t\ttrungDiemAB,\r\n\t\t\t-gocXoayA,\r\n\t\t\tthis.options.chieuDai / 2\r\n\t\t);\r\n\t\tconst diemB = L.GeometryUtil.destination(\r\n\t\t\ttrungDiemAB,\r\n\t\t\t-gocXoayB,\r\n\t\t\tthis.options.chieuDai / 2\r\n\t\t);\r\n\t\tconst diemC = L.GeometryUtil.destination(\r\n\t\t\tdiemB,\r\n\t\t\t-gocXoayC,\r\n\t\t\tthis.options.chieuRong\r\n\t\t);\r\n\t\tconst diemD = L.GeometryUtil.destination(\r\n\t\t\tdiemA,\r\n\t\t\t-gocXoayD,\r\n\t\t\tthis.options.chieuRong\r\n\t\t);\r\n\t\treturn [diemA, diemB, diemC, diemD, diemA];\r\n\t},\r\n\tgetRotateMarker: function () {\r\n\t\tconst centerPoint = this.getCenterCus();\r\n\t\treturn L.GeometryUtil.destination(\r\n\t\t\tcenterPoint,\r\n\t\t\tthis.options.gocXoay,\r\n\t\t\tthis.options.chieuRong\r\n\t\t);\r\n\t},\r\n\tmove: function (latlng) {\r\n\t\tthis.setLatLngs(this._roleLatLngs(latlng));\r\n\t},\r\n\tresize: function (latlng) {\r\n\t\tconst latLngs = this.getLatLngs();\r\n\t\tconst centerPoint = this.getCenterCus();\r\n\t\tconst map = this._map;\r\n\t\tconst pA = latLngs[0];\r\n\t\tconst pB = latLngs[1];\r\n\t\tconst pD = latLngs[3];\r\n\t\tconst trungDiemAB = L.GeometryUtil.closestOnSegment(\r\n\t\t\tmap,\r\n\t\t\tcenterPoint,\r\n\t\t\tpA,\r\n\t\t\tpB\r\n\t\t);\r\n\t\tconst trungDiemAD = L.GeometryUtil.closestOnSegment(\r\n\t\t\tmap,\r\n\t\t\tcenterPoint,\r\n\t\t\tpA,\r\n\t\t\tpD\r\n\t\t);\r\n\t\tconst angleMAB_A = L.GeometryUtil.angle(map, trungDiemAB, pA);\r\n\t\tconst angleMAD_A = L.GeometryUtil.angle(map, trungDiemAD, pA);\r\n\t\tconst angleMAB_ADetal = L.GeometryUtil.angle(map, trungDiemAB, latlng);\r\n\t\tconst angleMAD_ADetal = L.GeometryUtil.angle(map, trungDiemAD, latlng);\r\n\t\tconst angleA = Math.abs(angleMAB_ADetal - angleMAB_A);\r\n\t\tconst angleB = Math.abs(angleMAD_ADetal - angleMAD_A);\r\n\t\tconst dxAB =\r\n\t\t\tMath.cos((angleA * Math.PI) / 180) * trungDiemAB.distanceTo(latlng);\r\n\t\tconst dxAD =\r\n\t\t\tMath.cos((angleB * Math.PI) / 180) * trungDiemAD.distanceTo(latlng);\r\n\t\tthis.options.chieuDai = Math.abs(this.options.chieuDai / 2 + dxAB);\r\n\t\tthis.options.chieuRong = Math.abs(this.options.chieuRong / 2 + dxAD);\r\n\t\tthis.setLatLngs(this._roleLatLngs(centerPoint));\r\n\t},\r\n\trotate: function (latlng) {\r\n\t\tconst map = this._map;\r\n\t\tconst centerPoint = this.getCenterCus();\r\n\t\tconst angle = L.GeometryUtil.angle(map, centerPoint, latlng);\r\n\t\tthis.options.gocXoay = angle;\r\n\t\tthis.setLatLngs(this._roleLatLngs(centerPoint));\r\n\t},\r\n\tgetLayerSnap: function () {\r\n\t\tconst latlngs = this.getLatLngs();\r\n\t\tconst pA = latlngs[0];\r\n\t\tconst pB = latlngs[1];\r\n\t\tconst pMAD = L.GeometryUtil.destination(\r\n\t\t\tpA,\r\n\t\t\tthis.options.gocXoay + 180,\r\n\t\t\tthis.options.chieuRong / 2\r\n\t\t);\r\n\t\tconst pMBC = L.GeometryUtil.destination(\r\n\t\t\tpB,\r\n\t\t\tthis.options.gocXoay + 180,\r\n\t\t\tthis.options.chieuRong / 2\r\n\t\t);\r\n\t\treturn L.layerGroup([\r\n\t\t\tL.circleMarker(pMAD, { opacity: 0, weight: 0.5 }),\r\n\t\t\tL.circleMarker(pMBC, { opacity: 0, weight: 0.5 }),\r\n\t\t]);\r\n\t},\r\n\tgetCenter: function () {\r\n\t\treturn this._centerPoint;\r\n\t},\r\n});\r\n\r\nL.role = function (latlng, options) {\r\n\treturn new L.Role(latlng, options);\r\n};\r\n//#endregion\r\n\r\n//#region Draw GuidLayer\r\n\r\nL.GuideLayer = L.Class.extend({\r\n\toptions: {\r\n\t\twidth: 10,\r\n\t\theight: 10,\r\n\t},\r\n\tinitialize: function (map, options) {\r\n\t\tL.setOptions(this, options);\r\n\t\tthis._map = map;\r\n\t\tthis._gocO = L.latLng(0, 0);\r\n\t\tthis._lineX = this._getLineX();\r\n\t\tthis._lineY = this._getLineY();\r\n\t\tthis._drawGuidLayer();\r\n\t\tthis._map.on(\r\n\t\t\t\"move\",\r\n\t\t\tfunction () {\r\n\t\t\t\tthis.options.layer.clearLayers();\r\n\t\t\t\tconst zoom = this._map.getZoom();\r\n\t\t\t\tif (zoom >= this.options.zoom) {\r\n\t\t\t\t\tthis._drawGuidLayer();\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tthis\r\n\t\t);\r\n\t},\r\n\t_drawGuidLayer: function () {\r\n\t\tvar ret = [];\r\n\t\tvar tpms = this._getLatLngs(\r\n\t\t\tthis._getLatLngO(),\r\n\t\t\tL.GeometryUtil.closestOnSegment(\r\n\t\t\t\tthis._map,\r\n\t\t\t\tthis._getLatLngO(),\r\n\t\t\t\tthis._getLatLngA(),\r\n\t\t\t\tthis._getLatLngD()\r\n\t\t\t),\r\n\t\t\tthis.options.width\r\n\t\t);\r\n\t\ttpms = tpms.concat(\r\n\t\t\tthis._getLatLngs(\r\n\t\t\t\tthis._getLatLngO(),\r\n\t\t\t\tL.GeometryUtil.closestOnSegment(\r\n\t\t\t\t\tthis._map,\r\n\t\t\t\t\tthis._getLatLngO(),\r\n\t\t\t\t\tthis._getLatLngB(),\r\n\t\t\t\t\tthis._getLatLngC()\r\n\t\t\t\t),\r\n\t\t\t\tthis.options.width\r\n\t\t\t)\r\n\t\t);\r\n\t\ttpms.push(this._getLatLngO());\r\n\t\ttpms.forEach((element) => {\r\n\t\t\tconst dAB = L.GeometryUtil.closestOnSegment(\r\n\t\t\t\tthis._map,\r\n\t\t\t\telement,\r\n\t\t\t\tthis._getLatLngA(),\r\n\t\t\t\tthis._getLatLngB()\r\n\t\t\t);\r\n\t\t\tret = ret.concat(this._getLatLngs(element, dAB, this.options.height));\r\n\r\n\t\t\tconst dCD = L.GeometryUtil.closestOnSegment(\r\n\t\t\t\tthis._map,\r\n\t\t\t\telement,\r\n\t\t\t\tthis._getLatLngC(),\r\n\t\t\t\tthis._getLatLngD()\r\n\t\t\t);\r\n\t\t\tret = ret.concat(this._getLatLngs(element, dCD, this.options.height));\r\n\r\n\t\t\tret.push(element);\r\n\t\t});\r\n\t\tret.forEach((e) => {\r\n\t\t\tthis.options.layer.addLayer(\r\n\t\t\t\tL.circleMarker(e, {\r\n\t\t\t\t\tradius: 0.5,\r\n\t\t\t\t\tcolor: \"black\",\r\n\t\t\t\t\tfill: false,\r\n\t\t\t\t\tweight: 1,\r\n\t\t\t\t\tbubblingMouseEvents: false,\r\n\t\t\t\t})\r\n\t\t\t);\r\n\t\t});\r\n\t},\r\n\t_getLatLngs: function (latlngA, latlngB, distance) {\r\n\t\tvar ret = [];\r\n\t\tconst n = this._getNumberLatLng(latlngA, latlngB, distance);\r\n\t\tvar angle = L.GeometryUtil.angle(this._map, latlngA, latlngB);\r\n\t\tfor (var i = 1; i <= n; i++) {\r\n\t\t\tret.push(L.GeometryUtil.destination(latlngA, angle, i * distance));\r\n\t\t}\r\n\t\treturn ret;\r\n\t},\r\n\t_getNumberLatLng: function (latlngA, latlngB, distance) {\r\n\t\treturn Math.floor(latlngA.distanceTo(latlngB) / distance);\r\n\t},\r\n\t_getLineX: function () {\r\n\t\treturn L.polyline([L.latLng(0, -180), L.latLng(0, 180)]);\r\n\t},\r\n\t_getLineY: function () {\r\n\t\treturn L.polyline([L.latLng(90, 0), L.latLng(-90, 0)]);\r\n\t},\r\n\t_getGocPhanTu: function () {\r\n\t\tconst angle = L.GeometryUtil.angle(\r\n\t\t\tthis._map,\r\n\t\t\tthis._gocO,\r\n\t\t\tthis._map.getCenter()\r\n\t\t);\r\n\t\tvar ret = 1;\r\n\t\tif (angle >= 0 && angle <= 90) {\r\n\t\t\tret = 1;\r\n\t\t} else if (angle > 90 && angle <= 180) {\r\n\t\t\tret = 2;\r\n\t\t} else if (angle > 180 && angle <= 270) {\r\n\t\t\tret = 3;\r\n\t\t} else {\r\n\t\t\tret = 4;\r\n\t\t}\r\n\t\treturn ret;\r\n\t},\r\n\t_getDistaceCenterToLineX() {\r\n\t\tconst latlngs = this._lineX.getLatLngs();\r\n\t\treturn L.GeometryUtil.closestOnSegment(\r\n\t\t\tthis._map,\r\n\t\t\tthis._map.getCenter(),\r\n\t\t\tlatlngs[0],\r\n\t\t\tlatlngs[1]\r\n\t\t).distanceTo(this._map.getCenter());\r\n\t},\r\n\t_getDistaceCenterToLineY() {\r\n\t\tconst latlngs = this._lineY.getLatLngs();\r\n\t\treturn L.GeometryUtil.closestOnSegment(\r\n\t\t\tthis._map,\r\n\t\t\tthis._map.getCenter(),\r\n\t\t\tlatlngs[0],\r\n\t\t\tlatlngs[1]\r\n\t\t).distanceTo(this._map.getCenter());\r\n\t},\r\n\t_getLatLngO: function () {\r\n\t\tconst gocPhanTu = this._getGocPhanTu();\r\n\t\tconst dY = this._getDistaceCenterToLineY();\r\n\t\tconst dX = this._getDistaceCenterToLineX();\r\n\t\tconst center = this._map.getCenter();\r\n\t\tvar rY = dY % this.options.width;\r\n\t\tvar rX = dX % this.options.height;\r\n\t\tif (rY !== 0 || rX !== 0) {\r\n\t\t\tif (gocPhanTu === 1) {\r\n\t\t\t\treturn L.GeometryUtil.destination(\r\n\t\t\t\t\tL.GeometryUtil.destination(center, 180, rX),\r\n\t\t\t\t\t-90,\r\n\t\t\t\t\trY\r\n\t\t\t\t);\r\n\t\t\t} else if (gocPhanTu === 2) {\r\n\t\t\t\treturn L.GeometryUtil.destination(\r\n\t\t\t\t\tL.GeometryUtil.destination(center, 0, rX),\r\n\t\t\t\t\t-90,\r\n\t\t\t\t\trY\r\n\t\t\t\t);\r\n\t\t\t} else if (gocPhanTu === 3) {\r\n\t\t\t\treturn L.GeometryUtil.destination(\r\n\t\t\t\t\tL.GeometryUtil.destination(center, 0, rX),\r\n\t\t\t\t\t90,\r\n\t\t\t\t\trY\r\n\t\t\t\t);\r\n\t\t\t} else {\r\n\t\t\t\treturn L.GeometryUtil.destination(\r\n\t\t\t\t\tL.GeometryUtil.destination(center, 180, rX),\r\n\t\t\t\t\t90,\r\n\t\t\t\t\trY\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn center;\r\n\t},\r\n\t_getDistanceToAB: function (latlng) {\r\n\t\treturn L.GeometryUtil.closestOnSegment(\r\n\t\t\tthis._map,\r\n\t\t\tlatlng,\r\n\t\t\tthis._getLatLngA(),\r\n\t\t\tthis._getLatLngB()\r\n\t\t).distanceTo(latlng);\r\n\t},\r\n\t_getDistanceToBC: function (latlng) {\r\n\t\treturn L.GeometryUtil.closestOnSegment(\r\n\t\t\tthis._map,\r\n\t\t\tlatlng,\r\n\t\t\tthis._getLatLngB(),\r\n\t\t\tthis._getLatLngC()\r\n\t\t).distanceTo(latlng);\r\n\t},\r\n\t_getDistanceToCD: function (latlng) {\r\n\t\treturn L.GeometryUtil.closestOnSegment(\r\n\t\t\tthis._map,\r\n\t\t\tlatlng,\r\n\t\t\tthis._getLatLngC(),\r\n\t\t\tthis._getLatLngD()\r\n\t\t).distanceTo(latlng);\r\n\t},\r\n\t_getDistanceToDA: function (latlng) {\r\n\t\treturn L.GeometryUtil.closestOnSegment(\r\n\t\t\tthis._map,\r\n\t\t\tlatlng,\r\n\t\t\tthis._getLatLngD(),\r\n\t\t\tthis._getLatLngA()\r\n\t\t).distanceTo(latlng);\r\n\t},\r\n\t_getLatLngA: function () {\r\n\t\treturn this._map.getBounds().getNorthWest();\r\n\t},\r\n\t_getLatLngB: function () {\r\n\t\treturn this._map.getBounds().getNorthEast();\r\n\t},\r\n\t_getLatLngC: function () {\r\n\t\treturn this._map.getBounds().getSouthEast();\r\n\t},\r\n\t_getLatLngD: function () {\r\n\t\treturn this._map.getBounds().getSouthWest();\r\n\t},\r\n});\r\n\r\nL.guideLayer = function (map, options) {\r\n\treturn new L.GuideLayer(map, options);\r\n};\r\n\r\n//#endregion\r\n","/**\r\n * Leaflet.draw assumes that you have already included the Leaflet library.\r\n */\r\nL.drawVersion = \"0.4.2\";\r\n/**\r\n * @class L.Draw\r\n * @aka Draw\r\n *\r\n *\r\n * To add the draw toolbar set the option drawControl: true in the map options.\r\n *\r\n * @example\r\n * ```js\r\n *      var map = L.map('map', {drawControl: true}).setView([51.505, -0.09], 13);\r\n *\r\n *      L.tileLayer('http://{s}.tile.osm.org/{z}/{x}/{y}.png', {\r\n *          attribution: '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors'\r\n *      }).addTo(map);\r\n * ```\r\n *\r\n * ### Adding the edit toolbar\r\n * To use the edit toolbar you must initialise the Leaflet.draw control and manually add it to the map.\r\n *\r\n * ```js\r\n *      var map = L.map('map').setView([51.505, -0.09], 13);\r\n *\r\n *      L.tileLayer('http://{s}.tile.osm.org/{z}/{x}/{y}.png', {\r\n *          attribution: '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors'\r\n *      }).addTo(map);\r\n *\r\n *      // FeatureGroup is to store editable layers\r\n *      var drawnItems = new L.FeatureGroup();\r\n *      map.addLayer(drawnItems);\r\n *\r\n *      var drawControl = new L.Control.Draw({\r\n *          edit: {\r\n *              featureGroup: drawnItems\r\n *          }\r\n *      });\r\n *      map.addControl(drawControl);\r\n * ```\r\n *\r\n * The key here is the featureGroup option. This tells the plugin which FeatureGroup contains the layers that\r\n * should be editable. The featureGroup can contain 0 or more features with geometry types Point, LineString, and Polygon.\r\n * Leaflet.draw does not work with multigeometry features such as MultiPoint, MultiLineString, MultiPolygon,\r\n * or GeometryCollection. If you need to add multigeometry features to the draw plugin, convert them to a\r\n * FeatureCollection of non-multigeometries (Points, LineStrings, or Polygons).\r\n */\r\nL.Draw = {};\r\n\r\n/**\r\n * @class L.drawLocal\r\n * @aka L.drawLocal\r\n *\r\n * The core toolbar class of the API — it is used to create the toolbar ui\r\n *\r\n * @example\r\n * ```js\r\n *      var modifiedDraw = L.drawLocal.extend({\r\n *          draw: {\r\n *              toolbar: {\r\n *                  buttons: {\r\n *                      polygon: 'Draw an awesome polygon'\r\n *                  }\r\n *              }\r\n *          }\r\n *      });\r\n * ```\r\n *\r\n * The default state for the control is the draw toolbar just below the zoom control.\r\n *  This will allow map users to draw vectors and markers.\r\n *  **Please note the edit toolbar is not enabled by default.**\r\n */\r\nL.drawLocal = {\r\n\t// format: {\r\n\t// \tnumeric: {\r\n\t// \t\tdelimiters: {\r\n\t// \t\t\tthousands: ',',\r\n\t// \t\t\tdecimal: '.'\r\n\t// \t\t}\r\n\t// \t}\r\n\t// },\r\n\tdraw: {\r\n\t\ttoolbar: {\r\n\t\t\t// #TODO: this should be reorganized where actions are nested in actions\r\n\t\t\t// ex: actions.undo  or actions.cancel\r\n\t\t\tactions: {\r\n\t\t\t\ttitle: \"Cancel drawing\",\r\n\t\t\t\ttext: \"Cancel\",\r\n\t\t\t},\r\n\t\t\tfinish: {\r\n\t\t\t\ttitle: \"Finish drawing\",\r\n\t\t\t\ttext: \"Finish\",\r\n\t\t\t},\r\n\t\t\tundo: {\r\n\t\t\t\ttitle: \"Delete last point drawn\",\r\n\t\t\t\ttext: \"Delete last point\",\r\n\t\t\t},\r\n\t\t\tbuttons: {\r\n\t\t\t\tpolyline: \"Draw a polyline\",\r\n\t\t\t\tpolygon: \"Draw a polygon\",\r\n\t\t\t\trectangle: \"Draw a rectangle\",\r\n\t\t\t\tcircle: \"Draw a circle\",\r\n\t\t\t\tmarker: \"Draw a marker\",\r\n\t\t\t\tcirclemarker: \"Draw a circlemarker\",\r\n\t\t\t\trole: \"Role\",\r\n\t\t\t\tthanhCai: \"Thanh cái\",\r\n\t\t\t\tmayBienAp: \"Máy biến áp\",\r\n\t\t\t\tduongDay: \"Đường dây\",\r\n\t\t\t},\r\n\t\t},\r\n\t\thandlers: {\r\n\t\t\tcircle: {\r\n\t\t\t\ttooltip: {\r\n\t\t\t\t\tstart: \"Click and drag to draw circle.\",\r\n\t\t\t\t},\r\n\t\t\t\tradius: \"Radius\",\r\n\t\t\t},\r\n\t\t\tcirclemarker: {\r\n\t\t\t\ttooltip: {\r\n\t\t\t\t\tstart: \"Click map to place circle marker.\",\r\n\t\t\t\t},\r\n\t\t\t},\r\n\t\t\tmarker: {\r\n\t\t\t\ttooltip: {\r\n\t\t\t\t\tstart: \"Click map to place marker.\",\r\n\t\t\t\t},\r\n\t\t\t},\r\n\t\t\tpolygon: {\r\n\t\t\t\ttooltip: {\r\n\t\t\t\t\tstart: \"Click to start drawing shape.\",\r\n\t\t\t\t\tcont: \"Click to continue drawing shape.\",\r\n\t\t\t\t\tend: \"Click first point to close this shape.\",\r\n\t\t\t\t},\r\n\t\t\t},\r\n\t\t\tpolyline: {\r\n\t\t\t\terror: \"<strong>Error:</strong> shape edges cannot cross!\",\r\n\t\t\t\ttooltip: {\r\n\t\t\t\t\tstart: \"Click to start drawing line.\",\r\n\t\t\t\t\tcont: \"Click to continue drawing line.\",\r\n\t\t\t\t\tend: \"Click last point to finish line.\",\r\n\t\t\t\t},\r\n\t\t\t},\r\n\t\t\trectangle: {\r\n\t\t\t\ttooltip: {\r\n\t\t\t\t\tstart: \"Click and drag to draw rectangle.\",\r\n\t\t\t\t},\r\n\t\t\t},\r\n\t\t\tsimpleshape: {\r\n\t\t\t\ttooltip: {\r\n\t\t\t\t\tend: \"Release mouse to finish drawing.\",\r\n\t\t\t\t},\r\n\t\t\t},\r\n\t\t\trole: {\r\n\t\t\t\ttooltip: {\r\n\t\t\t\t\tstart: \"Click để vẽ rơ-le.\",\r\n\t\t\t\t},\r\n\t\t\t},\r\n\t\t\tthanhCai: {\r\n\t\t\t\ttooltip: {\r\n\t\t\t\t\tstart: \"Click để vẽ thanh cái\",\r\n\t\t\t\t},\r\n\t\t\t},\r\n\t\t\tmayBienAp: {\r\n\t\t\t\ttooltip: {\r\n\t\t\t\t\tstart: \"Click để vẽ máy biến áp\",\r\n\t\t\t\t},\r\n\t\t\t},\r\n\t\t\tduongDay: {\r\n\t\t\t\terror: \"<strong>Error:</strong> shape edges cannot cross!\",\r\n\t\t\t\ttooltip: {\r\n\t\t\t\t\tstart: \"Click to start drawing line.\",\r\n\t\t\t\t\tcont: \"Click to continue drawing line.\",\r\n\t\t\t\t\tend: \"Click last point to finish line.\",\r\n\t\t\t\t},\r\n\t\t\t},\r\n\t\t},\r\n\t},\r\n\tedit: {\r\n\t\ttoolbar: {\r\n\t\t\tactions: {\r\n\t\t\t\tsave: {\r\n\t\t\t\t\ttitle: \"Save changes\",\r\n\t\t\t\t\ttext: \"Save\",\r\n\t\t\t\t},\r\n\t\t\t\tcancel: {\r\n\t\t\t\t\ttitle: \"Cancel editing, discards all changes\",\r\n\t\t\t\t\ttext: \"Cancel\",\r\n\t\t\t\t},\r\n\t\t\t\tclearAll: {\r\n\t\t\t\t\ttitle: \"Clear all layers\",\r\n\t\t\t\t\ttext: \"Clear All\",\r\n\t\t\t\t},\r\n\t\t\t},\r\n\t\t\tbuttons: {\r\n\t\t\t\tedit: \"Edit layers\",\r\n\t\t\t\teditDisabled: \"No layers to edit\",\r\n\t\t\t\tremove: \"Delete layers\",\r\n\t\t\t\tremoveDisabled: \"No layers to delete\",\r\n\t\t\t},\r\n\t\t},\r\n\t\thandlers: {\r\n\t\t\tedit: {\r\n\t\t\t\ttooltip: {\r\n\t\t\t\t\ttext: \"Drag handles or markers to edit features.\",\r\n\t\t\t\t\tsubtext: \"Click cancel to undo changes.\",\r\n\t\t\t\t},\r\n\t\t\t},\r\n\t\t\tremove: {\r\n\t\t\t\ttooltip: {\r\n\t\t\t\t\ttext: \"Click on a feature to remove.\",\r\n\t\t\t\t},\r\n\t\t\t},\r\n\t\t},\r\n\t},\r\n};\r\n","/**\r\n * ### Events\r\n * Once you have successfully added the Leaflet.draw plugin to your map you will want to respond to the different\r\n * actions users can initiate. The following events will be triggered on the map:\r\n *\r\n * @class L.Draw.Event\r\n * @aka Draw.Event\r\n *\r\n * Use `L.Draw.Event.EVENTNAME` constants to ensure events are correct.\r\n *\r\n * @example\r\n * ```js\r\n * map.on(L.Draw.Event.CREATED; function (e) {\r\n *    var type = e.layerType,\r\n *        layer = e.layer;\r\n *\r\n *    if (type === 'marker') {\r\n *        // Do marker specific actions\r\n *    }\r\n *\r\n *    // Do whatever else you need to. (save to db; add to map etc)\r\n *    map.addLayer(layer);\r\n *});\r\n * ```\r\n */\r\nL.Draw.Event = {};\r\n/**\r\n * @event draw:created: PolyLine; Polygon; Rectangle; Circle; Marker | String\r\n *\r\n * Layer that was just created.\r\n * The type of layer this is. One of: `polyline`; `polygon`; `rectangle`; `circle`; `marker`\r\n * Triggered when a new vector or marker has been created.\r\n *\r\n */\r\nL.Draw.Event.CREATED = \"draw:created\";\r\n\r\n/**\r\n * @event draw:edited: LayerGroup\r\n *\r\n * List of all layers just edited on the map.\r\n *\r\n *\r\n * Triggered when layers in the FeatureGroup; initialised with the plugin; have been edited and saved.\r\n *\r\n * @example\r\n * ```js\r\n *      map.on('draw:edited', function (e) {\r\n *          var layers = e.layers;\r\n *          layers.eachLayer(function (layer) {\r\n *              //do whatever you want; most likely save back to db\r\n *          });\r\n *      });\r\n * ```\r\n */\r\nL.Draw.Event.EDITED = \"draw:edited\";\r\n\r\n/**\r\n * @event draw:deleted: LayerGroup\r\n *\r\n * List of all layers just removed from the map.\r\n *\r\n * Triggered when layers have been removed (and saved) from the FeatureGroup.\r\n */\r\nL.Draw.Event.DELETED = \"draw:deleted\";\r\n\r\n/**\r\n * @event draw:drawstart: String\r\n *\r\n * The type of layer this is. One of:`polyline`; `polygon`; `rectangle`; `circle`; `marker`\r\n *\r\n * Triggered when the user has chosen to draw a particular vector or marker.\r\n */\r\nL.Draw.Event.DRAWSTART = \"draw:drawstart\";\r\n\r\n/**\r\n * @event draw:drawstop: String\r\n *\r\n * The type of layer this is. One of: `polyline`; `polygon`; `rectangle`; `circle`; `marker`\r\n *\r\n * Triggered when the user has finished a particular vector or marker.\r\n */\r\n\r\nL.Draw.Event.DRAWSTOP = \"draw:drawstop\";\r\n\r\n/**\r\n * @event draw:drawvertex: LayerGroup\r\n *\r\n * List of all layers just being added from the map.\r\n *\r\n * Triggered when a vertex is created on a polyline or polygon.\r\n */\r\nL.Draw.Event.DRAWVERTEX = \"draw:drawvertex\";\r\n\r\n/**\r\n * @event draw:editstart: String\r\n *\r\n * The type of edit this is. One of: `edit`\r\n *\r\n * Triggered when the user starts edit mode by clicking the edit tool button.\r\n */\r\n\r\nL.Draw.Event.EDITSTART = \"draw:editstart\";\r\n\r\n/**\r\n * @event draw:editmove: ILayer\r\n *\r\n *  Layer that was just moved.\r\n *\r\n * Triggered as the user moves a rectangle; circle or marker.\r\n */\r\nL.Draw.Event.EDITMOVE = \"draw:editmove\";\r\n\r\n/**\r\n * @event draw:editresize: ILayer\r\n *\r\n * Layer that was just moved.\r\n *\r\n * Triggered as the user resizes a rectangle or circle.\r\n */\r\nL.Draw.Event.EDITRESIZE = \"draw:editresize\";\r\n\r\n/**\r\n * @event draw:editrotate: ILayer\r\n *\r\n * Layer that was just moved.\r\n *\r\n * Triggered as the user rotate a object.\r\n */\r\nL.Draw.Event.EDITROTATE = \"draw:editrotate\";\r\n\r\n/**\r\n * @event draw:createmarker: ILayer\r\n *\r\n * Layer that was just moved.\r\n *\r\n * Triggered as the user rotate a object.\r\n */\r\nL.Draw.Event.CREATEMARKER = \"draw:createmarker\";\r\n\r\n/**\r\n * @event draw:editvertex: LayerGroup\r\n *\r\n * List of all layers just being edited from the map.\r\n *\r\n * Triggered when a vertex is edited on a polyline or polygon.\r\n */\r\nL.Draw.Event.EDITVERTEX = \"draw:editvertex\";\r\n\r\n/**\r\n * @event draw:editstop: String\r\n *\r\n * The type of edit this is. One of: `edit`\r\n *\r\n * Triggered when the user has finshed editing (edit mode) and saves edits.\r\n */\r\nL.Draw.Event.EDITSTOP = \"draw:editstop\";\r\n\r\n/**\r\n * @event draw:deletestart: String\r\n *\r\n * The type of edit this is. One of: `remove`\r\n *\r\n * Triggered when the user starts remove mode by clicking the remove tool button.\r\n */\r\nL.Draw.Event.DELETESTART = \"draw:deletestart\";\r\n\r\n/**\r\n * @event draw:deletestop: String\r\n *\r\n * The type of edit this is. One of: `remove`\r\n *\r\n * Triggered when the user has finished removing shapes (remove mode) and saves.\r\n */\r\nL.Draw.Event.DELETESTOP = \"draw:deletestop\";\r\n\r\n/**\r\n * @event draw:toolbaropened: String\r\n *\r\n * Triggered when a toolbar is opened.\r\n */\r\nL.Draw.Event.TOOLBAROPENED = \"draw:toolbaropened\";\r\n\r\n/**\r\n * @event draw:toolbarclosed: String\r\n *\r\n * Triggered when a toolbar is closed.\r\n */\r\nL.Draw.Event.TOOLBARCLOSED = \"draw:toolbarclosed\";\r\n\r\n/**\r\n * @event draw:markercontext: String\r\n *\r\n * Triggered when a marker is right clicked.\r\n */\r\nL.Draw.Event.MARKERCONTEXT = \"draw:markercontext\";\r\n","L.Draw = L.Draw || {};\r\n\r\n/**\r\n * @class L.Draw.Feature\r\n * @aka Draw.Feature\r\n */\r\nL.Draw.Feature = L.Handler.extend({\r\n\r\n\t// @method initialize(): void\r\n\tinitialize: function (map, options) {\r\n\t\tthis._map = map;\r\n\t\tthis._container = map._container;\r\n\t\tthis._overlayPane = map._panes.overlayPane;\r\n\t\tthis._popupPane = map._panes.popupPane;\r\n\r\n\t\t// Merge default shapeOptions options with custom shapeOptions\r\n\t\tif (options && options.shapeOptions) {\r\n\t\t\toptions.shapeOptions = L.Util.extend({}, this.options.shapeOptions, options.shapeOptions);\r\n\t\t}\r\n\t\tL.setOptions(this, options);\r\n\r\n\t\tvar version = L.version.split('.');\r\n\t\t//If Version is >= 1.2.0\r\n\t\tif (parseInt(version[0], 10) === 1 && parseInt(version[1], 10) >= 2) {\r\n\t\t\tL.Draw.Feature.include(L.Evented.prototype);\r\n\t\t} else {\r\n\t\t\tL.Draw.Feature.include(L.Mixin.Events);\r\n\t\t}\r\n\t},\r\n\r\n\t// @method enable(): void\r\n\t// Enables this handler\r\n\tenable: function () {\r\n\t\tif (this._enabled) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tL.Handler.prototype.enable.call(this);\r\n\r\n\t\tthis.fire('enabled', {handler: this.type});\r\n\r\n\t\tthis._map.fire(L.Draw.Event.DRAWSTART, {layerType: this.type});\r\n\t},\r\n\r\n\t// @method disable(): void\r\n\tdisable: function () {\r\n\t\tif (!this._enabled) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tL.Handler.prototype.disable.call(this);\r\n\r\n\t\tthis._map.fire(L.Draw.Event.DRAWSTOP, {layerType: this.type});\r\n\r\n\t\tthis.fire('disabled', {handler: this.type});\r\n\t},\r\n\r\n\t// @method addHooks(): void\r\n\t// Add's event listeners to this handler\r\n\taddHooks: function () {\r\n\t\tvar map = this._map;\r\n\r\n\t\tif (map) {\r\n\t\t\tL.DomUtil.disableTextSelection();\r\n\r\n\t\t\tmap.getContainer().focus();\r\n\r\n\t\t\tthis._tooltip = new L.Draw.Tooltip(this._map);\r\n\r\n\t\t\tL.DomEvent.on(this._container, 'keyup', this._cancelDrawing, this);\r\n\t\t}\r\n\t},\r\n\r\n\t// @method removeHooks(): void\r\n\t// Removes event listeners from this handler\r\n\tremoveHooks: function () {\r\n\t\tif (this._map) {\r\n\t\t\tL.DomUtil.enableTextSelection();\r\n\r\n\t\t\tthis._tooltip.dispose();\r\n\t\t\tthis._tooltip = null;\r\n\r\n\t\t\tL.DomEvent.off(this._container, 'keyup', this._cancelDrawing, this);\r\n\t\t}\r\n\t},\r\n\r\n\t// @method setOptions(object): void\r\n\t// Sets new options to this handler\r\n\tsetOptions: function (options) {\r\n\t\tL.setOptions(this, options);\r\n\t},\r\n\r\n\t_fireCreatedEvent: function (layer) {\r\n\t\tthis._map.fire(L.Draw.Event.CREATED, {layer: layer, layerType: this.type});\r\n\t},\r\n\r\n\t// Cancel drawing when the escape key is pressed\r\n\t_cancelDrawing: function (e) {\r\n\t\tif (e.keyCode === 27) {\r\n\t\t\tthis._map.fire('draw:canceled', {layerType: this.type});\r\n\t\t\tthis.disable();\r\n\t\t}\r\n\t}\r\n});\r\n","/**\r\n * @class L.Draw.Polyline\r\n * @aka Draw.Polyline\r\n * @inherits L.Draw.Feature\r\n */\r\nL.Draw.Polyline = L.Draw.Feature.extend({\r\n\tstatics: {\r\n\t\tTYPE: \"polyline\",\r\n\t},\r\n\r\n\tPoly: L.Polyline,\r\n\r\n\toptions: {\r\n\t\tallowIntersection: true,\r\n\t\trepeatMode: false,\r\n\t\tdrawError: {\r\n\t\t\tcolor: \"#b00b00\",\r\n\t\t\ttimeout: 2500,\r\n\t\t},\r\n\t\ticon: new L.DivIcon({\r\n\t\t\ticonSize: new L.Point(8, 8),\r\n\t\t\tclassName: \"leaflet-div-icon leaflet-editing-icon\",\r\n\t\t}),\r\n\t\ttouchIcon: new L.DivIcon({\r\n\t\t\ticonSize: new L.Point(20, 20),\r\n\t\t\tclassName: \"leaflet-div-icon leaflet-editing-icon leaflet-touch-icon\",\r\n\t\t}),\r\n\t\tguidelineDistance: 20,\r\n\t\tmaxGuideLineLength: 4000,\r\n\t\tshapeOptions: {\r\n\t\t\tstroke: true,\r\n\t\t\tcolor: \"#3388ff\",\r\n\t\t\tweight: 4,\r\n\t\t\topacity: 0.5,\r\n\t\t\tfill: false,\r\n\t\t\tclickable: true,\r\n\t\t},\r\n\t\tmetric: true, // Whether to use the metric measurement system or imperial\r\n\t\tfeet: true, // When not metric, to use feet instead of yards for display.\r\n\t\tnautic: false, // When not metric, not feet use nautic mile for display\r\n\t\tshowLength: true, // Whether to display distance in the tooltip\r\n\t\tzIndexOffset: 2000, // This should be > than the highest z-index any map layers\r\n\t\tfactor: 1, // To change distance calculation\r\n\t\tmaxPoints: 0, // Once this number of points are placed, finish shape,\r\n\t\tisEditPoly: true,\r\n\t},\r\n\r\n\t// @method initialize(): void\r\n\tinitialize: function (map, options) {\r\n\t\t// if touch, switch to touch icon\r\n\t\tif (L.Browser.touch) {\r\n\t\t\tthis.options.icon = this.options.touchIcon;\r\n\t\t}\r\n\r\n\t\t// Need to set this here to ensure the correct message is used.\r\n\t\tthis.options.drawError.message = L.drawLocal.draw.handlers.polyline.error;\r\n\r\n\t\t// Merge default drawError options with custom options\r\n\t\tif (options && options.drawError) {\r\n\t\t\toptions.drawError = L.Util.extend(\r\n\t\t\t\t{},\r\n\t\t\t\tthis.options.drawError,\r\n\t\t\t\toptions.drawError\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\t// Save the type so super can fire, need to do this as cannot do this.TYPE :(\r\n\t\tthis.type = L.Draw.Polyline.TYPE;\r\n\r\n\t\tL.Draw.Feature.prototype.initialize.call(this, map, options);\r\n\t},\r\n\r\n\t// @method addHooks(): void\r\n\t// Add listener hooks to this handler\r\n\taddHooks: function () {\r\n\t\tL.Draw.Feature.prototype.addHooks.call(this);\r\n\t\tif (this._map) {\r\n\t\t\tthis._markers = [];\r\n\r\n\t\t\tthis._markerGroup = new L.LayerGroup();\r\n\t\t\tthis._map.addLayer(this._markerGroup);\r\n\r\n\t\t\tthis._poly = new L.Polyline([], this.options.shapeOptions);\r\n\r\n\t\t\tthis._tooltip.updateContent(this._getTooltipText());\r\n\r\n\t\t\t// Make a transparent marker that will used to catch click events. These click\r\n\t\t\t// events will create the vertices. We need to do this so we can ensure that\r\n\t\t\t// we can create vertices over other map layers (markers, vector layers). We\r\n\t\t\t// also do not want to trigger any click handlers of objects we are clicking on\r\n\t\t\t// while drawing.\r\n\t\t\tif (!this._mouseMarker) {\r\n\t\t\t\tthis._mouseMarker = L.marker(this._map.getCenter(), {\r\n\t\t\t\t\ticon: L.divIcon({\r\n\t\t\t\t\t\tclassName: \"leaflet-mouse-marker\",\r\n\t\t\t\t\t\ticonAnchor: [20, 20],\r\n\t\t\t\t\t\ticonSize: [40, 40],\r\n\t\t\t\t\t}),\r\n\t\t\t\t\topacity: 0,\r\n\t\t\t\t\tzIndexOffset: this.options.zIndexOffset,\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tthis._mouseMarker\r\n\t\t\t\t.on(\"mouseout\", this._onMouseOut, this)\r\n\t\t\t\t.on(\"mousemove\", this._onMouseMove, this) // Necessary to prevent 0.8 stutter\r\n\t\t\t\t.on(\"mousedown\", this._onMouseDown, this)\r\n\t\t\t\t.on(\"mouseup\", this._onMouseUp, this) // Necessary for 0.8 compatibility\r\n\t\t\t\t.addTo(this._map);\r\n\r\n\t\t\tthis._map\r\n\t\t\t\t.on(\"mouseup\", this._onMouseUp, this) // Necessary for 0.7 compatibility\r\n\t\t\t\t.on(\"mousemove\", this._onMouseMove, this)\r\n\t\t\t\t.on(\"zoomlevelschange\", this._onZoomEnd, this)\r\n\t\t\t\t.on(\"touchstart\", this._onTouch, this)\r\n\t\t\t\t.on(\"zoomend\", this._onZoomEnd, this);\r\n\t\t}\r\n\t},\r\n\r\n\t// @method removeHooks(): void\r\n\t// Remove listener hooks from this handler.\r\n\tremoveHooks: function () {\r\n\t\tL.Draw.Feature.prototype.removeHooks.call(this);\r\n\r\n\t\tthis._clearHideErrorTimeout();\r\n\r\n\t\tthis._cleanUpShape();\r\n\r\n\t\t// remove markers from map\r\n\t\tthis._map.removeLayer(this._markerGroup);\r\n\t\tdelete this._markerGroup;\r\n\t\tdelete this._markers;\r\n\r\n\t\tthis._map.removeLayer(this._poly);\r\n\t\tdelete this._poly;\r\n\r\n\t\tthis._mouseMarker\r\n\t\t\t.off(\"mousedown\", this._onMouseDown, this)\r\n\t\t\t.off(\"mouseout\", this._onMouseOut, this)\r\n\t\t\t.off(\"mouseup\", this._onMouseUp, this)\r\n\t\t\t.off(\"mousemove\", this._onMouseMove, this);\r\n\t\tthis._map.removeLayer(this._mouseMarker);\r\n\t\tdelete this._mouseMarker;\r\n\r\n\t\t// clean up DOM\r\n\t\tthis._clearGuides();\r\n\r\n\t\tthis._map\r\n\t\t\t.off(\"mouseup\", this._onMouseUp, this)\r\n\t\t\t.off(\"mousemove\", this._onMouseMove, this)\r\n\t\t\t.off(\"zoomlevelschange\", this._onZoomEnd, this)\r\n\t\t\t.off(\"zoomend\", this._onZoomEnd, this)\r\n\t\t\t.off(\"touchstart\", this._onTouch, this)\r\n\t\t\t.off(\"click\", this._onTouch, this);\r\n\t},\r\n\r\n\t// @method deleteLastVertex(): void\r\n\t// Remove the last vertex from the polyline, removes polyline from map if only one point exists.\r\n\tdeleteLastVertex: function () {\r\n\t\tif (this._markers.length <= 1) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar lastMarker = this._markers.pop(),\r\n\t\t\tpoly = this._poly,\r\n\t\t\t// Replaces .spliceLatLngs()\r\n\t\t\tlatlngs = poly.getLatLngs(),\r\n\t\t\tlatlng = latlngs.splice(-1, 1)[0];\r\n\t\tthis._poly.setLatLngs(latlngs);\r\n\r\n\t\tthis._markerGroup.removeLayer(lastMarker);\r\n\r\n\t\tif (poly.getLatLngs().length < 2) {\r\n\t\t\tthis._map.removeLayer(poly);\r\n\t\t}\r\n\r\n\t\tthis._vertexChanged(latlng, false);\r\n\t},\r\n\r\n\t// @method addVertex(): void\r\n\t// Add a vertex to the end of the polyline\r\n\taddVertex: function (latlng) {\r\n\t\tvar markersLength = this._markers.length;\r\n\t\t// markersLength must be greater than or equal to 2 before intersections can occur\r\n\t\tif (\r\n\t\t\tmarkersLength >= 2 &&\r\n\t\t\t!this.options.allowIntersection &&\r\n\t\t\tthis._poly.newLatLngIntersects(latlng)\r\n\t\t) {\r\n\t\t\tthis._showErrorTooltip();\r\n\t\t\treturn;\r\n\t\t} else if (this._errorShown) {\r\n\t\t\tthis._hideErrorTooltip();\r\n\t\t}\r\n\r\n\t\tthis._markers.push(this._createMarker(latlng));\r\n\r\n\t\tthis._poly.addLatLng(latlng);\r\n\r\n\t\tif (this._poly.getLatLngs().length === 2) {\r\n\t\t\tthis._map.addLayer(this._poly);\r\n\t\t}\r\n\r\n\t\tthis._vertexChanged(latlng, true);\r\n\t},\r\n\r\n\t// @method completeShape(): void\r\n\t// Closes the polyline between the first and last points\r\n\tcompleteShape: function () {\r\n\t\tif (this._markers.length <= 1 || !this._shapeIsValid()) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis._fireCreatedEvent();\r\n\t\tthis.disable();\r\n\r\n\t\tif (this.options.repeatMode) {\r\n\t\t\tthis.enable();\r\n\t\t}\r\n\t},\r\n\r\n\t_finishShape: function () {\r\n\t\tvar latlngs = this._poly._defaultShape\r\n\t\t\t? this._poly._defaultShape()\r\n\t\t\t: this._poly.getLatLngs();\r\n\t\tvar intersects = this._poly.newLatLngIntersects(\r\n\t\t\tlatlngs[latlngs.length - 1]\r\n\t\t);\r\n\r\n\t\tif (\r\n\t\t\t(!this.options.allowIntersection && intersects) ||\r\n\t\t\t!this._shapeIsValid()\r\n\t\t) {\r\n\t\t\tthis._showErrorTooltip();\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis._fireCreatedEvent();\r\n\t\tthis.disable();\r\n\t\tif (this.options.repeatMode) {\r\n\t\t\tthis.enable();\r\n\t\t}\r\n\t},\r\n\r\n\t// Called to verify the shape is valid when the user tries to finish it\r\n\t// Return false if the shape is not valid\r\n\t_shapeIsValid: function () {\r\n\t\treturn true;\r\n\t},\r\n\r\n\t_onZoomEnd: function () {\r\n\t\tif (this._markers !== null) {\r\n\t\t\tthis._updateGuide();\r\n\t\t}\r\n\t},\r\n\r\n\t_onMouseMove: function (e) {\r\n\t\tvar newPos = this._map.mouseEventToLayerPoint(e.originalEvent);\r\n\t\tvar latlng = this._map.layerPointToLatLng(newPos);\r\n\r\n\t\t// Save latlng\r\n\t\t// should this be moved to _updateGuide() ?\r\n\t\tthis._currentLatLng = latlng;\r\n\r\n\t\tthis._updateTooltip(latlng);\r\n\r\n\t\t// Update the guide line\r\n\t\tthis._updateGuide(newPos);\r\n\r\n\t\t// Update the mouse marker position\r\n\t\tthis._mouseMarker.setLatLng(latlng);\r\n\r\n\t\tL.DomEvent.preventDefault(e.originalEvent);\r\n\t},\r\n\r\n\t_vertexChanged: function (latlng, added) {\r\n\t\tthis._map.fire(L.Draw.Event.DRAWVERTEX, { layers: this._markerGroup });\r\n\t\tthis._updateFinishHandler();\r\n\r\n\t\tthis._updateRunningMeasure(latlng, added);\r\n\r\n\t\tthis._clearGuides();\r\n\r\n\t\tthis._updateTooltip();\r\n\t},\r\n\r\n\t_onMouseDown: function (e) {\r\n\t\tif (!this._clickHandled && !this._touchHandled && !this._disableMarkers) {\r\n\t\t\tthis._onMouseMove(e);\r\n\t\t\tthis._clickHandled = true;\r\n\t\t\tthis._disableNewMarkers();\r\n\t\t\tvar originalEvent = e.originalEvent;\r\n\t\t\tvar clientX = originalEvent.clientX;\r\n\t\t\tvar clientY = originalEvent.clientY;\r\n\t\t\tthis._startPoint.call(this, clientX, clientY);\r\n\t\t}\r\n\t},\r\n\r\n\t_startPoint: function (clientX, clientY) {\r\n\t\tthis._mouseDownOrigin = L.point(clientX, clientY);\r\n\t},\r\n\r\n\t_onMouseUp: function (e) {\r\n\t\tvar originalEvent = e.originalEvent;\r\n\t\tvar clientX = originalEvent.clientX;\r\n\t\tvar clientY = originalEvent.clientY;\r\n\t\tthis._endPoint.call(this, clientX, clientY, e);\r\n\t\tthis._clickHandled = null;\r\n\t},\r\n\r\n\t_endPoint: function (clientX, clientY, e) {\r\n\t\tif (this._mouseDownOrigin) {\r\n\t\t\tvar dragCheckDistance = L.point(clientX, clientY).distanceTo(\r\n\t\t\t\tthis._mouseDownOrigin\r\n\t\t\t);\r\n\t\t\tvar lastPtDistance = this._calculateFinishDistance(e.latlng);\r\n\t\t\tif (\r\n\t\t\t\tthis.options.maxPoints > 1 &&\r\n\t\t\t\tthis.options.maxPoints == this._markers.length + 1\r\n\t\t\t) {\r\n\t\t\t\tthis.addVertex(e.latlng);\r\n\t\t\t\tthis._finishShape();\r\n\t\t\t} else if (lastPtDistance < 10 && L.Browser.touch) {\r\n\t\t\t\tthis._finishShape();\r\n\t\t\t} else if (\r\n\t\t\t\tMath.abs(dragCheckDistance) <\r\n\t\t\t\t9 * (window.devicePixelRatio || 1)\r\n\t\t\t) {\r\n\t\t\t\t// this.addVertex(e.latlng);\r\n\r\n\t\t\t\tthis.addVertex(this._mouseMarker._latlng);\r\n\t\t\t}\r\n\t\t\tthis._enableNewMarkers(); // after a short pause, enable new markers\r\n\t\t}\r\n\t\tthis._mouseDownOrigin = null;\r\n\t},\r\n\r\n\t// ontouch prevented by clickHandled flag because some browsers fire both click/touch events,\r\n\t// causing unwanted behavior\r\n\t_onTouch: function (e) {\r\n\t\tvar originalEvent = e.originalEvent;\r\n\t\tvar clientX;\r\n\t\tvar clientY;\r\n\t\tif (\r\n\t\t\toriginalEvent.touches &&\r\n\t\t\toriginalEvent.touches[0] &&\r\n\t\t\t!this._clickHandled &&\r\n\t\t\t!this._touchHandled &&\r\n\t\t\t!this._disableMarkers\r\n\t\t) {\r\n\t\t\tclientX = originalEvent.touches[0].clientX;\r\n\t\t\tclientY = originalEvent.touches[0].clientY;\r\n\t\t\tthis._disableNewMarkers();\r\n\t\t\tthis._touchHandled = true;\r\n\t\t\tthis._startPoint.call(this, clientX, clientY);\r\n\t\t\tthis._endPoint.call(this, clientX, clientY, e);\r\n\t\t\tthis._touchHandled = null;\r\n\t\t}\r\n\t\tthis._clickHandled = null;\r\n\t},\r\n\r\n\t_onMouseOut: function () {\r\n\t\tif (this._tooltip) {\r\n\t\t\tthis._tooltip._onMouseOut.call(this._tooltip);\r\n\t\t}\r\n\t},\r\n\r\n\t// calculate if we are currently within close enough distance\r\n\t// of the closing point (first point for shapes, last point for lines)\r\n\t// this is semi-ugly code but the only reliable way i found to get the job done\r\n\t// note: calculating point.distanceTo between mouseDownOrigin and last marker did NOT work\r\n\t_calculateFinishDistance: function (potentialLatLng) {\r\n\t\tvar lastPtDistance;\r\n\t\tif (this._markers.length > 0) {\r\n\t\t\tvar finishMarker;\r\n\t\t\tif (this.type === L.Draw.Polyline.TYPE) {\r\n\t\t\t\tfinishMarker = this._markers[this._markers.length - 1];\r\n\t\t\t} else if (this.type === L.Draw.Polygon.TYPE) {\r\n\t\t\t\tfinishMarker = this._markers[0];\r\n\t\t\t} else {\r\n\t\t\t\treturn Infinity;\r\n\t\t\t}\r\n\t\t\tvar lastMarkerPoint = this._map.latLngToContainerPoint(\r\n\t\t\t\t\tfinishMarker.getLatLng()\r\n\t\t\t\t),\r\n\t\t\t\tpotentialMarker = new L.Marker(potentialLatLng, {\r\n\t\t\t\t\ticon: this.options.icon,\r\n\t\t\t\t\tzIndexOffset: this.options.zIndexOffset * 2,\r\n\t\t\t\t});\r\n\t\t\tvar potentialMarkerPint = this._map.latLngToContainerPoint(\r\n\t\t\t\tpotentialMarker.getLatLng()\r\n\t\t\t);\r\n\t\t\tlastPtDistance = lastMarkerPoint.distanceTo(potentialMarkerPint);\r\n\t\t} else {\r\n\t\t\tlastPtDistance = Infinity;\r\n\t\t}\r\n\t\treturn lastPtDistance;\r\n\t},\r\n\r\n\t_updateFinishHandler: function () {\r\n\t\tvar markerCount = this._markers.length;\r\n\t\t// The last marker should have a click handler to close the polyline\r\n\t\tif (markerCount > 1) {\r\n\t\t\tthis._markers[markerCount - 1].on(\"click\", this._finishShape, this);\r\n\t\t}\r\n\r\n\t\t// Remove the old marker click handler (as only the last point should close the polyline)\r\n\t\tif (markerCount > 2) {\r\n\t\t\tthis._markers[markerCount - 2].off(\"click\", this._finishShape, this);\r\n\t\t}\r\n\t},\r\n\r\n\t_createMarker: function (latlng) {\r\n\t\tvar marker = new L.Marker(latlng, {\r\n\t\t\ticon: this.options.icon,\r\n\t\t\tzIndexOffset: this.options.zIndexOffset * 2,\r\n\t\t});\r\n\r\n\t\tthis._markerGroup.addLayer(marker);\r\n\r\n\t\treturn marker;\r\n\t},\r\n\r\n\t_updateGuide: function (newPos) {\r\n\t\tvar markerCount = this._markers ? this._markers.length : 0;\r\n\r\n\t\tif (markerCount > 0) {\r\n\t\t\tnewPos = newPos || this._map.latLngToLayerPoint(this._currentLatLng);\r\n\r\n\t\t\t// draw the guide line\r\n\t\t\tthis._clearGuides();\r\n\t\t\tthis._drawGuide(\r\n\t\t\t\tthis._map.latLngToLayerPoint(\r\n\t\t\t\t\tthis._markers[markerCount - 1].getLatLng()\r\n\t\t\t\t),\r\n\t\t\t\tnewPos\r\n\t\t\t);\r\n\t\t}\r\n\t},\r\n\r\n\t_updateTooltip: function (latLng) {\r\n\t\tvar text = this._getTooltipText();\r\n\r\n\t\tif (latLng) {\r\n\t\t\tthis._tooltip.updatePosition(latLng);\r\n\t\t}\r\n\r\n\t\tif (!this._errorShown) {\r\n\t\t\tthis._tooltip.updateContent(text);\r\n\t\t}\r\n\t},\r\n\r\n\t_drawGuide: function (pointA, pointB) {\r\n\t\tvar length = Math.floor(\r\n\t\t\t\tMath.sqrt(\r\n\t\t\t\t\tMath.pow(pointB.x - pointA.x, 2) + Math.pow(pointB.y - pointA.y, 2)\r\n\t\t\t\t)\r\n\t\t\t),\r\n\t\t\tguidelineDistance = this.options.guidelineDistance,\r\n\t\t\tmaxGuideLineLength = this.options.maxGuideLineLength,\r\n\t\t\t// Only draw a guideline with a max length\r\n\t\t\ti =\r\n\t\t\t\tlength > maxGuideLineLength\r\n\t\t\t\t\t? length - maxGuideLineLength\r\n\t\t\t\t\t: guidelineDistance,\r\n\t\t\tfraction,\r\n\t\t\tdashPoint,\r\n\t\t\tdash;\r\n\r\n\t\t//create the guides container if we haven't yet\r\n\t\tif (!this._guidesContainer) {\r\n\t\t\tthis._guidesContainer = L.DomUtil.create(\r\n\t\t\t\t\"div\",\r\n\t\t\t\t\"leaflet-draw-guides\",\r\n\t\t\t\tthis._overlayPane\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\t//draw a dash every GuildeLineDistance\r\n\t\tfor (; i < length; i += this.options.guidelineDistance) {\r\n\t\t\t//work out fraction along line we are\r\n\t\t\tfraction = i / length;\r\n\r\n\t\t\t//calculate new x,y point\r\n\t\t\tdashPoint = {\r\n\t\t\t\tx: Math.floor(pointA.x * (1 - fraction) + fraction * pointB.x),\r\n\t\t\t\ty: Math.floor(pointA.y * (1 - fraction) + fraction * pointB.y),\r\n\t\t\t};\r\n\r\n\t\t\t//add guide dash to guide container\r\n\t\t\tdash = L.DomUtil.create(\r\n\t\t\t\t\"div\",\r\n\t\t\t\t\"leaflet-draw-guide-dash\",\r\n\t\t\t\tthis._guidesContainer\r\n\t\t\t);\r\n\t\t\tdash.style.backgroundColor = !this._errorShown\r\n\t\t\t\t? this.options.shapeOptions.color\r\n\t\t\t\t: this.options.drawError.color;\r\n\r\n\t\t\tL.DomUtil.setPosition(dash, dashPoint);\r\n\t\t}\r\n\t},\r\n\r\n\t_updateGuideColor: function (color) {\r\n\t\tif (this._guidesContainer) {\r\n\t\t\tfor (var i = 0, l = this._guidesContainer.childNodes.length; i < l; i++) {\r\n\t\t\t\tthis._guidesContainer.childNodes[i].style.backgroundColor = color;\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t// removes all child elements (guide dashes) from the guides container\r\n\t_clearGuides: function () {\r\n\t\tif (this._guidesContainer) {\r\n\t\t\twhile (this._guidesContainer.firstChild) {\r\n\t\t\t\tthis._guidesContainer.removeChild(this._guidesContainer.firstChild);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_getTooltipText: function () {\r\n\t\tvar showLength = this.options.showLength,\r\n\t\t\tlabelText,\r\n\t\t\tdistanceStr;\r\n\t\tif (this._markers.length === 0) {\r\n\t\t\tlabelText = {\r\n\t\t\t\ttext: L.drawLocal.draw.handlers.polyline.tooltip.start,\r\n\t\t\t};\r\n\t\t} else {\r\n\t\t\tdistanceStr = showLength ? this._getMeasurementString() : \"\";\r\n\r\n\t\t\tif (this._markers.length === 1) {\r\n\t\t\t\tlabelText = {\r\n\t\t\t\t\ttext: L.drawLocal.draw.handlers.polyline.tooltip.cont,\r\n\t\t\t\t\tsubtext: distanceStr,\r\n\t\t\t\t};\r\n\t\t\t} else {\r\n\t\t\t\tlabelText = {\r\n\t\t\t\t\ttext: L.drawLocal.draw.handlers.polyline.tooltip.end,\r\n\t\t\t\t\tsubtext: distanceStr,\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn labelText;\r\n\t},\r\n\r\n\t_updateRunningMeasure: function (latlng, added) {\r\n\t\tvar markersLength = this._markers.length,\r\n\t\t\tpreviousMarkerIndex,\r\n\t\t\tdistance;\r\n\r\n\t\tif (this._markers.length === 1) {\r\n\t\t\tthis._measurementRunningTotal = 0;\r\n\t\t} else {\r\n\t\t\tpreviousMarkerIndex = markersLength - (added ? 2 : 1);\r\n\r\n\t\t\t// Calculate the distance based on the version\r\n\t\t\tif (L.GeometryUtil.isVersion07x()) {\r\n\t\t\t\tdistance =\r\n\t\t\t\t\tlatlng.distanceTo(this._markers[previousMarkerIndex].getLatLng()) *\r\n\t\t\t\t\t(this.options.factor || 1);\r\n\t\t\t} else {\r\n\t\t\t\tdistance =\r\n\t\t\t\t\tthis._map.distance(\r\n\t\t\t\t\t\tlatlng,\r\n\t\t\t\t\t\tthis._markers[previousMarkerIndex].getLatLng()\r\n\t\t\t\t\t) * (this.options.factor || 1);\r\n\t\t\t}\r\n\r\n\t\t\tthis._measurementRunningTotal += distance * (added ? 1 : -1);\r\n\t\t}\r\n\t},\r\n\r\n\t_getMeasurementString: function () {\r\n\t\tvar currentLatLng = this._currentLatLng,\r\n\t\t\tpreviousLatLng = this._markers[this._markers.length - 1].getLatLng(),\r\n\t\t\tdistance;\r\n\r\n\t\t// Calculate the distance from the last fixed point to the mouse position based on the version\r\n\t\tif (L.GeometryUtil.isVersion07x()) {\r\n\t\t\tdistance =\r\n\t\t\t\tpreviousLatLng && currentLatLng && currentLatLng.distanceTo\r\n\t\t\t\t\t? this._measurementRunningTotal +\r\n\t\t\t\t\t  currentLatLng.distanceTo(previousLatLng) *\r\n\t\t\t\t\t\t\t(this.options.factor || 1)\r\n\t\t\t\t\t: this._measurementRunningTotal || 0;\r\n\t\t} else {\r\n\t\t\tdistance =\r\n\t\t\t\tpreviousLatLng && currentLatLng\r\n\t\t\t\t\t? this._measurementRunningTotal +\r\n\t\t\t\t\t  this._map.distance(currentLatLng, previousLatLng) *\r\n\t\t\t\t\t\t\t(this.options.factor || 1)\r\n\t\t\t\t\t: this._measurementRunningTotal || 0;\r\n\t\t}\r\n\r\n\t\treturn L.GeometryUtil.readableDistance(\r\n\t\t\tdistance,\r\n\t\t\tthis.options.metric,\r\n\t\t\tthis.options.feet,\r\n\t\t\tthis.options.nautic,\r\n\t\t\tthis.options.precision\r\n\t\t);\r\n\t},\r\n\r\n\t_showErrorTooltip: function () {\r\n\t\tthis._errorShown = true;\r\n\r\n\t\t// Update tooltip\r\n\t\tthis._tooltip\r\n\t\t\t.showAsError()\r\n\t\t\t.updateContent({ text: this.options.drawError.message });\r\n\r\n\t\t// Update shape\r\n\t\tthis._updateGuideColor(this.options.drawError.color);\r\n\t\tthis._poly.setStyle({ color: this.options.drawError.color });\r\n\r\n\t\t// Hide the error after 2 seconds\r\n\t\tthis._clearHideErrorTimeout();\r\n\t\tthis._hideErrorTimeout = setTimeout(\r\n\t\t\tL.Util.bind(this._hideErrorTooltip, this),\r\n\t\t\tthis.options.drawError.timeout\r\n\t\t);\r\n\t},\r\n\r\n\t_hideErrorTooltip: function () {\r\n\t\tthis._errorShown = false;\r\n\r\n\t\tthis._clearHideErrorTimeout();\r\n\r\n\t\t// Revert tooltip\r\n\t\tthis._tooltip.removeError().updateContent(this._getTooltipText());\r\n\r\n\t\t// Revert shape\r\n\t\tthis._updateGuideColor(this.options.shapeOptions.color);\r\n\t\tthis._poly.setStyle({ color: this.options.shapeOptions.color });\r\n\t},\r\n\r\n\t_clearHideErrorTimeout: function () {\r\n\t\tif (this._hideErrorTimeout) {\r\n\t\t\tclearTimeout(this._hideErrorTimeout);\r\n\t\t\tthis._hideErrorTimeout = null;\r\n\t\t}\r\n\t},\r\n\r\n\t// disable new markers temporarily;\r\n\t// this is to prevent duplicated touch/click events in some browsers\r\n\t_disableNewMarkers: function () {\r\n\t\tthis._disableMarkers = true;\r\n\t},\r\n\r\n\t// see _disableNewMarkers\r\n\t_enableNewMarkers: function () {\r\n\t\tsetTimeout(\r\n\t\t\tfunction () {\r\n\t\t\t\tthis._disableMarkers = false;\r\n\t\t\t}.bind(this),\r\n\t\t\t50\r\n\t\t);\r\n\t},\r\n\r\n\t_cleanUpShape: function () {\r\n\t\tif (this._markers.length > 1) {\r\n\t\t\tthis._markers[this._markers.length - 1].off(\r\n\t\t\t\t\"click\",\r\n\t\t\t\tthis._finishShape,\r\n\t\t\t\tthis\r\n\t\t\t);\r\n\t\t}\r\n\t},\r\n\r\n\t_fireCreatedEvent: function () {\r\n\t\tvar poly = new this.Poly(\r\n\t\t\tthis._poly.getLatLngs(),\r\n\t\t\tthis.options.shapeOptions\r\n\t\t);\r\n\t\tL.Draw.Feature.prototype._fireCreatedEvent.call(this, poly);\r\n\t},\r\n});\r\n","/**\r\n * @class L.Draw.Polygon\r\n * @aka Draw.Polygon\r\n * @inherits L.Draw.Polyline\r\n */\r\nL.Draw.Polygon = L.Draw.Polyline.extend({\r\n\tstatics: {\r\n\t\tTYPE: 'polygon'\r\n\t},\r\n\r\n\tPoly: L.Polygon,\r\n\r\n\toptions: {\r\n\t\tshowArea: false,\r\n\t\tshowLength: false,\r\n\t\tshapeOptions: {\r\n\t\t\tstroke: true,\r\n\t\t\tcolor: '#3388ff',\r\n\t\t\tweight: 4,\r\n\t\t\topacity: 0.5,\r\n\t\t\tfill: true,\r\n\t\t\tfillColor: null, //same as color by default\r\n\t\t\tfillOpacity: 0.2,\r\n\t\t\tclickable: true\r\n\t\t},\r\n\t\t// Whether to use the metric measurement system (truthy) or not (falsy).\r\n\t\t// Also defines the units to use for the metric system as an array of\r\n\t\t// strings (e.g. `['ha', 'm']`).\r\n\t\tmetric: true,\r\n\t\tfeet: true, // When not metric, to use feet instead of yards for display.\r\n\t\tnautic: false, // When not metric, not feet use nautic mile for display\r\n\t\t// Defines the precision for each type of unit (e.g. {km: 2, ft: 0}\r\n\t\tprecision: {}\r\n\t},\r\n\r\n\t// @method initialize(): void\r\n\tinitialize: function (map, options) {\r\n\t\tL.Draw.Polyline.prototype.initialize.call(this, map, options);\r\n\r\n\t\t// Save the type so super can fire, need to do this as cannot do this.TYPE :(\r\n\t\tthis.type = L.Draw.Polygon.TYPE;\r\n\t},\r\n\r\n\t_updateFinishHandler: function () {\r\n\t\tvar markerCount = this._markers.length;\r\n\r\n\t\t// The first marker should have a click handler to close the polygon\r\n\t\tif (markerCount === 1) {\r\n\t\t\tthis._markers[0].on('click', this._finishShape, this);\r\n\t\t}\r\n\r\n\t\t// Add and update the double click handler\r\n\t\tif (markerCount > 2) {\r\n\t\t\tthis._markers[markerCount - 1].on('dblclick', this._finishShape, this);\r\n\t\t\t// Only need to remove handler if has been added before\r\n\t\t\tif (markerCount > 3) {\r\n\t\t\t\tthis._markers[markerCount - 2].off('dblclick', this._finishShape, this);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_getTooltipText: function () {\r\n\t\tvar text, subtext;\r\n\r\n\t\tif (this._markers.length === 0) {\r\n\t\t\ttext = L.drawLocal.draw.handlers.polygon.tooltip.start;\r\n\t\t} else if (this._markers.length < 3) {\r\n\t\t\ttext = L.drawLocal.draw.handlers.polygon.tooltip.cont;\r\n\t\t\tsubtext = this._getMeasurementString();\r\n\t\t} else {\r\n\t\t\ttext = L.drawLocal.draw.handlers.polygon.tooltip.end;\r\n\t\t\tsubtext = this._getMeasurementString();\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\ttext: text,\r\n\t\t\tsubtext: subtext\r\n\t\t};\r\n\t},\r\n\r\n\t_getMeasurementString: function () {\r\n\t\tvar area = this._area,\r\n\t\t\tmeasurementString = '';\r\n\r\n\r\n\t\tif (!area && !this.options.showLength) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tif (this.options.showLength) {\r\n\t\t\tmeasurementString = L.Draw.Polyline.prototype._getMeasurementString.call(this);\r\n\t\t}\r\n\r\n\t\tif (area) {\r\n\t\t\tmeasurementString += '<br>' + L.GeometryUtil.readableArea(area, this.options.metric, this.options.precision);\r\n\t\t}\r\n\r\n\t\treturn measurementString;\r\n\t},\r\n\r\n\t_shapeIsValid: function () {\r\n\t\treturn this._markers.length >= 3;\r\n\t},\r\n\r\n\t_vertexChanged: function (latlng, added) {\r\n\t\tvar latLngs;\r\n\r\n\t\t// Check to see if we should show the area\r\n\t\tif (!this.options.allowIntersection && this.options.showArea) {\r\n\t\t\tlatLngs = this._poly.getLatLngs();\r\n\r\n\t\t\tthis._area = L.GeometryUtil.geodesicArea(latLngs);\r\n\t\t}\r\n\r\n\t\tL.Draw.Polyline.prototype._vertexChanged.call(this, latlng, added);\r\n\t},\r\n\r\n\t_cleanUpShape: function () {\r\n\t\tvar markerCount = this._markers.length;\r\n\r\n\t\tif (markerCount > 0) {\r\n\t\t\tthis._markers[0].off('click', this._finishShape, this);\r\n\r\n\t\t\tif (markerCount > 2) {\r\n\t\t\t\tthis._markers[markerCount - 1].off('dblclick', this._finishShape, this);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n});\r\n","L.SimpleShape = {};\r\n/**\r\n * @class L.Draw.SimpleShape\r\n * @aka Draw.SimpleShape\r\n * @inherits L.Draw.Feature\r\n */\r\nL.Draw.SimpleShape = L.Draw.Feature.extend({\r\n\toptions: {\r\n\t\trepeatMode: false\r\n\t},\r\n\r\n\t// @method initialize(): void\r\n\tinitialize: function (map, options) {\r\n\t\tthis._endLabelText = L.drawLocal.draw.handlers.simpleshape.tooltip.end;\r\n\r\n\t\tL.Draw.Feature.prototype.initialize.call(this, map, options);\r\n\t},\r\n\r\n\t// @method addHooks(): void\r\n\t// Add listener hooks to this handler.\r\n\taddHooks: function () {\r\n\t\tL.Draw.Feature.prototype.addHooks.call(this);\r\n\t\tif (this._map) {\r\n\t\t\tthis._mapDraggable = this._map.dragging.enabled();\r\n\r\n\t\t\tif (this._mapDraggable) {\r\n\t\t\t\tthis._map.dragging.disable();\r\n\t\t\t}\r\n\r\n\t\t\t//TODO refactor: move cursor to styles\r\n\t\t\tthis._container.style.cursor = 'crosshair';\r\n\r\n\t\t\tthis._tooltip.updateContent({text: this._initialLabelText});\r\n\r\n\t\t\tthis._map\r\n\t\t\t\t.on('mousedown', this._onMouseDown, this)\r\n\t\t\t\t.on('mousemove', this._onMouseMove, this)\r\n\t\t\t\t.on('touchstart', this._onMouseDown, this)\r\n\t\t\t\t.on('touchmove', this._onMouseMove, this);\r\n\r\n\t\t\t// we should prevent default, otherwise default behavior (scrolling) will fire,\r\n\t\t\t// and that will cause document.touchend to fire and will stop the drawing\r\n\t\t\t// (circle, rectangle) in touch mode.\r\n\t\t\t// (update): we have to send passive now to prevent scroll, because by default it is {passive: true} now, which means,\r\n\t\t\t// handler can't event.preventDefault\r\n\t\t\t// check the news https://developers.google.com/web/updates/2016/06/passive-event-listeners\r\n\t\t\tdocument.addEventListener('touchstart', L.DomEvent.preventDefault, {passive: false});\r\n\t\t}\r\n\t},\r\n\r\n\t// @method removeHooks(): void\r\n\t// Remove listener hooks from this handler.\r\n\tremoveHooks: function () {\r\n\t\tL.Draw.Feature.prototype.removeHooks.call(this);\r\n\t\tif (this._map) {\r\n\t\t\tif (this._mapDraggable) {\r\n\t\t\t\tthis._map.dragging.enable();\r\n\t\t\t}\r\n\r\n\t\t\t//TODO refactor: move cursor to styles\r\n\t\t\tthis._container.style.cursor = '';\r\n\r\n\t\t\tthis._map\r\n\t\t\t\t.off('mousedown', this._onMouseDown, this)\r\n\t\t\t\t.off('mousemove', this._onMouseMove, this)\r\n\t\t\t\t.off('touchstart', this._onMouseDown, this)\r\n\t\t\t\t.off('touchmove', this._onMouseMove, this);\r\n\r\n\t\t\tL.DomEvent.off(document, 'mouseup', this._onMouseUp, this);\r\n\t\t\tL.DomEvent.off(document, 'touchend', this._onMouseUp, this);\r\n\r\n\t\t\tdocument.removeEventListener('touchstart', L.DomEvent.preventDefault);\r\n\r\n\t\t\t// If the box element doesn't exist they must not have moved the mouse, so don't need to destroy/return\r\n\t\t\tif (this._shape) {\r\n\t\t\t\tthis._map.removeLayer(this._shape);\r\n\t\t\t\tdelete this._shape;\r\n\t\t\t}\r\n\t\t}\r\n\t\tthis._isDrawing = false;\r\n\t},\r\n\r\n\t_getTooltipText: function () {\r\n\t\treturn {\r\n\t\t\ttext: this._endLabelText\r\n\t\t};\r\n\t},\r\n\r\n\t_onMouseDown: function (e) {\r\n\t\tthis._isDrawing = true;\r\n\t\tthis._startLatLng = e.latlng;\r\n\r\n\t\tL.DomEvent\r\n\t\t\t.on(document, 'mouseup', this._onMouseUp, this)\r\n\t\t\t.on(document, 'touchend', this._onMouseUp, this)\r\n\t\t\t.preventDefault(e.originalEvent);\r\n\t},\r\n\r\n\t_onMouseMove: function (e) {\r\n\t\tvar latlng = e.latlng;\r\n\r\n\t\tthis._tooltip.updatePosition(latlng);\r\n\t\tif (this._isDrawing) {\r\n\t\t\tthis._tooltip.updateContent(this._getTooltipText());\r\n\t\t\tthis._drawShape(latlng);\r\n\t\t}\r\n\t},\r\n\r\n\t_onMouseUp: function () {\r\n\t\tif (this._shape) {\r\n\t\t\tthis._fireCreatedEvent();\r\n\t\t}\r\n\r\n\t\tthis.disable();\r\n\t\tif (this.options.repeatMode) {\r\n\t\t\tthis.enable();\r\n\t\t}\r\n\t}\r\n});\r\n","/**\r\n * @class L.Draw.Rectangle\r\n * @aka Draw.Rectangle\r\n * @inherits L.Draw.SimpleShape\r\n */\r\nL.Draw.Rectangle = L.Draw.SimpleShape.extend({\r\n\tstatics: {\r\n\t\tTYPE: 'rectangle'\r\n\t},\r\n\r\n\toptions: {\r\n\t\tshapeOptions: {\r\n\t\t\tstroke: true,\r\n\t\t\tcolor: '#3388ff',\r\n\t\t\tweight: 4,\r\n\t\t\topacity: 0.5,\r\n\t\t\tfill: true,\r\n\t\t\tfillColor: null, //same as color by default\r\n\t\t\tfillOpacity: 0.2,\r\n\t\t\tclickable: true\r\n\t\t},\r\n\t\tshowArea: true, //Whether to show the area in the tooltip\r\n\t\tmetric: true // Whether to use the metric measurement system or imperial\r\n\t},\r\n\r\n\t// @method initialize(): void\r\n\tinitialize: function (map, options) {\r\n\t\t// Save the type so super can fire, need to do this as cannot do this.TYPE :(\r\n\t\tthis.type = L.Draw.Rectangle.TYPE;\r\n\r\n\t\tthis._initialLabelText = L.drawLocal.draw.handlers.rectangle.tooltip.start;\r\n\r\n\t\tL.Draw.SimpleShape.prototype.initialize.call(this, map, options);\r\n\t},\r\n\r\n\t// @method disable(): void\r\n\tdisable: function () {\r\n\t\tif (!this._enabled) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis._isCurrentlyTwoClickDrawing = false;\r\n\t\tL.Draw.SimpleShape.prototype.disable.call(this);\r\n\t},\r\n\r\n\t_onMouseUp: function (e) {\r\n\t\tif (!this._shape && !this._isCurrentlyTwoClickDrawing) {\r\n\t\t\tthis._isCurrentlyTwoClickDrawing = true;\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Make sure closing click is on map\r\n\t\tif (this._isCurrentlyTwoClickDrawing && !_hasAncestor(e.target, 'leaflet-pane')) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tL.Draw.SimpleShape.prototype._onMouseUp.call(this);\r\n\t},\r\n\r\n\t_drawShape: function (latlng) {\r\n\t\tif (!this._shape) {\r\n\t\t\tthis._shape = new L.Rectangle(new L.LatLngBounds(this._startLatLng, latlng), this.options.shapeOptions);\r\n\t\t\tthis._map.addLayer(this._shape);\r\n\t\t} else {\r\n\t\t\tthis._shape.setBounds(new L.LatLngBounds(this._startLatLng, latlng));\r\n\t\t}\r\n\t},\r\n\r\n\t_fireCreatedEvent: function () {\r\n\t\tvar rectangle = new L.Rectangle(this._shape.getBounds(), this.options.shapeOptions);\r\n\t\tL.Draw.SimpleShape.prototype._fireCreatedEvent.call(this, rectangle);\r\n\t},\r\n\r\n\t_getTooltipText: function () {\r\n\t\tvar tooltipText = L.Draw.SimpleShape.prototype._getTooltipText.call(this),\r\n\t\t\tshape = this._shape,\r\n\t\t\tshowArea = this.options.showArea,\r\n\t\t\tlatLngs, area, subtext;\r\n\r\n\t\tif (shape) {\r\n\t\t\tlatLngs = this._shape._defaultShape ? this._shape._defaultShape() : this._shape.getLatLngs();\r\n\t\t\tarea = L.GeometryUtil.geodesicArea(latLngs);\r\n\t\t\tsubtext = showArea ? L.GeometryUtil.readableArea(area, this.options.metric) : '';\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\ttext: tooltipText.text,\r\n\t\t\tsubtext: subtext\r\n\t\t};\r\n\t}\r\n});\r\n\r\nfunction _hasAncestor(el, cls) {\r\n\twhile ((el = el.parentElement) && !el.classList.contains(cls)) {\r\n\t\t;\r\n\t}\r\n\treturn el;\r\n}\r\n","/**\r\n * @class L.Draw.Marker\r\n * @aka Draw.Marker\r\n * @inherits L.Draw.Feature\r\n */\r\nL.Draw.Marker = L.Draw.Feature.extend({\r\n\tstatics: {\r\n\t\tTYPE: 'marker'\r\n\t},\r\n\r\n\toptions: {\r\n\t\ticon: new L.Icon.Default(),\r\n\t\trepeatMode: false,\r\n\t\tzIndexOffset: 2000 // This should be > than the highest z-index any markers\r\n\t},\r\n\r\n\t// @method initialize(): void\r\n\tinitialize: function (map, options) {\r\n\t\t// Save the type so super can fire, need to do this as cannot do this.TYPE :(\r\n\t\tthis.type = L.Draw.Marker.TYPE;\r\n\r\n\t\tthis._initialLabelText = L.drawLocal.draw.handlers.marker.tooltip.start;\r\n\r\n\t\tL.Draw.Feature.prototype.initialize.call(this, map, options);\r\n\t},\r\n\r\n\t// @method addHooks(): void\r\n\t// Add listener hooks to this handler.\r\n\taddHooks: function () {\r\n\t\tL.Draw.Feature.prototype.addHooks.call(this);\r\n\r\n\t\tif (this._map) {\r\n\t\t\tthis._tooltip.updateContent({text: this._initialLabelText});\r\n\r\n\t\t\t// Same mouseMarker as in Draw.Polyline\r\n\t\t\tif (!this._mouseMarker) {\r\n\t\t\t\tthis._mouseMarker = L.marker(this._map.getCenter(), {\r\n\t\t\t\t\ticon: L.divIcon({\r\n\t\t\t\t\t\tclassName: 'leaflet-mouse-marker',\r\n\t\t\t\t\t\ticonAnchor: [20, 20],\r\n\t\t\t\t\t\ticonSize: [40, 40]\r\n\t\t\t\t\t}),\r\n\t\t\t\t\topacity: 0,\r\n\t\t\t\t\tzIndexOffset: this.options.zIndexOffset\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tthis._mouseMarker\r\n\t\t\t\t.on('click', this._onClick, this)\r\n\t\t\t\t.addTo(this._map);\r\n\r\n\t\t\tthis._map.on('mousemove', this._onMouseMove, this);\r\n\t\t\tthis._map.on('click', this._onTouch, this);\r\n\t\t}\r\n\t},\r\n\r\n\t// @method removeHooks(): void\r\n\t// Remove listener hooks from this handler.\r\n\tremoveHooks: function () {\r\n\t\tL.Draw.Feature.prototype.removeHooks.call(this);\r\n\r\n\t\tif (this._map) {\r\n\t\t\tthis._map\r\n\t\t\t\t.off('click', this._onClick, this)\r\n\t\t\t\t.off('click', this._onTouch, this);\r\n\t\t\tif (this._marker) {\r\n\t\t\t\tthis._marker.off('click', this._onClick, this);\r\n\t\t\t\tthis._map\r\n\t\t\t\t\t.removeLayer(this._marker);\r\n\t\t\t\tdelete this._marker;\r\n\t\t\t}\r\n\r\n\t\t\tthis._mouseMarker.off('click', this._onClick, this);\r\n\t\t\tthis._map.removeLayer(this._mouseMarker);\r\n\t\t\tdelete this._mouseMarker;\r\n\r\n\t\t\tthis._map.off('mousemove', this._onMouseMove, this);\r\n\t\t}\r\n\t},\r\n\r\n\t_onMouseMove: function (e) {\r\n\t\tvar latlng = e.latlng;\r\n\r\n\t\tthis._tooltip.updatePosition(latlng);\r\n\t\tthis._mouseMarker.setLatLng(latlng);\r\n\r\n\t\tif (!this._marker) {\r\n\t\t\tthis._marker = this._createMarker(latlng);\r\n\t\t\t// Bind to both marker and map to make sure we get the click event.\r\n\t\t\tthis._marker.on('click', this._onClick, this);\r\n\t\t\tthis._map\r\n\t\t\t\t.on('click', this._onClick, this)\r\n\t\t\t\t.addLayer(this._marker);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tlatlng = this._mouseMarker.getLatLng();\r\n\t\t\tthis._marker.setLatLng(latlng);\r\n\t\t}\r\n\t},\r\n\r\n\t_createMarker: function (latlng) {\r\n\t\treturn new L.Marker(latlng, {\r\n\t\t\ticon: this.options.icon,\r\n\t\t\tzIndexOffset: this.options.zIndexOffset\r\n\t\t});\r\n\t},\r\n\r\n\t_onClick: function () {\r\n\t\tthis._fireCreatedEvent();\r\n\r\n\t\tthis.disable();\r\n\t\tif (this.options.repeatMode) {\r\n\t\t\tthis.enable();\r\n\t\t}\r\n\t},\r\n\r\n\t_onTouch: function (e) {\r\n\t\t// called on click & tap, only really does any thing on tap\r\n\t\tthis._onMouseMove(e); // creates & places marker\r\n\t\tthis._onClick(); // permanently places marker & ends interaction\r\n\t},\r\n\r\n\t_fireCreatedEvent: function () {\r\n\t\tvar marker = new L.Marker.Touch(this._marker.getLatLng(), {icon: this.options.icon});\r\n\t\tL.Draw.Feature.prototype._fireCreatedEvent.call(this, marker);\r\n\t}\r\n});\r\n","/**\r\n * @class L.Draw.CircleMarker\r\n * @aka Draw.CircleMarker\r\n * @inherits L.Draw.Marker\r\n */\r\nL.Draw.CircleMarker = L.Draw.Marker.extend({\r\n\tstatics: {\r\n\t\tTYPE: 'circlemarker'\r\n\t},\r\n\r\n\toptions: {\r\n\t\tstroke: true,\r\n\t\tcolor: '#3388ff',\r\n\t\tweight: 4,\r\n\t\topacity: 0.5,\r\n\t\tfill: true,\r\n\t\tfillColor: null, //same as color by default\r\n\t\tfillOpacity: 0.2,\r\n\t\tclickable: true,\r\n\t\tzIndexOffset: 2000 // This should be > than the highest z-index any markers\r\n\t},\r\n\r\n\t// @method initialize(): void\r\n\tinitialize: function (map, options) {\r\n\t\t// Save the type so super can fire, need to do this as cannot do this.TYPE :(\r\n\t\tthis.type = L.Draw.CircleMarker.TYPE;\r\n\r\n\t\tthis._initialLabelText = L.drawLocal.draw.handlers.circlemarker.tooltip.start;\r\n\r\n\t\tL.Draw.Feature.prototype.initialize.call(this, map, options);\r\n\t},\r\n\r\n\r\n\t_fireCreatedEvent: function () {\r\n\t\tvar circleMarker = new L.CircleMarker(this._marker.getLatLng(), this.options);\r\n\t\tL.Draw.Feature.prototype._fireCreatedEvent.call(this, circleMarker);\r\n\t},\r\n\r\n\t_createMarker: function (latlng) {\r\n\t\treturn new L.CircleMarker(latlng, this.options);\r\n\t}\r\n});\r\n","/**\r\n * @class L.Draw.Circle\r\n * @aka Draw.Circle\r\n * @inherits L.Draw.SimpleShape\r\n */\r\nL.Draw.Circle = L.Draw.SimpleShape.extend({\r\n\tstatics: {\r\n\t\tTYPE: 'circle'\r\n\t},\r\n\r\n\toptions: {\r\n\t\tshapeOptions: {\r\n\t\t\tstroke: true,\r\n\t\t\tcolor: '#3388ff',\r\n\t\t\tweight: 4,\r\n\t\t\topacity: 0.5,\r\n\t\t\tfill: true,\r\n\t\t\tfillColor: null, //same as color by default\r\n\t\t\tfillOpacity: 0.2,\r\n\t\t\tclickable: true\r\n\t\t},\r\n\t\tshowRadius: true,\r\n\t\tmetric: true, // Whether to use the metric measurement system or imperial\r\n\t\tfeet: true, // When not metric, use feet instead of yards for display\r\n\t\tnautic: false // When not metric, not feet use nautic mile for display\r\n\t},\r\n\r\n\t// @method initialize(): void\r\n\tinitialize: function (map, options) {\r\n\t\t// Save the type so super can fire, need to do this as cannot do this.TYPE :(\r\n\t\tthis.type = L.Draw.Circle.TYPE;\r\n\r\n\t\tthis._initialLabelText = L.drawLocal.draw.handlers.circle.tooltip.start;\r\n\r\n\t\tL.Draw.SimpleShape.prototype.initialize.call(this, map, options);\r\n\t},\r\n\r\n\t_drawShape: function (latlng) {\r\n\t\t// Calculate the distance based on the version\r\n\t\tif (L.GeometryUtil.isVersion07x()) {\r\n\t\t\tvar distance = this._startLatLng.distanceTo(latlng);\r\n\t\t} else {\r\n\t\t\tvar distance = this._map.distance(this._startLatLng, latlng);\r\n\t\t}\r\n\r\n\t\tif (!this._shape) {\r\n\t\t\tthis._shape = new L.Circle(this._startLatLng, distance, this.options.shapeOptions);\r\n\t\t\tthis._map.addLayer(this._shape);\r\n\t\t} else {\r\n\t\t\tthis._shape.setRadius(distance);\r\n\t\t}\r\n\t},\r\n\r\n\t_fireCreatedEvent: function () {\r\n\t\tvar circle = new L.Circle(this._startLatLng, this._shape.getRadius(), this.options.shapeOptions);\r\n\t\tL.Draw.SimpleShape.prototype._fireCreatedEvent.call(this, circle);\r\n\t},\r\n\r\n\t_onMouseMove: function (e) {\r\n\t\tvar latlng = e.latlng,\r\n\t\t\tshowRadius = this.options.showRadius,\r\n\t\t\tuseMetric = this.options.metric,\r\n\t\t\tradius;\r\n\r\n\t\tthis._tooltip.updatePosition(latlng);\r\n\t\tif (this._isDrawing) {\r\n\t\t\tthis._drawShape(latlng);\r\n\r\n\t\t\t// Get the new radius (rounded to 1 dp)\r\n\t\t\tradius = this._shape.getRadius().toFixed(1);\r\n\r\n\t\t\tvar subtext = '';\r\n\t\t\tif (showRadius) {\r\n\t\t\t\tsubtext = L.drawLocal.draw.handlers.circle.radius + ': ' +\r\n\t\t\t\t\tL.GeometryUtil.readableDistance(radius, useMetric, this.options.feet, this.options.nautic);\r\n\t\t\t}\r\n\t\t\tthis._tooltip.updateContent({\r\n\t\t\t\ttext: this._endLabelText,\r\n\t\t\t\tsubtext: subtext\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n});\r\n","/**\r\n * @class L.Draw.DuongDay\r\n * @aka Draw.DuongDay\r\n * @inherits L.Draw.Feature\r\n */\r\nL.Draw.DuongDay = L.Draw.Polyline.extend({\r\n\tstatics: {\r\n\t\tTYPE: \"duongDay\",\r\n\t},\r\n\tinitialize: function (map, options) {\r\n\t\tL.Draw.Polyline.prototype.initialize.call(this, map, options);\r\n\t\tthis.type = L.Draw.DuongDay.TYPE;\r\n\t},\r\n\t_fireCreatedEvent: function () {\r\n\t\tvar poly = L.duongDay(this._poly.getLatLngs(), this.options);\r\n\t\tL.Draw.Feature.prototype._fireCreatedEvent.call(this, poly);\r\n\t},\r\n});\r\n","/**\r\n * @class L.Draw.ThanhCai\r\n * @aka Draw.ThanhCai\r\n * @inherits L.Draw.Feature\r\n */\r\nL.Draw.ThanhCai = L.Draw.Feature.extend({\r\n\tstatics: {\r\n\t\tTYPE: \"thanhCai\",\r\n\t},\r\n\r\n\toptions: {\r\n\t\ticon: new L.DivIcon({\r\n\t\t\ticonSize: new L.Point(8, 8),\r\n\t\t\tclassName: \"leaflet-div-icon leaflet-editing-icon\",\r\n\t\t}),\r\n\t\ttouchIcon: new L.DivIcon({\r\n\t\t\ticonSize: new L.Point(20, 20),\r\n\t\t\tclassName: \"leaflet-div-icon leaflet-editing-icon leaflet-touch-icon\",\r\n\t\t}),\r\n\t\trepeatMode: false,\r\n\t\tzIndexOffset: 2000, // This should be > than the highest z-index any markers\r\n\t\tisEditPoly: false,\r\n\t},\r\n\r\n\t// @method initialize(): void\r\n\tinitialize: function (map, options) {\r\n\t\t// if touch, switch to touch icon\r\n\t\tif (L.Browser.touch) {\r\n\t\t\tthis.options.icon = this.options.touchIcon;\r\n\t\t}\r\n\t\t// Save the type so super can fire, need to do this as cannot do this.TYPE :(\r\n\t\tthis.type = L.Draw.ThanhCai.TYPE;\r\n\r\n\t\tthis._initialLabelText = L.drawLocal.draw.handlers.thanhCai.tooltip.start;\r\n\r\n\t\tL.Draw.Feature.prototype.initialize.call(this, map, options);\r\n\t},\r\n\r\n\t// @method addHooks(): void\r\n\t// Add listener hooks to this handler.\r\n\taddHooks: function () {\r\n\t\tL.Draw.Feature.prototype.addHooks.call(this);\r\n\r\n\t\tif (this._map) {\r\n\t\t\tthis._tooltip.updateContent({ text: this._initialLabelText });\r\n\r\n\t\t\t// Same mouseMarker as in Draw.Polyline\r\n\t\t\tif (!this._mouseMarker) {\r\n\t\t\t\tthis._mouseMarker = L.marker(this._map.getCenter(), {\r\n\t\t\t\t\ticon: L.divIcon({\r\n\t\t\t\t\t\tclassName: \"leaflet-mouse-marker\",\r\n\t\t\t\t\t\ticonAnchor: [20, 20],\r\n\t\t\t\t\t\ticonSize: [40, 40],\r\n\t\t\t\t\t}),\r\n\t\t\t\t\topacity: 0,\r\n\t\t\t\t\tzIndexOffset: this.options.zIndexOffset,\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tthis._mouseMarker.on(\"click\", this._onClick, this).addTo(this._map);\r\n\r\n\t\t\tthis._map.on(\"mousemove\", this._onMouseMove, this);\r\n\t\t\tthis._map.on(\"click\", this._onTouch, this);\r\n\t\t}\r\n\t},\r\n\r\n\t// @method removeHooks(): void\r\n\t// Remove listener hooks from this handler.\r\n\tremoveHooks: function () {\r\n\t\tL.Draw.Feature.prototype.removeHooks.call(this);\r\n\r\n\t\tif (this._map) {\r\n\t\t\tthis._map\r\n\t\t\t\t.off(\"click\", this._onClick, this)\r\n\t\t\t\t.off(\"click\", this._onTouch, this);\r\n\t\t\tif (this._marker) {\r\n\t\t\t\tthis._marker.off(\"click\", this._onClick, this);\r\n\t\t\t\tthis._map.removeLayer(this._marker);\r\n\t\t\t\tdelete this._marker;\r\n\t\t\t}\r\n\r\n\t\t\tthis._mouseMarker.off(\"click\", this._onClick, this);\r\n\t\t\tthis._map.removeLayer(this._mouseMarker);\r\n\t\t\tdelete this._mouseMarker;\r\n\r\n\t\t\tthis._map.off(\"mousemove\", this._onMouseMove, this);\r\n\t\t}\r\n\t},\r\n\r\n\t_onMouseMove: function (e) {\r\n\t\tvar latlng = e.latlng;\r\n\r\n\t\tthis._tooltip.updatePosition(latlng);\r\n\t\tthis._mouseMarker.setLatLng(latlng);\r\n\r\n\t\tif (!this._marker) {\r\n\t\t\tthis._marker = this._createThanhCai(latlng);\r\n\t\t\t// Bind to both marker and map to make sure we get the click event.\r\n\t\t\tthis._marker.on(\"click\", this._onClick, this);\r\n\t\t\tthis._map.on(\"click\", this._onClick, this).addLayer(this._marker);\r\n\t\t} else {\r\n\t\t\tlatlng = this._mouseMarker.getLatLng();\r\n\t\t\tthis._map.removeLayer(this._marker);\r\n\t\t\tthis._marker = this._createThanhCai(latlng);\r\n\t\t\tthis._map.addLayer(this._marker);\r\n\t\t}\r\n\t},\r\n\r\n\t_createThanhCai: function (latlng) {\r\n\t\treturn L.thanhCai(latlng, this.options);\r\n\t},\r\n\r\n\t_onClick: function () {\r\n\t\tthis._fireCreatedEvent();\r\n\r\n\t\tthis.disable();\r\n\t\tif (this.options.repeatMode) {\r\n\t\t\tthis.enable();\r\n\t\t}\r\n\t},\r\n\r\n\t_onTouch: function (e) {\r\n\t\t// called on click & tap, only really does any thing on tap\r\n\t\tthis._onMouseMove(e); // creates & places marker\r\n\t\tthis._onClick(); // permanently places marker & ends interaction\r\n\t},\r\n\r\n\t_fireCreatedEvent: function () {\r\n\t\tvar marker = this._createThanhCai(this._mouseMarker.getLatLng());\r\n\t\tL.Draw.Feature.prototype._fireCreatedEvent.call(this, marker);\r\n\t},\r\n});\r\n","/**\r\n * @class L.Draw.Role\r\n * @aka Draw.Role\r\n * @inherits L.Draw.Feature\r\n */\r\nL.Draw.Role = L.Draw.Feature.extend({\r\n\tstatics: {\r\n\t\tTYPE: \"role\",\r\n\t},\r\n\r\n\toptions: {\r\n\t\ticon: new L.DivIcon({\r\n\t\t\ticonSize: new L.Point(8, 8),\r\n\t\t\tclassName: \"leaflet-div-icon leaflet-editing-icon\",\r\n\t\t}),\r\n\t\ttouchIcon: new L.DivIcon({\r\n\t\t\ticonSize: new L.Point(20, 20),\r\n\t\t\tclassName: \"leaflet-div-icon leaflet-editing-icon leaflet-touch-icon\",\r\n\t\t}),\r\n\t\trepeatMode: false,\r\n\t\tzIndexOffset: 2000, // This should be > than the highest z-index any markers,\r\n\t\tisEditPoly: false,\r\n\t},\r\n\r\n\t// @method initialize(): void\r\n\tinitialize: function (map, options) {\r\n\t\t// if touch, switch to touch icon\r\n\t\tif (L.Browser.touch) {\r\n\t\t\tthis.options.icon = this.options.touchIcon;\r\n\t\t}\r\n\t\t// Save the type so super can fire, need to do this as cannot do this.TYPE :(\r\n\t\tthis.type = L.Draw.Role.TYPE;\r\n\r\n\t\tthis._initialLabelText = L.drawLocal.draw.handlers.role.tooltip.start;\r\n\r\n\t\tL.Draw.Feature.prototype.initialize.call(this, map, options);\r\n\t},\r\n\r\n\t// @method addHooks(): void\r\n\t// Add listener hooks to this handler.\r\n\taddHooks: function () {\r\n\t\tL.Draw.Feature.prototype.addHooks.call(this);\r\n\r\n\t\tif (this._map) {\r\n\t\t\tthis._tooltip.updateContent({ text: this._initialLabelText });\r\n\r\n\t\t\t// Same mouseMarker as in Draw.Polyline\r\n\t\t\tif (!this._mouseMarker) {\r\n\t\t\t\tthis._mouseMarker = L.marker(this._map.getCenter(), {\r\n\t\t\t\t\ticon: L.divIcon({\r\n\t\t\t\t\t\tclassName: \"leaflet-mouse-marker\",\r\n\t\t\t\t\t\ticonAnchor: [20, 20],\r\n\t\t\t\t\t\ticonSize: [40, 40],\r\n\t\t\t\t\t}),\r\n\t\t\t\t\topacity: 0,\r\n\t\t\t\t\tzIndexOffset: this.options.zIndexOffset,\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tthis._mouseMarker.on(\"click\", this._onClick, this).addTo(this._map);\r\n\r\n\t\t\tthis._map.on(\"mousemove\", this._onMouseMove, this);\r\n\t\t\tthis._map.on(\"click\", this._onTouch, this);\r\n\t\t}\r\n\t},\r\n\r\n\t// @method removeHooks(): void\r\n\t// Remove listener hooks from this handler.\r\n\tremoveHooks: function () {\r\n\t\tL.Draw.Feature.prototype.removeHooks.call(this);\r\n\r\n\t\tif (this._map) {\r\n\t\t\tthis._map\r\n\t\t\t\t.off(\"click\", this._onClick, this)\r\n\t\t\t\t.off(\"click\", this._onTouch, this);\r\n\t\t\tif (this._marker) {\r\n\t\t\t\tthis._marker.off(\"click\", this._onClick, this);\r\n\t\t\t\tthis._map.removeLayer(this._marker);\r\n\t\t\t\tdelete this._marker;\r\n\t\t\t}\r\n\r\n\t\t\tthis._mouseMarker.off(\"click\", this._onClick, this);\r\n\t\t\tthis._map.removeLayer(this._mouseMarker);\r\n\t\t\tdelete this._mouseMarker;\r\n\r\n\t\t\tthis._map.off(\"mousemove\", this._onMouseMove, this);\r\n\t\t}\r\n\t},\r\n\r\n\t_onMouseMove: function (e) {\r\n\t\tvar latlng = e.latlng;\r\n\r\n\t\tthis._tooltip.updatePosition(latlng);\r\n\t\tthis._mouseMarker.setLatLng(latlng);\r\n\r\n\t\tif (!this._marker) {\r\n\t\t\tthis._marker = this._createRole(latlng);\r\n\t\t\t// Bind to both marker and map to make sure we get the click event.\r\n\t\t\tthis._marker.on(\"click\", this._onClick, this);\r\n\t\t\tthis._map.on(\"click\", this._onClick, this).addLayer(this._marker);\r\n\t\t} else {\r\n\t\t\tlatlng = this._mouseMarker.getLatLng();\r\n\t\t\tthis._map.removeLayer(this._marker);\r\n\t\t\tthis._marker = this._createRole(latlng);\r\n\t\t\tthis._map.addLayer(this._marker);\r\n\t\t}\r\n\t},\r\n\r\n\t_createRole: function (latlng) {\r\n\t\treturn L.role(latlng, this.options);\r\n\t},\r\n\r\n\t_onClick: function () {\r\n\t\tthis._fireCreatedEvent();\r\n\r\n\t\tthis.disable();\r\n\t\tif (this.options.repeatMode) {\r\n\t\t\tthis.enable();\r\n\t\t}\r\n\t},\r\n\r\n\t_onTouch: function (e) {\r\n\t\t// called on click & tap, only really does any thing on tap\r\n\t\tthis._onMouseMove(e); // creates & places marker\r\n\t\tthis._onClick(); // permanently places marker & ends interaction\r\n\t},\r\n\r\n\t_fireCreatedEvent: function () {\r\n\t\tconst marker = this._createRole(this._mouseMarker.getLatLng());\r\n\t\tL.Draw.Feature.prototype._fireCreatedEvent.call(this, marker);\r\n\t},\r\n});\r\n","/**\r\n * @class L.Draw.MayBienAp\r\n * @aka Draw.MayBienAp\r\n * @inherits L.Draw.Feature\r\n */\r\nL.Draw.MayBienAp = L.Draw.Feature.extend({\r\n\tstatics: {\r\n\t\tTYPE: \"mayBienAp\",\r\n\t},\r\n\r\n\toptions: {\r\n\t\ticon: new L.DivIcon({\r\n\t\t\ticonSize: new L.Point(8, 8),\r\n\t\t\tclassName: \"leaflet-div-icon leaflet-editing-icon\",\r\n\t\t}),\r\n\t\ttouchIcon: new L.DivIcon({\r\n\t\t\ticonSize: new L.Point(20, 20),\r\n\t\t\tclassName: \"leaflet-div-icon leaflet-editing-icon leaflet-touch-icon\",\r\n\t\t}),\r\n\t\trepeatMode: false,\r\n\t\tzIndexOffset: 2000, // This should be > than the highest z-index any markers\r\n\t},\r\n\r\n\t// @method initialize(): void\r\n\tinitialize: function (map, options) {\r\n\t\t// if touch, switch to touch icon\r\n\t\tif (L.Browser.touch) {\r\n\t\t\tthis.options.icon = this.options.touchIcon;\r\n\t\t}\r\n\t\t// Save the type so super can fire, need to do this as cannot do this.TYPE :(\r\n\t\tthis.type = L.Draw.MayBienAp.TYPE;\r\n\r\n\t\tthis._initialLabelText = L.drawLocal.draw.handlers.mayBienAp.tooltip.start;\r\n\r\n\t\tL.Draw.Feature.prototype.initialize.call(this, map, options);\r\n\t},\r\n\r\n\t// @method addHooks(): void\r\n\t// Add listener hooks to this handler.\r\n\taddHooks: function () {\r\n\t\tL.Draw.Feature.prototype.addHooks.call(this);\r\n\r\n\t\tif (this._map) {\r\n\t\t\tthis._tooltip.updateContent({ text: this._initialLabelText });\r\n\r\n\t\t\t// Same mouseMarker as in Draw.Polyline\r\n\t\t\tif (!this._mouseMarker) {\r\n\t\t\t\tthis._mouseMarker = L.marker(this._map.getCenter(), {\r\n\t\t\t\t\ticon: L.divIcon({\r\n\t\t\t\t\t\tclassName: \"leaflet-mouse-marker\",\r\n\t\t\t\t\t\ticonAnchor: [20, 20],\r\n\t\t\t\t\t\ticonSize: [40, 40],\r\n\t\t\t\t\t}),\r\n\t\t\t\t\topacity: 0,\r\n\t\t\t\t\tzIndexOffset: this.options.zIndexOffset,\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tthis._mouseMarker.on(\"click\", this._onClick, this).addTo(this._map);\r\n\r\n\t\t\tthis._map.on(\"mousemove\", this._onMouseMove, this);\r\n\t\t\tthis._map.on(\"click\", this._onTouch, this);\r\n\t\t}\r\n\t},\r\n\r\n\t// @method removeHooks(): void\r\n\t// Remove listener hooks from this handler.\r\n\tremoveHooks: function () {\r\n\t\tL.Draw.Feature.prototype.removeHooks.call(this);\r\n\r\n\t\tif (this._map) {\r\n\t\t\tthis._map\r\n\t\t\t\t.off(\"click\", this._onClick, this)\r\n\t\t\t\t.off(\"click\", this._onTouch, this);\r\n\t\t\tif (this._marker) {\r\n\t\t\t\tthis._marker.off(\"click\", this._onClick, this);\r\n\t\t\t\tthis._map.removeLayer(this._marker);\r\n\t\t\t\tdelete this._marker;\r\n\t\t\t}\r\n\r\n\t\t\tthis._mouseMarker.off(\"click\", this._onClick, this);\r\n\t\t\tthis._map.removeLayer(this._mouseMarker);\r\n\t\t\tdelete this._mouseMarker;\r\n\r\n\t\t\tthis._map.off(\"mousemove\", this._onMouseMove, this);\r\n\t\t}\r\n\t},\r\n\r\n\t_onMouseMove: function (e) {\r\n\t\tvar latlng = e.latlng;\r\n\r\n\t\tthis._tooltip.updatePosition(latlng);\r\n\t\tthis._mouseMarker.setLatLng(latlng);\r\n\r\n\t\tif (!this._marker) {\r\n\t\t\tthis._marker = this._createMayBienAp(latlng);\r\n\t\t\t// Bind to both marker and map to make sure we get the click event.\r\n\t\t\tthis._marker.on(\"click\", this._onClick, this);\r\n\t\t\tthis._map.on(\"click\", this._onClick, this).addLayer(this._marker);\r\n\t\t} else {\r\n\t\t\tlatlng = this._mouseMarker.getLatLng();\r\n\t\t\tthis._map.removeLayer(this._marker);\r\n\t\t\tthis._marker = this._createMayBienAp(latlng);\r\n\t\t\tthis._map.addLayer(this._marker);\r\n\t\t}\r\n\t},\r\n\r\n\t_createMayBienAp: function (latlng) {\r\n\t\treturn L.mayBienAp(latlng, this.options);\r\n\t},\r\n\r\n\t_onClick: function () {\r\n\t\tthis._fireCreatedEvent();\r\n\r\n\t\tthis.disable();\r\n\t\tif (this.options.repeatMode) {\r\n\t\t\tthis.enable();\r\n\t\t}\r\n\t},\r\n\r\n\t_onTouch: function (e) {\r\n\t\t// called on click & tap, only really does any thing on tap\r\n\t\tthis._onMouseMove(e); // creates & places marker\r\n\t\tthis._onClick(); // permanently places marker & ends interaction\r\n\t},\r\n\r\n\t_fireCreatedEvent: function () {\r\n\t\tvar mayBienAp = this._createMayBienAp(this._mouseMarker.getLatLng());\r\n\t\tL.Draw.Feature.prototype._fireCreatedEvent.call(this, mayBienAp);\r\n\t},\r\n});\r\n","L.Edit = L.Edit || {};\r\n\r\n/**\r\n * @class L.Edit.Marker\r\n * @aka Edit.Marker\r\n */\r\nL.Edit.Marker = L.Handler.extend({\r\n\t// @method initialize(): void\r\n\tinitialize: function (marker, options) {\r\n\t\tthis._marker = marker;\r\n\t\tL.setOptions(this, options);\r\n\t},\r\n\r\n\t// @method addHooks(): void\r\n\t// Add listener hooks to this handler\r\n\taddHooks: function () {\r\n\t\tvar marker = this._marker;\r\n\r\n\t\tmarker.dragging.enable();\r\n\t\tmarker.on('dragend', this._onDragEnd, marker);\r\n\t\tthis._toggleMarkerHighlight();\r\n\t},\r\n\r\n\t// @method removeHooks(): void\r\n\t// Remove listener hooks from this handler\r\n\tremoveHooks: function () {\r\n\t\tvar marker = this._marker;\r\n\r\n\t\tmarker.dragging.disable();\r\n\t\tmarker.off('dragend', this._onDragEnd, marker);\r\n\t\tthis._toggleMarkerHighlight();\r\n\t},\r\n\r\n\t_onDragEnd: function (e) {\r\n\t\tvar layer = e.target;\r\n\t\tlayer.edited = true;\r\n\t\tthis._map.fire(L.Draw.Event.EDITMOVE, {layer: layer});\r\n\t},\r\n\r\n\t_toggleMarkerHighlight: function () {\r\n\t\tvar icon = this._marker._icon;\r\n\r\n\t\t// Don't do anything if this layer is a marker but doesn't have an icon. Markers\r\n\t\t// should usually have icons. If using Leaflet.draw with Leaflet.markercluster there\r\n\t\t// is a chance that a marker doesn't.\r\n\t\tif (!icon) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// This is quite naughty, but I don't see another way of doing it. (short of setting a new icon)\r\n\t\ticon.style.display = 'none';\r\n\r\n\t\tif (L.DomUtil.hasClass(icon, 'leaflet-edit-marker-selected')) {\r\n\t\t\tL.DomUtil.removeClass(icon, 'leaflet-edit-marker-selected');\r\n\t\t\t// Offset as the border will make the icon move.\r\n\t\t\tthis._offsetMarker(icon, -4);\r\n\r\n\t\t} else {\r\n\t\t\tL.DomUtil.addClass(icon, 'leaflet-edit-marker-selected');\r\n\t\t\t// Offset as the border will make the icon move.\r\n\t\t\tthis._offsetMarker(icon, 4);\r\n\t\t}\r\n\r\n\t\ticon.style.display = '';\r\n\t},\r\n\r\n\t_offsetMarker: function (icon, offset) {\r\n\t\tvar iconMarginTop = parseInt(icon.style.marginTop, 10) - offset,\r\n\t\t\ticonMarginLeft = parseInt(icon.style.marginLeft, 10) - offset;\r\n\r\n\t\ticon.style.marginTop = iconMarginTop + 'px';\r\n\t\ticon.style.marginLeft = iconMarginLeft + 'px';\r\n\t}\r\n});\r\n\r\nL.Marker.addInitHook(function () {\r\n\tif (L.Edit.Marker) {\r\n\t\tthis.editing = new L.Edit.Marker(this);\r\n\r\n\t\tif (this.options.editable) {\r\n\t\t\tthis.editing.enable();\r\n\t\t}\r\n\t}\r\n});\r\n","L.Edit = L.Edit || {};\r\n\r\n/**\r\n * @class L.Edit.Polyline\r\n * @aka L.Edit.Poly\r\n * @aka Edit.Poly\r\n */\r\nL.Edit.Poly = L.Handler.extend({\r\n\t// @method initialize(): void\r\n\tinitialize: function (poly) {\r\n\t\tthis.latlngs = [poly._latlngs];\r\n\t\tif (poly._holes) {\r\n\t\t\tthis.latlngs = this.latlngs.concat(poly._holes);\r\n\t\t}\r\n\r\n\t\tthis._poly = poly;\r\n\r\n\t\tthis._poly.on(\"revert-edited\", this._updateLatLngs, this);\r\n\t},\r\n\r\n\t// Compatibility method to normalize Poly* objects\r\n\t// between 0.7.x and 1.0+\r\n\t_defaultShape: function () {\r\n\t\tif (!L.Polyline._flat) {\r\n\t\t\treturn this._poly._latlngs;\r\n\t\t}\r\n\t\treturn L.Polyline._flat(this._poly._latlngs)\r\n\t\t\t? this._poly._latlngs\r\n\t\t\t: this._poly._latlngs[0];\r\n\t},\r\n\r\n\t_eachVertexHandler: function (callback) {\r\n\t\tfor (var i = 0; i < this._verticesHandlers.length; i++) {\r\n\t\t\tcallback(this._verticesHandlers[i]);\r\n\t\t}\r\n\t},\r\n\r\n\t// @method addHooks(): void\r\n\t// Add listener hooks to this handler\r\n\taddHooks: function () {\r\n\t\tthis._initHandlers();\r\n\t\tthis._eachVertexHandler(function (handler) {\r\n\t\t\thandler.addHooks();\r\n\t\t});\r\n\t},\r\n\r\n\t// @method removeHooks(): void\r\n\t// Remove listener hooks from this handler\r\n\tremoveHooks: function () {\r\n\t\tthis._eachVertexHandler(function (handler) {\r\n\t\t\thandler.removeHooks();\r\n\t\t});\r\n\t},\r\n\r\n\t// @method updateMarkers(): void\r\n\t// Fire an update for each vertex handler\r\n\tupdateMarkers: function () {\r\n\t\tthis._eachVertexHandler(function (handler) {\r\n\t\t\thandler.updateMarkers();\r\n\t\t});\r\n\t},\r\n\r\n\t_initHandlers: function () {\r\n\t\tthis._verticesHandlers = [];\r\n\t\tfor (var i = 0; i < this.latlngs.length; i++) {\r\n\t\t\tthis._verticesHandlers.push(\r\n\t\t\t\tnew L.Edit.PolyVerticesEdit(\r\n\t\t\t\t\tthis._poly,\r\n\t\t\t\t\tthis.latlngs[i],\r\n\t\t\t\t\tthis._poly.options.poly\r\n\t\t\t\t)\r\n\t\t\t);\r\n\t\t}\r\n\t},\r\n\r\n\t_updateLatLngs: function (e) {\r\n\t\tthis.latlngs = [e.layer._latlngs];\r\n\t\tif (e.layer._holes) {\r\n\t\t\tthis.latlngs = this.latlngs.concat(e.layer._holes);\r\n\t\t}\r\n\t},\r\n});\r\n\r\n/**\r\n * @class L.Edit.PolyVerticesEdit\r\n * @aka Edit.PolyVerticesEdit\r\n */\r\nL.Edit.PolyVerticesEdit = L.Handler.extend({\r\n\toptions: {\r\n\t\ticon: new L.DivIcon({\r\n\t\t\ticonSize: new L.Point(8, 8),\r\n\t\t\tclassName: \"leaflet-div-icon leaflet-editing-icon\",\r\n\t\t}),\r\n\t\ttouchIcon: new L.DivIcon({\r\n\t\t\ticonSize: new L.Point(20, 20),\r\n\t\t\tclassName: \"leaflet-div-icon leaflet-editing-icon leaflet-touch-icon\",\r\n\t\t}),\r\n\t\tdrawError: {\r\n\t\t\tcolor: \"#b00b00\",\r\n\t\t\ttimeout: 1000,\r\n\t\t},\r\n\t},\r\n\r\n\t// @method intialize(): void\r\n\tinitialize: function (poly, latlngs, options) {\r\n\t\t// if touch, switch to touch icon\r\n\t\tif (L.Browser.touch) {\r\n\t\t\tthis.options.icon = this.options.touchIcon;\r\n\t\t}\r\n\t\tthis._poly = poly;\r\n\r\n\t\tif (options && options.drawError) {\r\n\t\t\toptions.drawError = L.Util.extend(\r\n\t\t\t\t{},\r\n\t\t\t\tthis.options.drawError,\r\n\t\t\t\toptions.drawError\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\tthis._latlngs = latlngs;\r\n\r\n\t\tL.setOptions(this, options);\r\n\t},\r\n\r\n\t// Compatibility method to normalize Poly* objects\r\n\t// between 0.7.x and 1.0+\r\n\t_defaultShape: function () {\r\n\t\tif (!L.Polyline._flat) {\r\n\t\t\treturn this._latlngs;\r\n\t\t}\r\n\t\treturn L.Polyline._flat(this._latlngs) ? this._latlngs : this._latlngs[0];\r\n\t},\r\n\r\n\t// @method addHooks(): void\r\n\t// Add listener hooks to this handler.\r\n\taddHooks: function () {\r\n\t\tvar poly = this._poly;\r\n\t\tvar path = poly._path;\r\n\r\n\t\tif (!(poly instanceof L.Polygon)) {\r\n\t\t\tpoly.options.fill = false;\r\n\t\t\tif (poly.options.editing) {\r\n\t\t\t\tpoly.options.editing.fill = false;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (path) {\r\n\t\t\tif (poly.options.editing && poly.options.editing.className) {\r\n\t\t\t\tif (poly.options.original.className) {\r\n\t\t\t\t\tpoly.options.original.className\r\n\t\t\t\t\t\t.split(\" \")\r\n\t\t\t\t\t\t.forEach(function (className) {\r\n\t\t\t\t\t\t\tL.DomUtil.removeClass(path, className);\r\n\t\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t\tpoly.options.editing.className.split(\" \").forEach(function (className) {\r\n\t\t\t\t\tL.DomUtil.addClass(path, className);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tpoly.setStyle(poly.options.editing);\r\n\r\n\t\tif (this._poly._map) {\r\n\t\t\tthis._map = this._poly._map; // Set map\r\n\r\n\t\t\tif (!this._markerGroup) {\r\n\t\t\t\tthis._initMarkers();\r\n\t\t\t}\r\n\t\t\tthis._poly._map.addLayer(this._markerGroup);\r\n\t\t}\r\n\t},\r\n\r\n\t// @method removeHooks(): void\r\n\t// Remove listener hooks from this handler.\r\n\tremoveHooks: function () {\r\n\t\tvar poly = this._poly;\r\n\t\tvar path = poly._path;\r\n\r\n\t\tif (path) {\r\n\t\t\tif (poly.options.editing && poly.options.editing.className) {\r\n\t\t\t\tpoly.options.editing.className.split(\" \").forEach(function (className) {\r\n\t\t\t\t\tL.DomUtil.removeClass(path, className);\r\n\t\t\t\t});\r\n\t\t\t\tif (poly.options.original.className) {\r\n\t\t\t\t\tpoly.options.original.className\r\n\t\t\t\t\t\t.split(\" \")\r\n\t\t\t\t\t\t.forEach(function (className) {\r\n\t\t\t\t\t\t\tL.DomUtil.addClass(path, className);\r\n\t\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tpoly.setStyle(poly.options.original);\r\n\r\n\t\tif (poly._map) {\r\n\t\t\tpoly._map.removeLayer(this._markerGroup);\r\n\t\t\tdelete this._markerGroup;\r\n\t\t\tdelete this._markers;\r\n\t\t}\r\n\t},\r\n\r\n\t// @method updateMarkers(): void\r\n\t// Clear markers and update their location\r\n\tupdateMarkers: function () {\r\n\t\tthis._markerGroup.clearLayers();\r\n\t\tthis._initMarkers();\r\n\t},\r\n\r\n\t_initMarkers: function () {\r\n\t\tif (!this._markerGroup) {\r\n\t\t\tthis._markerGroup = new L.LayerGroup();\r\n\t\t}\r\n\t\tthis._markers = [];\r\n\r\n\t\tvar latlngs = this._defaultShape(),\r\n\t\t\ti,\r\n\t\t\tj,\r\n\t\t\tlen,\r\n\t\t\tmarker;\r\n\r\n\t\tfor (i = 0, len = latlngs.length; i < len; i++) {\r\n\t\t\tmarker = this._createMarker(latlngs[i], i);\r\n\t\t\tmarker.on(\"click\", this._onMarkerClick, this);\r\n\t\t\tmarker.on(\"contextmenu\", this._onContextMenu, this);\r\n\t\t\tthis._markers.push(marker);\r\n\t\t}\r\n\r\n\t\tvar markerLeft, markerRight;\r\n\r\n\t\tfor (i = 0, j = len - 1; i < len; j = i++) {\r\n\t\t\tif (i === 0 && !(L.Polygon && this._poly instanceof L.Polygon)) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tmarkerLeft = this._markers[j];\r\n\t\t\tmarkerRight = this._markers[i];\r\n\r\n\t\t\tthis._createMiddleMarker(markerLeft, markerRight);\r\n\t\t\tthis._updatePrevNext(markerLeft, markerRight);\r\n\t\t}\r\n\t},\r\n\r\n\t_createMarker: function (latlng, index) {\r\n\t\t// Extending L.Marker in TouchEvents.js to include touch.\r\n\t\tvar marker = new L.Marker.Touch(latlng, {\r\n\t\t\tdraggable: true,\r\n\t\t\ticon: this.options.icon,\r\n\t\t});\r\n\r\n\t\tmarker._origLatLng = latlng;\r\n\t\tmarker._index = index;\r\n\r\n\t\tmarker\r\n\t\t\t.on(\"dragstart\", this._onMarkerDragStart, this)\r\n\t\t\t.on(\"drag\", this._onMarkerDrag, this)\r\n\t\t\t.on(\"dragend\", this._fireEdit, this)\r\n\t\t\t.on(\"touchmove\", this._onTouchMove, this)\r\n\t\t\t.on(\"touchend\", this._fireEdit, this)\r\n\t\t\t.on(\"MSPointerMove\", this._onTouchMove, this)\r\n\t\t\t.on(\"MSPointerUp\", this._fireEdit, this);\r\n\r\n\t\tthis._markerGroup.addLayer(marker);\r\n\r\n\t\treturn marker;\r\n\t},\r\n\r\n\t_onMarkerDragStart: function () {\r\n\t\tthis._poly.fire(\"editstart\");\r\n\t},\r\n\r\n\t_spliceLatLngs: function () {\r\n\t\tvar latlngs = this._defaultShape();\r\n\t\tvar removed = [].splice.apply(latlngs, arguments);\r\n\t\tthis._poly._convertLatLngs(latlngs, true);\r\n\t\tthis._poly.redraw();\r\n\t\treturn removed;\r\n\t},\r\n\r\n\t_removeMarker: function (marker) {\r\n\t\tvar i = marker._index;\r\n\r\n\t\tthis._markerGroup.removeLayer(marker);\r\n\t\tthis._markers.splice(i, 1);\r\n\t\tthis._spliceLatLngs(i, 1);\r\n\t\tthis._updateIndexes(i, -1);\r\n\r\n\t\tmarker\r\n\t\t\t.off(\"dragstart\", this._onMarkerDragStart, this)\r\n\t\t\t.off(\"drag\", this._onMarkerDrag, this)\r\n\t\t\t.off(\"dragend\", this._fireEdit, this)\r\n\t\t\t.off(\"touchmove\", this._onMarkerDrag, this)\r\n\t\t\t.off(\"touchend\", this._fireEdit, this)\r\n\t\t\t.off(\"click\", this._onMarkerClick, this)\r\n\t\t\t.off(\"MSPointerMove\", this._onTouchMove, this)\r\n\t\t\t.off(\"MSPointerUp\", this._fireEdit, this);\r\n\t},\r\n\r\n\t_fireEdit: function () {\r\n\t\tthis._poly.edited = true;\r\n\t\tthis._poly.fire(\"edit\");\r\n\t\tthis._poly._map.fire(L.Draw.Event.EDITVERTEX, {\r\n\t\t\tlayers: this._markerGroup,\r\n\t\t\tpoly: this._poly,\r\n\t\t});\r\n\t},\r\n\r\n\t_onMarkerDrag: function (e) {\r\n\t\tvar marker = e.target;\r\n\t\tvar poly = this._poly;\r\n\r\n\t\tvar oldOrigLatLng = L.LatLngUtil.cloneLatLng(marker._origLatLng);\r\n\t\tL.extend(marker._origLatLng, marker._latlng);\r\n\t\tif (poly.options.poly) {\r\n\t\t\tvar tooltip = poly._map._editTooltip; // Access the tooltip\r\n\r\n\t\t\t// If we don't allow intersections and the polygon intersects\r\n\t\t\tif (!poly.options.poly.allowIntersection && poly.intersects()) {\r\n\t\t\t\tL.extend(marker._origLatLng, oldOrigLatLng);\r\n\t\t\t\tmarker.setLatLng(oldOrigLatLng);\r\n\t\t\t\tvar originalColor = poly.options.color;\r\n\t\t\t\tpoly.setStyle({ color: this.options.drawError.color });\r\n\t\t\t\tif (tooltip) {\r\n\t\t\t\t\ttooltip.updateContent({\r\n\t\t\t\t\t\ttext: L.drawLocal.draw.handlers.polyline.error,\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Reset everything back to normal after a second\r\n\t\t\t\tsetTimeout(function () {\r\n\t\t\t\t\tpoly.setStyle({ color: originalColor });\r\n\t\t\t\t\tif (tooltip) {\r\n\t\t\t\t\t\ttooltip.updateContent({\r\n\t\t\t\t\t\t\ttext: L.drawLocal.edit.handlers.edit.tooltip.text,\r\n\t\t\t\t\t\t\tsubtext: L.drawLocal.edit.handlers.edit.tooltip.subtext,\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t}, 1000);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (marker._middleLeft) {\r\n\t\t\tmarker._middleLeft.setLatLng(this._getMiddleLatLng(marker._prev, marker));\r\n\t\t}\r\n\t\tif (marker._middleRight) {\r\n\t\t\tmarker._middleRight.setLatLng(\r\n\t\t\t\tthis._getMiddleLatLng(marker, marker._next)\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\t//refresh the bounds when draging\r\n\t\tthis._poly._bounds._southWest = L.latLng(Infinity, Infinity);\r\n\t\tthis._poly._bounds._northEast = L.latLng(-Infinity, -Infinity);\r\n\t\tvar latlngs = this._poly.getLatLngs();\r\n\t\tthis._poly._convertLatLngs(latlngs, true);\r\n\t\tthis._poly.redraw();\r\n\t\tthis._poly.fire(\"editdrag\");\r\n\t},\r\n\r\n\t_onMarkerClick: function (e) {\r\n\t\tvar minPoints = L.Polygon && this._poly instanceof L.Polygon ? 4 : 3,\r\n\t\t\tmarker = e.target;\r\n\r\n\t\t// If removing this point would create an invalid polyline/polygon don't remove\r\n\t\tif (this._defaultShape().length < minPoints) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// remove the marker\r\n\t\tthis._removeMarker(marker);\r\n\r\n\t\t// update prev/next links of adjacent markers\r\n\t\tthis._updatePrevNext(marker._prev, marker._next);\r\n\r\n\t\t// remove ghost markers near the removed marker\r\n\t\tif (marker._middleLeft) {\r\n\t\t\tthis._markerGroup.removeLayer(marker._middleLeft);\r\n\t\t}\r\n\t\tif (marker._middleRight) {\r\n\t\t\tthis._markerGroup.removeLayer(marker._middleRight);\r\n\t\t}\r\n\r\n\t\t// create a ghost marker in place of the removed one\r\n\t\tif (marker._prev && marker._next) {\r\n\t\t\tthis._createMiddleMarker(marker._prev, marker._next);\r\n\t\t} else if (!marker._prev) {\r\n\t\t\tmarker._next._middleLeft = null;\r\n\t\t} else if (!marker._next) {\r\n\t\t\tmarker._prev._middleRight = null;\r\n\t\t}\r\n\r\n\t\tthis._fireEdit();\r\n\t},\r\n\r\n\t_onContextMenu: function (e) {\r\n\t\tvar marker = e.target;\r\n\t\tvar poly = this._poly;\r\n\t\tthis._poly._map.fire(L.Draw.Event.MARKERCONTEXT, {\r\n\t\t\tmarker: marker,\r\n\t\t\tlayers: this._markerGroup,\r\n\t\t\tpoly: this._poly,\r\n\t\t});\r\n\t\tL.DomEvent.stopPropagation;\r\n\t},\r\n\r\n\t_onTouchMove: function (e) {\r\n\t\tvar layerPoint = this._map.mouseEventToLayerPoint(\r\n\t\t\t\te.originalEvent.touches[0]\r\n\t\t\t),\r\n\t\t\tlatlng = this._map.layerPointToLatLng(layerPoint),\r\n\t\t\tmarker = e.target;\r\n\r\n\t\tL.extend(marker._origLatLng, latlng);\r\n\r\n\t\tif (marker._middleLeft) {\r\n\t\t\tmarker._middleLeft.setLatLng(this._getMiddleLatLng(marker._prev, marker));\r\n\t\t}\r\n\t\tif (marker._middleRight) {\r\n\t\t\tmarker._middleRight.setLatLng(\r\n\t\t\t\tthis._getMiddleLatLng(marker, marker._next)\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\tthis._poly.redraw();\r\n\t\tthis.updateMarkers();\r\n\t},\r\n\r\n\t_updateIndexes: function (index, delta) {\r\n\t\tthis._markerGroup.eachLayer(function (marker) {\r\n\t\t\tif (marker._index > index) {\r\n\t\t\t\tmarker._index += delta;\r\n\t\t\t}\r\n\t\t});\r\n\t},\r\n\r\n\t_createMiddleMarker: function (marker1, marker2) {\r\n\t\tvar latlng = this._getMiddleLatLng(marker1, marker2),\r\n\t\t\tmarker = this._createMarker(latlng),\r\n\t\t\tonClick,\r\n\t\t\tonDragStart,\r\n\t\t\tonDragEnd;\r\n\r\n\t\tmarker.setOpacity(0.6);\r\n\r\n\t\tmarker1._middleRight = marker2._middleLeft = marker;\r\n\r\n\t\tonDragStart = function () {\r\n\t\t\tmarker.off(\"touchmove\", onDragStart, this);\r\n\t\t\tvar i = marker2._index;\r\n\r\n\t\t\tmarker._index = i;\r\n\r\n\t\t\tmarker.off(\"click\", onClick, this).on(\"click\", this._onMarkerClick, this);\r\n\r\n\t\t\tlatlng.lat = marker.getLatLng().lat;\r\n\t\t\tlatlng.lng = marker.getLatLng().lng;\r\n\t\t\tthis._spliceLatLngs(i, 0, latlng);\r\n\t\t\tthis._markers.splice(i, 0, marker);\r\n\r\n\t\t\tmarker.setOpacity(1);\r\n\r\n\t\t\tthis._updateIndexes(i, 1);\r\n\t\t\tmarker2._index++;\r\n\t\t\tthis._updatePrevNext(marker1, marker);\r\n\t\t\tthis._updatePrevNext(marker, marker2);\r\n\r\n\t\t\tthis._poly.fire(\"editstart\");\r\n\t\t};\r\n\r\n\t\tonDragEnd = function () {\r\n\t\t\tmarker.off(\"dragstart\", onDragStart, this);\r\n\t\t\tmarker.off(\"dragend\", onDragEnd, this);\r\n\t\t\tmarker.off(\"touchmove\", onDragStart, this);\r\n\r\n\t\t\tthis._createMiddleMarker(marker1, marker);\r\n\t\t\tthis._createMiddleMarker(marker, marker2);\r\n\t\t};\r\n\r\n\t\tonClick = function () {\r\n\t\t\tonDragStart.call(this);\r\n\t\t\tonDragEnd.call(this);\r\n\t\t\tthis._fireEdit();\r\n\t\t};\r\n\r\n\t\tmarker\r\n\t\t\t.on(\"click\", onClick, this)\r\n\t\t\t.on(\"dragstart\", onDragStart, this)\r\n\t\t\t.on(\"dragend\", onDragEnd, this)\r\n\t\t\t.on(\"touchmove\", onDragStart, this);\r\n\r\n\t\tthis._markerGroup.addLayer(marker);\r\n\t},\r\n\r\n\t_updatePrevNext: function (marker1, marker2) {\r\n\t\tif (marker1) {\r\n\t\t\tmarker1._next = marker2;\r\n\t\t}\r\n\t\tif (marker2) {\r\n\t\t\tmarker2._prev = marker1;\r\n\t\t}\r\n\t},\r\n\r\n\t_getMiddleLatLng: function (marker1, marker2) {\r\n\t\tvar map = this._poly._map,\r\n\t\t\tp1 = map.project(marker1.getLatLng()),\r\n\t\t\tp2 = map.project(marker2.getLatLng());\r\n\r\n\t\treturn map.unproject(p1._add(p2)._divideBy(2));\r\n\t},\r\n});\r\n\r\n// L.Polyline.addInitHook(function () {\r\n// \t// Check to see if handler has already been initialized. This is to support versions of Leaflet that still have L.Handler.PolyEdit\r\n// \tif (this.editing) {\r\n// \t\treturn;\r\n// \t}\r\n\r\n// \tif (L.Edit.Poly) {\r\n// \t\tthis.editing = new L.Edit.Poly(this);\r\n\r\n// \t\tif (this.options.editable) {\r\n// \t\t\tthis.editing.enable();\r\n// \t\t}\r\n// \t}\r\n\r\n// \tthis.on(\"add\", function () {\r\n// \t\tif (this.editing && this.editing.enabled()) {\r\n// \t\t\tthis.editing.addHooks();\r\n// \t\t}\r\n// \t});\r\n\r\n// \tthis.on(\"remove\", function () {\r\n// \t\tif (this.editing && this.editing.enabled()) {\r\n// \t\t\tthis.editing.removeHooks();\r\n// \t\t}\r\n// \t});\r\n// });\r\n","L.Edit = L.Edit || {};\r\n/**\r\n * @class L.Edit.SimpleShape\r\n * @aka Edit.SimpleShape\r\n */\r\nL.Edit.SimpleShape = L.Handler.extend({\r\n\toptions: {\r\n\t\tmoveIcon: new L.DivIcon({\r\n\t\t\ticonSize: new L.Point(8, 8),\r\n\t\t\tclassName: \"leaflet-div-icon leaflet-editing-icon leaflet-edit-move\",\r\n\t\t}),\r\n\t\tresizeIcon: new L.DivIcon({\r\n\t\t\ticonSize: new L.Point(8, 8),\r\n\t\t\tclassName: \"leaflet-div-icon leaflet-editing-icon leaflet-edit-resize\",\r\n\t\t}),\r\n\t\ttouchMoveIcon: new L.DivIcon({\r\n\t\t\ticonSize: new L.Point(20, 20),\r\n\t\t\tclassName:\r\n\t\t\t\t\"leaflet-div-icon leaflet-editing-icon leaflet-edit-move leaflet-touch-icon\",\r\n\t\t}),\r\n\t\ttouchResizeIcon: new L.DivIcon({\r\n\t\t\ticonSize: new L.Point(20, 20),\r\n\t\t\tclassName:\r\n\t\t\t\t\"leaflet-div-icon leaflet-editing-icon leaflet-edit-resize leaflet-touch-icon\",\r\n\t\t}),\r\n\t},\r\n\r\n\t// @method intialize(): void\r\n\tinitialize: function (shape, options) {\r\n\t\t// if touch, switch to touch icon\r\n\t\tif (L.Browser.touch) {\r\n\t\t\tthis.options.moveIcon = this.options.touchMoveIcon;\r\n\t\t\tthis.options.resizeIcon = this.options.touchResizeIcon;\r\n\t\t}\r\n\r\n\t\tthis._shape = shape;\r\n\t\tL.Util.setOptions(this, options);\r\n\t},\r\n\r\n\t// @method addHooks(): void\r\n\t// Add listener hooks to this handler\r\n\taddHooks: function () {\r\n\t\tvar shape = this._shape;\r\n\t\tif (this._shape._map) {\r\n\t\t\tthis._map = this._shape._map;\r\n\t\t\tshape.setStyle(shape.options.editing);\r\n\r\n\t\t\tif (shape._map) {\r\n\t\t\t\tthis._map = shape._map;\r\n\t\t\t\tif (!this._markerGroup) {\r\n\t\t\t\t\tthis._initMarkers();\r\n\t\t\t\t}\r\n\t\t\t\tthis._map.addLayer(this._markerGroup);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t// @method removeHooks(): void\r\n\t// Remove listener hooks from this handler\r\n\tremoveHooks: function () {\r\n\t\tvar shape = this._shape;\r\n\r\n\t\tshape.setStyle(shape.options.original);\r\n\r\n\t\tif (shape._map) {\r\n\t\t\tthis._unbindMarker(this._moveMarker);\r\n\t\t\tthis._unbindMarker(this._rotateMarker);\r\n\r\n\t\t\tfor (var i = 0, l = this._resizeMarkers.length; i < l; i++) {\r\n\t\t\t\tthis._unbindMarker(this._resizeMarkers[i]);\r\n\t\t\t}\r\n\t\t\tthis._resizeMarkers = null;\r\n\r\n\t\t\tthis._map.removeLayer(this._markerGroup);\r\n\t\t\tdelete this._markerGroup;\r\n\t\t}\r\n\r\n\t\tthis._map = null;\r\n\t},\r\n\r\n\t// @method updateMarkers(): void\r\n\t// Remove the edit markers from this layer\r\n\tupdateMarkers: function () {\r\n\t\tthis._markerGroup.clearLayers();\r\n\t\tthis._initMarkers();\r\n\t},\r\n\r\n\t_initMarkers: function () {\r\n\t\tif (!this._markerGroup) {\r\n\t\t\tthis._markerGroup = new L.LayerGroup();\r\n\t\t}\r\n\r\n\t\t// Create center marker\r\n\t\tthis._createMoveMarker();\r\n\r\n\t\t// Create edge marker\r\n\t\tthis._createResizeMarker();\r\n\r\n\t\t// Create rotate marker\r\n\t\tthis._createRotateMarker();\r\n\t},\r\n\r\n\t_createMoveMarker: function () {\r\n\t\t// Children override\r\n\t},\r\n\r\n\t_createResizeMarker: function () {\r\n\t\t// Children override\r\n\t},\r\n\r\n\t_createRotateMarker: function () {\r\n\t\t// Children override\r\n\t},\r\n\r\n\t_createMarker: function (latlng, icon) {\r\n\t\t// Extending L.Marker in TouchEvents.js to include touch.\r\n\t\tvar marker = new L.Marker.Touch(latlng, {\r\n\t\t\tdraggable: true,\r\n\t\t\ticon: icon,\r\n\t\t\tzIndexOffset: 10,\r\n\t\t});\r\n\r\n\t\tthis._bindMarker(marker);\r\n\r\n\t\tthis._markerGroup.addLayer(marker);\r\n\r\n\t\treturn marker;\r\n\t},\r\n\r\n\t_bindMarker: function (marker) {\r\n\t\tmarker\r\n\t\t\t.on(\"dragstart\", this._onMarkerDragStart, this)\r\n\t\t\t.on(\"drag\", this._onMarkerDrag, this)\r\n\t\t\t.on(\"dragend\", this._onMarkerDragEnd, this)\r\n\t\t\t.on(\"touchstart\", this._onTouchStart, this)\r\n\t\t\t.on(\"touchmove\", this._onTouchMove, this)\r\n\t\t\t.on(\"MSPointerMove\", this._onTouchMove, this)\r\n\t\t\t.on(\"touchend\", this._onTouchEnd, this)\r\n\t\t\t.on(\"MSPointerUp\", this._onTouchEnd, this);\r\n\t},\r\n\r\n\t_unbindMarker: function (marker) {\r\n\t\tif (marker === undefined) return;\r\n\t\tmarker\r\n\t\t\t.off(\"dragstart\", this._onMarkerDragStart, this)\r\n\t\t\t.off(\"drag\", this._onMarkerDrag, this)\r\n\t\t\t.off(\"dragend\", this._onMarkerDragEnd, this)\r\n\t\t\t.off(\"touchstart\", this._onTouchStart, this)\r\n\t\t\t.off(\"touchmove\", this._onTouchMove, this)\r\n\t\t\t.off(\"MSPointerMove\", this._onTouchMove, this)\r\n\t\t\t.off(\"touchend\", this._onTouchEnd, this)\r\n\t\t\t.off(\"MSPointerUp\", this._onTouchEnd, this);\r\n\t},\r\n\r\n\t_onMarkerDragStart: function (e) {\r\n\t\tvar marker = e.target;\r\n\t\tmarker.setOpacity(0);\r\n\r\n\t\tthis._shape.fire(\"editstart\");\r\n\t},\r\n\r\n\t_fireEdit: function () {\r\n\t\tthis._shape.edited = true;\r\n\t\tthis._shape.fire(\"edit\");\r\n\t},\r\n\r\n\t_onMarkerDrag: function (e) {\r\n\t\tvar marker = e.target,\r\n\t\t\tlatlng = marker.getLatLng();\r\n\r\n\t\tif (marker === this._moveMarker) {\r\n\t\t\tthis._move(latlng);\r\n\t\t} else if (marker === this._rotateMarker) {\r\n\t\t\tthis._rotate(latlng);\r\n\t\t} else {\r\n\t\t\tthis._resize(latlng);\r\n\t\t}\r\n\r\n\t\tthis._shape.redraw();\r\n\t\tthis._shape.fire(\"editdrag\");\r\n\t},\r\n\r\n\t_onMarkerDragEnd: function (e) {\r\n\t\tvar marker = e.target;\r\n\t\tmarker.setOpacity(1);\r\n\r\n\t\tthis._fireEdit();\r\n\t},\r\n\r\n\t_onTouchStart: function (e) {\r\n\t\tL.Edit.SimpleShape.prototype._onMarkerDragStart.call(this, e);\r\n\r\n\t\tif (typeof this._getCorners === \"function\") {\r\n\t\t\t// Save a reference to the opposite point\r\n\t\t\tvar corners = this._getCorners(),\r\n\t\t\t\tmarker = e.target,\r\n\t\t\t\tcurrentCornerIndex = marker._cornerIndex;\r\n\r\n\t\t\tmarker.setOpacity(0);\r\n\r\n\t\t\t// Copyed from Edit.Rectangle.js line 23 _onMarkerDragStart()\r\n\t\t\t// Latlng is null otherwise.\r\n\t\t\tthis._oppositeCorner = corners[(currentCornerIndex + 2) % 4];\r\n\t\t\tthis._toggleCornerMarkers(0, currentCornerIndex);\r\n\t\t}\r\n\r\n\t\tthis._shape.fire(\"editstart\");\r\n\t},\r\n\r\n\t_onTouchMove: function (e) {\r\n\t\tvar layerPoint = this._map.mouseEventToLayerPoint(\r\n\t\t\t\te.originalEvent.touches[0]\r\n\t\t\t),\r\n\t\t\tlatlng = this._map.layerPointToLatLng(layerPoint),\r\n\t\t\tmarker = e.target;\r\n\r\n\t\tif (marker === this._moveMarker) {\r\n\t\t\tthis._move(latlng);\r\n\t\t} else if (marker === this._rotateMarker) {\r\n\t\t\tthis._rotate(latlng);\r\n\t\t} else {\r\n\t\t\tthis._resize(latlng);\r\n\t\t}\r\n\r\n\t\tthis._shape.redraw();\r\n\r\n\t\t// prevent touchcancel in IOS\r\n\t\t// e.preventDefault();\r\n\t\treturn false;\r\n\t},\r\n\r\n\t_onTouchEnd: function (e) {\r\n\t\tvar marker = e.target;\r\n\t\tmarker.setOpacity(1);\r\n\t\tthis.updateMarkers();\r\n\t\tthis._fireEdit();\r\n\t},\r\n\r\n\t_move: function () {\r\n\t\t// Children override\r\n\t},\r\n\r\n\t_resize: function () {\r\n\t\t// Children override\r\n\t},\r\n\r\n\t_rotate: function () {\r\n\t\t// Children override\r\n\t},\r\n});\r\n","L.Edit.SimpleShapeSnap = L.Edit.SimpleShape.extend({\r\n\tinitialize: function (shape, options) {\r\n\t\tL.Edit.SimpleShape.prototype.initialize.call(this, shape, options);\r\n\t},\r\n\r\n\taddHooks: function () {\r\n\t\tL.Edit.SimpleShape.prototype.addHooks.call(this);\r\n\t\tthis._moveMarker.snapediting = new L.Handler.MarkerSnap(\r\n\t\t\tthis._map,\r\n\t\t\tthis._moveMarker\r\n\t\t);\r\n\t\tthis.options.guideLayers.forEach((element) => {\r\n\t\t\tthis._moveMarker.snapediting.addGuideLayer(element);\r\n\t\t});\r\n\t\tthis._moveMarker.snapediting.enable();\r\n\t},\r\n\r\n\tremoveHooks: function () {\r\n\t\tL.Edit.SimpleShape.prototype.removeHooks.call(this);\r\n\t\tthis._moveMarker.snapediting.disable();\r\n\t},\r\n});\r\n","L.Edit = L.Edit || {};\r\n/**\r\n * @class L.Edit.Rectangle\r\n * @aka Edit.Rectangle\r\n * @inherits L.Edit.SimpleShape\r\n */\r\nL.Edit.Rectangle = L.Edit.SimpleShape.extend({\r\n\t_createMoveMarker: function () {\r\n\t\tvar bounds = this._shape.getBounds(),\r\n\t\t\tcenter = bounds.getCenter();\r\n\r\n\t\tthis._moveMarker = this._createMarker(center, this.options.moveIcon);\r\n\t},\r\n\r\n\t_createResizeMarker: function () {\r\n\t\tvar corners = this._getCorners();\r\n\r\n\t\tthis._resizeMarkers = [];\r\n\r\n\t\tfor (var i = 0, l = corners.length; i < l; i++) {\r\n\t\t\tthis._resizeMarkers.push(this._createMarker(corners[i], this.options.resizeIcon));\r\n\t\t\t// Monkey in the corner index as we will need to know this for dragging\r\n\t\t\tthis._resizeMarkers[i]._cornerIndex = i;\r\n\t\t}\r\n\t},\r\n\r\n\t_onMarkerDragStart: function (e) {\r\n\t\tL.Edit.SimpleShape.prototype._onMarkerDragStart.call(this, e);\r\n\r\n\t\t// Save a reference to the opposite point\r\n\t\tvar corners = this._getCorners(),\r\n\t\t\tmarker = e.target,\r\n\t\t\tcurrentCornerIndex = marker._cornerIndex;\r\n\r\n\t\tthis._oppositeCorner = corners[(currentCornerIndex + 2) % 4];\r\n\r\n\t\tthis._toggleCornerMarkers(0, currentCornerIndex);\r\n\t},\r\n\r\n\t_onMarkerDragEnd: function (e) {\r\n\t\tvar marker = e.target,\r\n\t\t\tbounds, center;\r\n\r\n\t\t// Reset move marker position to the center\r\n\t\tif (marker === this._moveMarker) {\r\n\t\t\tbounds = this._shape.getBounds();\r\n\t\t\tcenter = bounds.getCenter();\r\n\r\n\t\t\tmarker.setLatLng(center);\r\n\t\t}\r\n\r\n\t\tthis._toggleCornerMarkers(1);\r\n\r\n\t\tthis._repositionCornerMarkers();\r\n\r\n\t\tL.Edit.SimpleShape.prototype._onMarkerDragEnd.call(this, e);\r\n\t},\r\n\r\n\t_move: function (newCenter) {\r\n\t\tvar latlngs = this._shape._defaultShape ? this._shape._defaultShape() : this._shape.getLatLngs(),\r\n\t\t\tbounds = this._shape.getBounds(),\r\n\t\t\tcenter = bounds.getCenter(),\r\n\t\t\toffset, newLatLngs = [];\r\n\r\n\t\t// Offset the latlngs to the new center\r\n\t\tfor (var i = 0, l = latlngs.length; i < l; i++) {\r\n\t\t\toffset = [latlngs[i].lat - center.lat, latlngs[i].lng - center.lng];\r\n\t\t\tnewLatLngs.push([newCenter.lat + offset[0], newCenter.lng + offset[1]]);\r\n\t\t}\r\n\r\n\t\tthis._shape.setLatLngs(newLatLngs);\r\n\r\n\t\t// Reposition the resize markers\r\n\t\tthis._repositionCornerMarkers();\r\n\r\n\t\tthis._map.fire(L.Draw.Event.EDITMOVE, {layer: this._shape});\r\n\t},\r\n\r\n\t_resize: function (latlng) {\r\n\t\tvar bounds;\r\n\r\n\t\t// Update the shape based on the current position of this corner and the opposite point\r\n\t\tthis._shape.setBounds(L.latLngBounds(latlng, this._oppositeCorner));\r\n\r\n\t\t// Reposition the move marker\r\n\t\tbounds = this._shape.getBounds();\r\n\t\tthis._moveMarker.setLatLng(bounds.getCenter());\r\n\r\n\t\tthis._map.fire(L.Draw.Event.EDITRESIZE, {layer: this._shape});\r\n\t},\r\n\r\n\t_getCorners: function () {\r\n\t\tvar bounds = this._shape.getBounds(),\r\n\t\t\tnw = bounds.getNorthWest(),\r\n\t\t\tne = bounds.getNorthEast(),\r\n\t\t\tse = bounds.getSouthEast(),\r\n\t\t\tsw = bounds.getSouthWest();\r\n\r\n\t\treturn [nw, ne, se, sw];\r\n\t},\r\n\r\n\t_toggleCornerMarkers: function (opacity) {\r\n\t\tfor (var i = 0, l = this._resizeMarkers.length; i < l; i++) {\r\n\t\t\tthis._resizeMarkers[i].setOpacity(opacity);\r\n\t\t}\r\n\t},\r\n\r\n\t_repositionCornerMarkers: function () {\r\n\t\tvar corners = this._getCorners();\r\n\r\n\t\tfor (var i = 0, l = this._resizeMarkers.length; i < l; i++) {\r\n\t\t\tthis._resizeMarkers[i].setLatLng(corners[i]);\r\n\t\t}\r\n\t}\r\n});\r\n\r\nL.Rectangle.addInitHook(function () {\r\n\tif (L.Edit.Rectangle) {\r\n\t\tthis.editing = new L.Edit.Rectangle(this);\r\n\r\n\t\tif (this.options.editable) {\r\n\t\t\tthis.editing.enable();\r\n\t\t}\r\n\t}\r\n});\r\n","L.Edit = L.Edit || {};\r\n/**\r\n * @class L.Edit.CircleMarker\r\n * @aka Edit.Circle\r\n * @inherits L.Edit.SimpleShape\r\n */\r\nL.Edit.CircleMarker = L.Edit.SimpleShape.extend({\r\n\t_createMoveMarker: function () {\r\n\t\tvar center = this._shape.getLatLng();\r\n\r\n\t\tthis._moveMarker = this._createMarker(center, this.options.moveIcon);\r\n\t},\r\n\r\n\t_createResizeMarker: function () {\r\n\t\t// To avoid an undefined check in L.Edit.SimpleShape.removeHooks\r\n\t\tthis._resizeMarkers = [];\r\n\t},\r\n\r\n\t_move: function (latlng) {\r\n\t\tif (this._resizeMarkers.length) {\r\n\t\t\tvar resizemarkerPoint = this._getResizeMarkerPoint(latlng);\r\n\t\t\t// Move the resize marker\r\n\t\t\tthis._resizeMarkers[0].setLatLng(resizemarkerPoint);\r\n\t\t}\r\n\r\n\t\t// Move the circle\r\n\t\tthis._shape.setLatLng(latlng);\r\n\r\n\t\tthis._map.fire(L.Draw.Event.EDITMOVE, {layer: this._shape});\r\n\t},\r\n});\r\n\r\nL.CircleMarker.addInitHook(function () {\r\n\tif (L.Edit.CircleMarker) {\r\n\t\tthis.editing = new L.Edit.CircleMarker(this);\r\n\r\n\t\tif (this.options.editable) {\r\n\t\t\tthis.editing.enable();\r\n\t\t}\r\n\t}\r\n\r\n\tthis.on('add', function () {\r\n\t\tif (this.editing && this.editing.enabled()) {\r\n\t\t\tthis.editing.addHooks();\r\n\t\t}\r\n\t});\r\n\r\n\tthis.on('remove', function () {\r\n\t\tif (this.editing && this.editing.enabled()) {\r\n\t\t\tthis.editing.removeHooks();\r\n\t\t}\r\n\t});\r\n});\r\n","L.Edit = L.Edit || {};\r\n/**\r\n * @class L.Edit.Circle\r\n * @aka Edit.Circle\r\n * @inherits L.Edit.CircleMarker\r\n */\r\nL.Edit.Circle = L.Edit.CircleMarker.extend({\r\n\r\n\t_createResizeMarker: function () {\r\n\t\tvar center = this._shape.getLatLng(),\r\n\t\t\tresizemarkerPoint = this._getResizeMarkerPoint(center);\r\n\r\n\t\tthis._resizeMarkers = [];\r\n\t\tthis._resizeMarkers.push(this._createMarker(resizemarkerPoint, this.options.resizeIcon));\r\n\t},\r\n\r\n\t_getResizeMarkerPoint: function (latlng) {\r\n\t\t// From L.shape.getBounds()\r\n\t\tvar delta = this._shape._radius * Math.cos(Math.PI / 4),\r\n\t\t\tpoint = this._map.project(latlng);\r\n\t\treturn this._map.unproject([point.x + delta, point.y - delta]);\r\n\t},\r\n\r\n\t_resize: function (latlng) {\r\n\t\tvar moveLatLng = this._moveMarker.getLatLng();\r\n\r\n\t\t// Calculate the radius based on the version\r\n\t\tif (L.GeometryUtil.isVersion07x()) {\r\n\t\t\tradius = moveLatLng.distanceTo(latlng);\r\n\t\t} else {\r\n\t\t\tradius = this._map.distance(moveLatLng, latlng);\r\n\t\t}\r\n\t\tthis._shape.setRadius(radius);\r\n\r\n\t\tif (this._map.editTooltip) {\r\n\t\t\tthis._map._editTooltip.updateContent({\r\n\t\t\t\ttext: L.drawLocal.edit.handlers.edit.tooltip.subtext + '<br />' + L.drawLocal.edit.handlers.edit.tooltip.text,\r\n\t\t\t\tsubtext: L.drawLocal.draw.handlers.circle.radius + ': ' +\r\n\t\t\t\tL.GeometryUtil.readableDistance(radius, true, this.options.feet, this.options.nautic)\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tthis._shape.setRadius(radius);\r\n\r\n\t\tthis._map.fire(L.Draw.Event.EDITRESIZE, {layer: this._shape});\r\n\t}\r\n});\r\n\r\nL.Circle.addInitHook(function () {\r\n\tif (L.Edit.Circle) {\r\n\t\tthis.editing = new L.Edit.Circle(this);\r\n\r\n\t\tif (this.options.editable) {\r\n\t\t\tthis.editing.enable();\r\n\t\t}\r\n\t}\r\n});\r\n","L.Edit = L.Edit || {};\r\n/**\r\n * @class L.Edit.CircleMarker\r\n * @aka Edit.Circle\r\n * @inherits L.Edit.SimpleShape\r\n */\r\nL.Edit.ThanhCai = L.Edit.SimpleShapeSnap.extend({\r\n\tinitialize: function (shape, options) {\r\n\t\tL.Edit.SimpleShapeSnap.prototype.initialize.call(this, shape, options);\r\n\t},\r\n\r\n\t_createMoveMarker: function () {\r\n\t\tthis._moveMarker = this._createMarker(\r\n\t\t\tthis._shape.getCenterCus(),\r\n\t\t\tthis.options.moveIcon\r\n\t\t);\r\n\t},\r\n\r\n\t_createResizeMarker: function () {\r\n\t\t// To avoid an undefined check in L.Edit.SimpleShape.removeHooks\r\n\t\tthis._resizeMarkers = [];\r\n\t\tconst latLngs = this._shape.getLatLngs();\r\n\t\tconst pA = latLngs[0];\r\n\t\tthis._resizeMarkers.push(this._createMarker(pA, this.options.resizeIcon));\r\n\t},\r\n\r\n\t_createRotateMarker: function () {\r\n\t\tconst latLng = this._shape.getRotateMarker();\r\n\t\tthis._rotateMarker = this._createMarker(latLng, this.options.moveIcon);\r\n\t},\r\n\r\n\t_move: function (latlng) {\r\n\t\tthis._shape.move(latlng);\r\n\t\tthis._updateMarkers();\r\n\t\tthis._map.fire(L.Draw.Event.EDITMOVE, { layer: this._shape });\r\n\t},\r\n\r\n\t_resize: function (latlng) {\r\n\t\tthis._shape.resize(latlng);\r\n\t\tthis._updateMarkers();\r\n\t\tthis._map.fire(L.Draw.Event.EDITRESIZE, { layer: this._shape });\r\n\t},\r\n\r\n\t_rotate: function (latlng) {\r\n\t\tthis._shape.rotate(latlng);\r\n\t\tthis._updateMarkers();\r\n\t},\r\n\r\n\t_updateMarkers: function () {\r\n\t\tthis._resizeMarkers[0].setLatLng(this._shape.getLatLngs()[0]);\r\n\t\tthis._rotateMarker.setLatLng(this._shape.getRotateMarker());\r\n\t},\r\n});\r\n\r\nL.ThanhCai.addInitHook(function () {\r\n\tif (this.editing) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (L.Edit.ThanhCai) {\r\n\t\tthis.editing = new L.Edit.ThanhCai(this, this.options);\r\n\r\n\t\tif (this.options.editable) {\r\n\t\t\tthis.editing.enable();\r\n\t\t}\r\n\t}\r\n\r\n\tthis.on(\"add\", function () {\r\n\t\tif (this.editing && this.editing.enabled()) {\r\n\t\t\tthis.editing.addHooks();\r\n\t\t}\r\n\t});\r\n\r\n\tthis.on(\"remove\", function () {\r\n\t\tif (this.editing && this.editing.enabled()) {\r\n\t\t\tthis.editing.removeHooks();\r\n\t\t}\r\n\t});\r\n});\r\n","L.Edit = L.Edit || {};\r\n/**\r\n * @class L.Edit.CircleMarker\r\n * @aka Edit.Circle\r\n * @inherits L.Edit.SimpleShape\r\n */\r\nL.Edit.Role = L.Edit.SimpleShapeSnap.extend({\r\n\tinitialize: function (shape, options) {\r\n\t\tL.Edit.SimpleShapeSnap.prototype.initialize.call(this, shape, options);\r\n\t},\r\n\r\n\t_createMoveMarker: function () {\r\n\t\tthis._moveMarker = this._createMarker(\r\n\t\t\tthis._shape.getCenterCus(),\r\n\t\t\tthis.options.moveIcon\r\n\t\t);\r\n\t},\r\n\r\n\t_createResizeMarker: function () {\r\n\t\t// To avoid an undefined check in L.Edit.SimpleShape.removeHooks\r\n\t\tconst latLngs = this._shape.getLatLngs();\r\n\t\tthis._resizeMarkers = [];\r\n\t\tthis._resizeMarkers.push(\r\n\t\t\tthis._createMarker(latLngs[0], this.options.resizeIcon)\r\n\t\t);\r\n\t},\r\n\r\n\t_createRotateMarker: function () {\r\n\t\tconst latLng = this._shape.getRotateMarker();\r\n\t\tthis._rotateMarker = this._createMarker(latLng, this.options.moveIcon);\r\n\t},\r\n\r\n\t_move: function (latlng) {\r\n\t\tthis._shape.move(latlng);\r\n\t\tthis._updateMarkers();\r\n\t\tthis._map.fire(L.Draw.Event.EDITMOVE, { layer: this._shape });\r\n\t},\r\n\r\n\t_resize: function (latlng) {\r\n\t\tthis._shape.resize(latlng);\r\n\t\tthis._updateMarkers();\r\n\t\tthis._map.fire(L.Draw.Event.EDITRESIZE, { layer: this._shape });\r\n\t},\r\n\r\n\t_rotate: function (latlng) {\r\n\t\tthis._shape.rotate(latlng);\r\n\t\tthis._updateMarkers();\r\n\t\tthis._map.fire(L.Draw.Event.EDITROTATE, { layer: this._shape });\r\n\t},\r\n\r\n\t_updateMarkers: function () {\r\n\t\tthis._resizeMarkers[0].setLatLng(this._shape.getLatLngs()[0]);\r\n\t\tthis._rotateMarker.setLatLng(this._shape.getRotateMarker());\r\n\t},\r\n});\r\n\r\nL.Role.addInitHook(function () {\r\n\tif (this.editing) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (L.Edit.Role) {\r\n\t\tthis.editing = new L.Edit.Role(this, this.options);\r\n\t\tif (this.options.editable) {\r\n\t\t\tthis.editing.enable();\r\n\t\t}\r\n\t}\r\n\r\n\tthis.on(\"add\", function () {\r\n\t\tif (this.editing && this.editing.enabled()) {\r\n\t\t\tthis.editing.addHooks();\r\n\t\t}\r\n\t});\r\n\r\n\tthis.on(\"remove\", function () {\r\n\t\tif (this.editing && this.editing.enabled()) {\r\n\t\t\tthis.editing.removeHooks();\r\n\t\t}\r\n\t});\r\n});\r\n","L.Edit = L.Edit || {};\r\n/**\r\n * @class L.Edit.CircleMarker\r\n * @aka Edit.Circle\r\n * @inherits L.Edit.SimpleShape\r\n */\r\nL.Edit.MayBienAp = L.Edit.SimpleShapeSnap.extend({\r\n\tinitialize: function (shape, options) {\r\n\t\tL.Edit.SimpleShapeSnap.prototype.initialize.call(this, shape, options);\r\n\t},\r\n\r\n\t_createMoveMarker: function () {\r\n\t\tthis._moveMarker = this._createMarker(\r\n\t\t\tthis._shape._latlng,\r\n\t\t\tthis.options.moveIcon\r\n\t\t);\r\n\t},\r\n\r\n\t_createResizeMarker: function () {\r\n\t\t// To avoid an undefined check in L.Edit.SimpleShape.removeHooks\r\n\t\tthis._resizeMarkers = [];\r\n\t\tthis._resizeMarkers.push(\r\n\t\t\tthis._createMarker(this._shape._getLatLngC(), this.options.resizeIcon)\r\n\t\t);\r\n\t},\r\n\r\n\t_createRotateMarker: function () {\r\n\t\tconst latLng = this._shape.getRotateMarker();\r\n\t\tthis._rotateMarker = this._createMarker(latLng, this.options.moveIcon);\r\n\t},\r\n\r\n\t_move: function (latlng) {\r\n\t\tthis._shape.move(latlng);\r\n\t\tthis._updateMarkers();\r\n\t\tthis._map.fire(L.Draw.Event.EDITMOVE, { layer: this._shape });\r\n\t},\r\n\r\n\t_resize: function (latlng) {\r\n\t\tthis._shape.resize(latlng);\r\n\t\tthis._updateMarkers();\r\n\t\tthis._map.fire(L.Draw.Event.EDITRESIZE, { layer: this._shape });\r\n\t},\r\n\r\n\t_rotate: function (latlng) {\r\n\t\tthis._shape.rotate(latlng);\r\n\t\tthis._updateMarkers();\r\n\t},\r\n\r\n\t_updateMarkers: function () {\r\n\t\tthis._resizeMarkers[0].setLatLng(this._shape._getLatLngC());\r\n\t\tthis._rotateMarker.setLatLng(this._shape.getRotateMarker());\r\n\t},\r\n});\r\n\r\nL.MayBienAp.addInitHook(function () {\r\n\tif (this.editing) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (L.Edit.MayBienAp) {\r\n\t\tthis.editing = new L.Edit.MayBienAp(this, this.options);\r\n\r\n\t\tif (this.options.editable) {\r\n\t\t\tthis.editing.enable();\r\n\t\t}\r\n\t}\r\n\r\n\tthis.on(\"add\", function () {\r\n\t\tif (this.editing && this.editing.enabled()) {\r\n\t\t\tthis.editing.addHooks();\r\n\t\t}\r\n\t});\r\n\r\n\tthis.on(\"remove\", function () {\r\n\t\tif (this.editing && this.editing.enabled()) {\r\n\t\t\tthis.editing.removeHooks();\r\n\t\t}\r\n\t});\r\n});\r\n","L.Edit = L.Edit || {};\r\n\r\n/**\r\n * @class L.Edit.DuongDay\r\n * @aka L.Edit.Poly\r\n * @aka Edit.Poly\r\n */\r\nL.Edit.DuongDay = L.Edit.Poly.extend({\r\n\tinitialize: function (poly, options) {\r\n\t\tL.Edit.Poly.prototype.initialize.call(this, poly, options);\r\n\t\tL.Util.setOptions(this, options);\r\n\t},\r\n\taddHooks: function () {\r\n\t\tL.Edit.Poly.prototype.addHooks.call(this);\r\n\t\tthis._poly.snapediting = new L.Handler.PolylineSnap(\r\n\t\t\tthis._poly._map,\r\n\t\t\tthis._poly,\r\n\t\t\tthis._poly.options\r\n\t\t);\r\n\t\tthis.options.guideLayers.forEach((element) => {\r\n\t\t\tthis._poly.snapediting.addGuideLayer(element);\r\n\t\t});\r\n\t\tthis._poly.snapediting.enable();\r\n\t},\r\n\tremoveHooks: function () {\r\n\t\tL.Edit.Poly.prototype.removeHooks.call(this);\r\n\t\tthis._poly.snapediting.disable();\r\n\t},\r\n});\r\n\r\nL.DuongDay.addInitHook(function () {\r\n\t// Check to see if handler has already been initialized. This is to support versions of Leaflet that still have L.Handler.PolyEdit\r\n\tif (this.editing) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (L.Edit.DuongDay) {\r\n\t\tthis.editing = new L.Edit.DuongDay(this, this.options);\r\n\r\n\t\tif (this.options.editable) {\r\n\t\t\tthis.editing.enable();\r\n\t\t}\r\n\t}\r\n\r\n\tthis.on(\"add\", function () {\r\n\t\tif (this.editing && this.editing.enabled()) {\r\n\t\t\tthis.editing.addHooks();\r\n\t\t}\r\n\t});\r\n\r\n\tthis.on(\"remove\", function () {\r\n\t\tif (this.editing && this.editing.enabled()) {\r\n\t\t\tthis.editing.removeHooks();\r\n\t\t}\r\n\t});\r\n});\r\n","L.Map.mergeOptions({\r\n\ttouchExtend: true\r\n});\r\n\r\n/**\r\n * @class L.Map.TouchExtend\r\n * @aka TouchExtend\r\n */\r\nL.Map.TouchExtend = L.Handler.extend({\r\n\r\n\t// @method initialize(): void\r\n\t// Sets TouchExtend private accessor variables\r\n\tinitialize: function (map) {\r\n\t\tthis._map = map;\r\n\t\tthis._container = map._container;\r\n\t\tthis._pane = map._panes.overlayPane;\r\n\t},\r\n\r\n\t// @method addHooks(): void\r\n\t// Adds dom listener events to the map container\r\n\taddHooks: function () {\r\n\t\tL.DomEvent.on(this._container, 'touchstart', this._onTouchStart, this);\r\n\t\tL.DomEvent.on(this._container, 'touchend', this._onTouchEnd, this);\r\n\t\tL.DomEvent.on(this._container, 'touchmove', this._onTouchMove, this);\r\n\t\tif (this._detectIE()) {\r\n\t\t\tL.DomEvent.on(this._container, 'MSPointerDown', this._onTouchStart, this);\r\n\t\t\tL.DomEvent.on(this._container, 'MSPointerUp', this._onTouchEnd, this);\r\n\t\t\tL.DomEvent.on(this._container, 'MSPointerMove', this._onTouchMove, this);\r\n\t\t\tL.DomEvent.on(this._container, 'MSPointerCancel', this._onTouchCancel, this);\r\n\r\n\t\t} else {\r\n\t\t\tL.DomEvent.on(this._container, 'touchcancel', this._onTouchCancel, this);\r\n\t\t\tL.DomEvent.on(this._container, 'touchleave', this._onTouchLeave, this);\r\n\t\t}\r\n\t},\r\n\r\n\t// @method removeHooks(): void\r\n\t// Removes dom listener events from the map container\r\n\tremoveHooks: function () {\r\n\t\tL.DomEvent.off(this._container, 'touchstart', this._onTouchStart, this);\r\n\t\tL.DomEvent.off(this._container, 'touchend', this._onTouchEnd, this);\r\n\t\tL.DomEvent.off(this._container, 'touchmove', this._onTouchMove, this);\r\n\t\tif (this._detectIE()) {\r\n\t\t\tL.DomEvent.off(this._container, 'MSPointerDown', this._onTouchStart, this);\r\n\t\t\tL.DomEvent.off(this._container, 'MSPointerUp', this._onTouchEnd, this);\r\n\t\t\tL.DomEvent.off(this._container, 'MSPointerMove', this._onTouchMove, this);\r\n\t\t\tL.DomEvent.off(this._container, 'MSPointerCancel', this._onTouchCancel, this);\r\n\t\t} else {\r\n\t\t\tL.DomEvent.off(this._container, 'touchcancel', this._onTouchCancel, this);\r\n\t\t\tL.DomEvent.off(this._container, 'touchleave', this._onTouchLeave, this);\r\n\t\t}\r\n\t},\r\n\r\n\t_touchEvent: function (e, type) {\r\n\t\t// #TODO: fix the pageX error that is do a bug in Android where a single touch triggers two click events\r\n\t\t// _filterClick is what leaflet uses as a workaround.\r\n\t\t// This is a problem with more things than just android. Another problem is touchEnd has no touches in\r\n\t\t// its touch list.\r\n\t\tvar touchEvent = {};\r\n\t\tif (typeof e.touches !== 'undefined') {\r\n\t\t\tif (!e.touches.length) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\ttouchEvent = e.touches[0];\r\n\t\t} else if (e.pointerType === 'touch') {\r\n\t\t\ttouchEvent = e;\r\n\t\t\tif (!this._filterClick(e)) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar containerPoint = this._map.mouseEventToContainerPoint(touchEvent),\r\n\t\t\tlayerPoint = this._map.mouseEventToLayerPoint(touchEvent),\r\n\t\t\tlatlng = this._map.layerPointToLatLng(layerPoint);\r\n\r\n\t\tthis._map.fire(type, {\r\n\t\t\tlatlng: latlng,\r\n\t\t\tlayerPoint: layerPoint,\r\n\t\t\tcontainerPoint: containerPoint,\r\n\t\t\tpageX: touchEvent.pageX,\r\n\t\t\tpageY: touchEvent.pageY,\r\n\t\t\toriginalEvent: e\r\n\t\t});\r\n\t},\r\n\r\n\t/** Borrowed from Leaflet and modified for bool ops **/\r\n\t_filterClick: function (e) {\r\n\t\tvar timeStamp = (e.timeStamp || e.originalEvent.timeStamp),\r\n\t\t\telapsed = L.DomEvent._lastClick && (timeStamp - L.DomEvent._lastClick);\r\n\r\n\t\t// are they closer together than 500ms yet more than 100ms?\r\n\t\t// Android typically triggers them ~300ms apart while multiple listeners\r\n\t\t// on the same event should be triggered far faster;\r\n\t\t// or check if click is simulated on the element, and if it is, reject any non-simulated events\r\n\t\tif ((elapsed && elapsed > 100 && elapsed < 500) || (e.target._simulatedClick && !e._simulated)) {\r\n\t\t\tL.DomEvent.stop(e);\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tL.DomEvent._lastClick = timeStamp;\r\n\t\treturn true;\r\n\t},\r\n\r\n\t_onTouchStart: function (e) {\r\n\t\tif (!this._map._loaded) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar type = 'touchstart';\r\n\t\tthis._touchEvent(e, type);\r\n\r\n\t},\r\n\r\n\t_onTouchEnd: function (e) {\r\n\t\tif (!this._map._loaded) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar type = 'touchend';\r\n\t\tthis._touchEvent(e, type);\r\n\t},\r\n\r\n\t_onTouchCancel: function (e) {\r\n\t\tif (!this._map._loaded) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar type = 'touchcancel';\r\n\t\tif (this._detectIE()) {\r\n\t\t\ttype = 'pointercancel';\r\n\t\t}\r\n\t\tthis._touchEvent(e, type);\r\n\t},\r\n\r\n\t_onTouchLeave: function (e) {\r\n\t\tif (!this._map._loaded) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar type = 'touchleave';\r\n\t\tthis._touchEvent(e, type);\r\n\t},\r\n\r\n\t_onTouchMove: function (e) {\r\n\t\tif (!this._map._loaded) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar type = 'touchmove';\r\n\t\tthis._touchEvent(e, type);\r\n\t},\r\n\r\n\t_detectIE: function () {\r\n\t\tvar ua = window.navigator.userAgent;\r\n\r\n\t\tvar msie = ua.indexOf('MSIE ');\r\n\t\tif (msie > 0) {\r\n\t\t\t// IE 10 or older => return version number\r\n\t\t\treturn parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);\r\n\t\t}\r\n\r\n\t\tvar trident = ua.indexOf('Trident/');\r\n\t\tif (trident > 0) {\r\n\t\t\t// IE 11 => return version number\r\n\t\t\tvar rv = ua.indexOf('rv:');\r\n\t\t\treturn parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);\r\n\t\t}\r\n\r\n\t\tvar edge = ua.indexOf('Edge/');\r\n\t\tif (edge > 0) {\r\n\t\t\t// IE 12 => return version number\r\n\t\t\treturn parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);\r\n\t\t}\r\n\r\n\t\t// other browser\r\n\t\treturn false;\r\n\t}\r\n});\r\n\r\nL.Map.addInitHook('addHandler', 'touchExtend', L.Map.TouchExtend);\r\n\r\n\r\n/**\r\n * @class L.Marker.Touch\r\n * @aka Marker.Touch\r\n *\r\n * This isn't full Touch support. This is just to get markers to also support dom touch events after creation\r\n * #TODO: find a better way of getting markers to support touch.\r\n */\r\nL.Marker.Touch = L.Marker.extend({\r\n\r\n\t_initInteraction: function () {\r\n\t\tif (!this.addInteractiveTarget) {\r\n\t\t\t// 0.7.x support\r\n\t\t\treturn this._initInteractionLegacy();\r\n\t\t}\r\n\t\t// TODO this may need be updated to re-add touch events for 1.0+\r\n\t\treturn L.Marker.prototype._initInteraction.apply(this);\r\n\t},\r\n\r\n\t// This is an exact copy of https://github.com/Leaflet/Leaflet/blob/v0.7/src/layer/marker/Marker.js\r\n\t// with the addition of the touch events\r\n\t_initInteractionLegacy: function () {\r\n\r\n\t\tif (!this.options.clickable) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// TODO refactor into something shared with Map/Path/etc. to DRY it up\r\n\r\n\t\tvar icon = this._icon,\r\n\t\t\tevents = ['dblclick',\r\n\t\t\t\t'mousedown',\r\n\t\t\t\t'mouseover',\r\n\t\t\t\t'mouseout',\r\n\t\t\t\t'contextmenu',\r\n\t\t\t\t'touchstart',\r\n\t\t\t\t'touchend',\r\n\t\t\t\t'touchmove'];\r\n\t\tif (this._detectIE) {\r\n\t\t\tevents.concat(['MSPointerDown',\r\n\t\t\t\t'MSPointerUp',\r\n\t\t\t\t'MSPointerMove',\r\n\t\t\t\t'MSPointerCancel']);\r\n\t\t} else {\r\n\t\t\tevents.concat(['touchcancel']);\r\n\t\t}\r\n\r\n\t\tL.DomUtil.addClass(icon, 'leaflet-clickable');\r\n\t\tL.DomEvent.on(icon, 'click', this._onMouseClick, this);\r\n\t\tL.DomEvent.on(icon, 'keypress', this._onKeyPress, this);\r\n\r\n\t\tfor (var i = 0; i < events.length; i++) {\r\n\t\t\tL.DomEvent.on(icon, events[i], this._fireMouseEvent, this);\r\n\t\t}\r\n\r\n\t\tif (L.Handler.MarkerDrag) {\r\n\t\t\tthis.dragging = new L.Handler.MarkerDrag(this);\r\n\r\n\t\t\tif (this.options.draggable) {\r\n\t\t\t\tthis.dragging.enable();\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_detectIE: function () {\r\n\t\tvar ua = window.navigator.userAgent;\r\n\r\n\t\tvar msie = ua.indexOf('MSIE ');\r\n\t\tif (msie > 0) {\r\n\t\t\t// IE 10 or older => return version number\r\n\t\t\treturn parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);\r\n\t\t}\r\n\r\n\t\tvar trident = ua.indexOf('Trident/');\r\n\t\tif (trident > 0) {\r\n\t\t\t// IE 11 => return version number\r\n\t\t\tvar rv = ua.indexOf('rv:');\r\n\t\t\treturn parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);\r\n\t\t}\r\n\r\n\t\tvar edge = ua.indexOf('Edge/');\r\n\t\tif (edge > 0) {\r\n\t\t\t// IE 12 => return version number\r\n\t\t\treturn parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);\r\n\t\t}\r\n\r\n\t\t// other browser\r\n\t\treturn false;\r\n\t}\r\n});\r\n","/**\r\n * @class L.LatLngUtil\r\n * @aka LatLngUtil\r\n */\r\nL.LatLngUtil = {\r\n\t// Clones a LatLngs[], returns [][]\r\n\r\n\t// @method cloneLatLngs(LatLngs[]): L.LatLngs[]\r\n\t// Clone the latLng point or points or nested points and return an array with those points\r\n\tcloneLatLngs: function (latlngs) {\r\n\t\tvar clone = [];\r\n\t\tfor (var i = 0, l = latlngs.length; i < l; i++) {\r\n\t\t\t// Check for nested array (Polyline/Polygon)\r\n\t\t\tif (Array.isArray(latlngs[i])) {\r\n\t\t\t\tclone.push(L.LatLngUtil.cloneLatLngs(latlngs[i]));\r\n\t\t\t} else {\r\n\t\t\t\tclone.push(this.cloneLatLng(latlngs[i]));\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn clone;\r\n\t},\r\n\r\n\t// @method cloneLatLng(LatLng): L.LatLng\r\n\t// Clone the latLng and return a new LatLng object.\r\n\tcloneLatLng: function (latlng) {\r\n\t\treturn L.latLng(latlng.lat, latlng.lng);\r\n\t}\r\n};\r\n","// Packaging/modules magic dance.\r\n(function (factory) {\r\n\tvar L;\r\n\tif (typeof define === \"function\" && define.amd) {\r\n\t\t// AMD\r\n\t\tdefine([\"leaflet\"], factory);\r\n\t} else if (typeof module !== \"undefined\") {\r\n\t\t// Node/CommonJS\r\n\t\tL = require(\"leaflet\");\r\n\t\tmodule.exports = factory(L);\r\n\t} else {\r\n\t\t// Browser globals\r\n\t\tif (typeof window.L === \"undefined\") throw \"Leaflet must be loaded first\";\r\n\t\tfactory(window.L);\r\n\t}\r\n})(function (L) {\r\n\t\"use strict\";\r\n\r\n\tL.Polyline._flat =\r\n\t\tL.LineUtil.isFlat ||\r\n\t\tL.Polyline._flat ||\r\n\t\tfunction (latlngs) {\r\n\t\t\t// true if it's a flat array of latlngs; false if nested\r\n\t\t\treturn (\r\n\t\t\t\t!L.Util.isArray(latlngs[0]) ||\r\n\t\t\t\t(typeof latlngs[0][0] !== \"object\" &&\r\n\t\t\t\t\ttypeof latlngs[0][0] !== \"undefined\")\r\n\t\t\t);\r\n\t\t};\r\n\r\n\t/**\r\n\t * @fileOverview Leaflet Geometry utilities for distances and linear referencing.\r\n\t * @name L.GeometryUtil\r\n\t */\r\n\r\n\tL.GeometryUtil = L.extend(L.GeometryUtil || {}, {\r\n\t\t/**\r\n        Shortcut function for planar distance between two {L.LatLng} at current zoom.\r\n\r\n        @tutorial distance-length\r\n\r\n        @param {L.Map} map Leaflet map to be used for this method\r\n        @param {L.LatLng} latlngA geographical point A\r\n        @param {L.LatLng} latlngB geographical point B\r\n        @returns {Number} planar distance\r\n     */\r\n\t\tdistance: function (map, latlngA, latlngB) {\r\n\t\t\treturn map\r\n\t\t\t\t.latLngToLayerPoint(latlngA)\r\n\t\t\t\t.distanceTo(map.latLngToLayerPoint(latlngB));\r\n\t\t},\r\n\r\n\t\t/**\r\n        Shortcut function for planar distance between a {L.LatLng} and a segment (A-B).\r\n        @param {L.Map} map Leaflet map to be used for this method\r\n        @param {L.LatLng} latlng - The position to search\r\n        @param {L.LatLng} latlngA geographical point A of the segment\r\n        @param {L.LatLng} latlngB geographical point B of the segment\r\n        @returns {Number} planar distance\r\n    */\r\n\t\tdistanceSegment: function (map, latlng, latlngA, latlngB) {\r\n\t\t\tvar p = map.latLngToLayerPoint(latlng),\r\n\t\t\t\tp1 = map.latLngToLayerPoint(latlngA),\r\n\t\t\t\tp2 = map.latLngToLayerPoint(latlngB);\r\n\t\t\treturn L.LineUtil.pointToSegmentDistance(p, p1, p2);\r\n\t\t},\r\n\r\n\t\t/**\r\n        Shortcut function for converting distance to readable distance.\r\n        @param {Number} distance distance to be converted\r\n        @param {String} unit 'metric' or 'imperial'\r\n        @returns {String} in yard or miles\r\n    */\r\n\t\treadableDistance: function (distance, unit) {\r\n\t\t\tvar isMetric = unit !== \"imperial\",\r\n\t\t\t\tdistanceStr;\r\n\t\t\tif (isMetric) {\r\n\t\t\t\t// show metres when distance is < 1km, then show km\r\n\t\t\t\tif (distance > 1000) {\r\n\t\t\t\t\tdistanceStr = (distance / 1000).toFixed(2) + \" km\";\r\n\t\t\t\t} else {\r\n\t\t\t\t\tdistanceStr = distance.toFixed(1) + \" m\";\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tdistance *= 1.09361;\r\n\t\t\t\tif (distance > 1760) {\r\n\t\t\t\t\tdistanceStr = (distance / 1760).toFixed(2) + \" miles\";\r\n\t\t\t\t} else {\r\n\t\t\t\t\tdistanceStr = distance.toFixed(1) + \" yd\";\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn distanceStr;\r\n\t\t},\r\n\r\n\t\t/**\r\n        Returns true if the latlng belongs to segment A-B\r\n        @param {L.LatLng} latlng - The position to search\r\n        @param {L.LatLng} latlngA geographical point A of the segment\r\n        @param {L.LatLng} latlngB geographical point B of the segment\r\n        @param {?Number} [tolerance=0.2] tolerance to accept if latlng belongs really\r\n        @returns {boolean}\r\n     */\r\n\t\tbelongsSegment: function (latlng, latlngA, latlngB, tolerance) {\r\n\t\t\ttolerance = tolerance === undefined ? 0.2 : tolerance;\r\n\t\t\tvar hypotenuse = latlngA.distanceTo(latlngB),\r\n\t\t\t\tdelta =\r\n\t\t\t\t\tlatlngA.distanceTo(latlng) + latlng.distanceTo(latlngB) - hypotenuse;\r\n\t\t\treturn delta / hypotenuse < tolerance;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns total length of line\r\n\t\t * @tutorial distance-length\r\n\t\t *\r\n\t\t * @param {L.Polyline|Array<L.Point>|Array<L.LatLng>} coords Set of coordinates\r\n\t\t * @returns {Number} Total length (pixels for Point, meters for LatLng)\r\n\t\t */\r\n\t\tlength: function (coords) {\r\n\t\t\tvar accumulated = L.GeometryUtil.accumulatedLengths(coords);\r\n\t\t\treturn accumulated.length > 0 ? accumulated[accumulated.length - 1] : 0;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns a list of accumulated length along a line.\r\n\t\t * @param {L.Polyline|Array<L.Point>|Array<L.LatLng>} coords Set of coordinates\r\n\t\t * @returns {Array<Number>} Array of accumulated lengths (pixels for Point, meters for LatLng)\r\n\t\t */\r\n\t\taccumulatedLengths: function (coords) {\r\n\t\t\tif (typeof coords.getLatLngs == \"function\") {\r\n\t\t\t\tcoords = coords.getLatLngs();\r\n\t\t\t}\r\n\t\t\tif (coords.length === 0) return [];\r\n\t\t\tvar total = 0,\r\n\t\t\t\tlengths = [0];\r\n\t\t\tfor (var i = 0, n = coords.length - 1; i < n; i++) {\r\n\t\t\t\ttotal += coords[i].distanceTo(coords[i + 1]);\r\n\t\t\t\tlengths.push(total);\r\n\t\t\t}\r\n\t\t\treturn lengths;\r\n\t\t},\r\n\r\n\t\t/**\r\n        Returns the closest point of a {L.LatLng} on the segment (A-B)\r\n\r\n        @tutorial closest\r\n\r\n        @param {L.Map} map Leaflet map to be used for this method\r\n        @param {L.LatLng} latlng - The position to search\r\n        @param {L.LatLng} latlngA geographical point A of the segment\r\n        @param {L.LatLng} latlngB geographical point B of the segment\r\n        @returns {L.LatLng} Closest geographical point\r\n    */\r\n\t\tclosestOnSegment: function (map, latlng, latlngA, latlngB) {\r\n\t\t\tvar maxzoom = map.getMaxZoom();\r\n\t\t\tif (maxzoom === Infinity) maxzoom = map.getZoom();\r\n\t\t\tvar p = map.project(latlng, maxzoom),\r\n\t\t\t\tp1 = map.project(latlngA, maxzoom),\r\n\t\t\t\tp2 = map.project(latlngB, maxzoom),\r\n\t\t\t\tclosest = L.LineUtil.closestPointOnSegment(p, p1, p2);\r\n\t\t\treturn map.unproject(closest, maxzoom);\r\n\t\t},\r\n\r\n\t\t/**\r\n        Returns the closest latlng on layer.\r\n\r\n        Accept nested arrays\r\n\r\n        @tutorial closest\r\n\r\n        @param {L.Map} map Leaflet map to be used for this method\r\n        @param {Array<L.LatLng>|Array<Array<L.LatLng>>|L.PolyLine|L.Polygon} layer - Layer that contains the result\r\n        @param {L.LatLng} latlng - The position to search\r\n        @param {?boolean} [vertices=false] - Whether to restrict to path vertices.\r\n        @returns {L.LatLng} Closest geographical point or null if layer param is incorrect\r\n    */\r\n\t\tclosest: function (map, layer, latlng, vertices) {\r\n\t\t\tvar latlngs,\r\n\t\t\t\tmindist = Infinity,\r\n\t\t\t\tresult = null,\r\n\t\t\t\ti,\r\n\t\t\t\tn,\r\n\t\t\t\tdistance,\r\n\t\t\t\tsubResult;\r\n\r\n\t\t\tif (layer instanceof Array) {\r\n\t\t\t\t// if layer is Array<Array<T>>\r\n\t\t\t\tif (layer[0] instanceof Array && typeof layer[0][0] !== \"number\") {\r\n\t\t\t\t\t// if we have nested arrays, we calc the closest for each array\r\n\t\t\t\t\t// recursive\r\n\t\t\t\t\tfor (i = 0; i < layer.length; i++) {\r\n\t\t\t\t\t\tsubResult = L.GeometryUtil.closest(map, layer[i], latlng, vertices);\r\n\t\t\t\t\t\tif (subResult && subResult.distance < mindist) {\r\n\t\t\t\t\t\t\tmindist = subResult.distance;\r\n\t\t\t\t\t\t\tresult = subResult;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn result;\r\n\t\t\t\t} else if (\r\n\t\t\t\t\tlayer[0] instanceof L.LatLng ||\r\n\t\t\t\t\ttypeof layer[0][0] === \"number\" ||\r\n\t\t\t\t\ttypeof layer[0].lat === \"number\"\r\n\t\t\t\t) {\r\n\t\t\t\t\t// we could have a latlng as [x,y] with x & y numbers or {lat, lng}\r\n\t\t\t\t\tlayer = L.polyline(layer);\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn result;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// if we don't have here a Polyline, that means layer is incorrect\r\n\t\t\t// see https://github.com/makinacorpus/Leaflet.GeometryUtil/issues/23\r\n\t\t\tif (!(layer instanceof L.Polyline)) return result;\r\n\r\n\t\t\t// deep copy of latlngs\r\n\t\t\tlatlngs = JSON.parse(JSON.stringify(layer.getLatLngs().slice(0)));\r\n\r\n\t\t\t// add the last segment for L.Polygon\r\n\t\t\tif (layer instanceof L.Polygon) {\r\n\t\t\t\t// add the last segment for each child that is a nested array\r\n\t\t\t\tvar addLastSegment = function (latlngs) {\r\n\t\t\t\t\tif (L.Polyline._flat(latlngs)) {\r\n\t\t\t\t\t\tlatlngs.push(latlngs[0]);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tfor (var i = 0; i < latlngs.length; i++) {\r\n\t\t\t\t\t\t\taddLastSegment(latlngs[i]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\t\t\t\taddLastSegment(latlngs);\r\n\t\t\t}\r\n\r\n\t\t\t// we have a multi polygon / multi polyline / polygon with holes\r\n\t\t\t// use recursive to explore and return the good result\r\n\t\t\tif (!L.Polyline._flat(latlngs)) {\r\n\t\t\t\tfor (i = 0; i < latlngs.length; i++) {\r\n\t\t\t\t\t// if we are at the lower level, and if we have a L.Polygon, we add the last segment\r\n\t\t\t\t\tsubResult = L.GeometryUtil.closest(map, latlngs[i], latlng, vertices);\r\n\t\t\t\t\tif (subResult.distance < mindist) {\r\n\t\t\t\t\t\tmindist = subResult.distance;\r\n\t\t\t\t\t\tresult = subResult;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn result;\r\n\t\t\t} else {\r\n\t\t\t\t// Lookup vertices\r\n\t\t\t\tif (vertices) {\r\n\t\t\t\t\tfor (i = 0, n = latlngs.length; i < n; i++) {\r\n\t\t\t\t\t\tvar ll = latlngs[i];\r\n\t\t\t\t\t\tdistance = L.GeometryUtil.distance(map, latlng, ll);\r\n\t\t\t\t\t\tif (distance < mindist) {\r\n\t\t\t\t\t\t\tmindist = distance;\r\n\t\t\t\t\t\t\tresult = ll;\r\n\t\t\t\t\t\t\tresult.distance = distance;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn result;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Keep the closest point of all segments\r\n\t\t\t\tfor (i = 0, n = latlngs.length; i < n - 1; i++) {\r\n\t\t\t\t\tvar latlngA = latlngs[i],\r\n\t\t\t\t\t\tlatlngB = latlngs[i + 1];\r\n\t\t\t\t\tdistance = L.GeometryUtil.distanceSegment(\r\n\t\t\t\t\t\tmap,\r\n\t\t\t\t\t\tlatlng,\r\n\t\t\t\t\t\tlatlngA,\r\n\t\t\t\t\t\tlatlngB\r\n\t\t\t\t\t);\r\n\t\t\t\t\tif (distance <= mindist) {\r\n\t\t\t\t\t\tmindist = distance;\r\n\t\t\t\t\t\tresult = L.GeometryUtil.closestOnSegment(\r\n\t\t\t\t\t\t\tmap,\r\n\t\t\t\t\t\t\tlatlng,\r\n\t\t\t\t\t\t\tlatlngA,\r\n\t\t\t\t\t\t\tlatlngB\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t\tresult.distance = distance;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn result;\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/**\r\n        Returns the closest layer to latlng among a list of layers.\r\n\r\n        @tutorial closest\r\n\r\n        @param {L.Map} map Leaflet map to be used for this method\r\n        @param {Array<L.ILayer>} layers Set of layers\r\n        @param {L.LatLng} latlng - The position to search\r\n        @returns {object} ``{layer, latlng, distance}`` or ``null`` if list is empty;\r\n    */\r\n\t\tclosestLayer: function (map, layers, latlng) {\r\n\t\t\tvar mindist = Infinity,\r\n\t\t\t\tresult = null,\r\n\t\t\t\tll = null,\r\n\t\t\t\tdistance = Infinity;\r\n\r\n\t\t\tfor (var i = 0, n = layers.length; i < n; i++) {\r\n\t\t\t\tvar layer = layers[i];\r\n\t\t\t\tif (layer instanceof L.LayerGroup) {\r\n\t\t\t\t\t// recursive\r\n\t\t\t\t\tvar subResult = L.GeometryUtil.closestLayer(\r\n\t\t\t\t\t\tmap,\r\n\t\t\t\t\t\tlayer.getLayers(),\r\n\t\t\t\t\t\tlatlng\r\n\t\t\t\t\t);\r\n\t\t\t\t\tif (subResult.distance < mindist) {\r\n\t\t\t\t\t\tmindist = subResult.distance;\r\n\t\t\t\t\t\tresult = subResult;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// Single dimension, snap on points, else snap on closest\r\n\t\t\t\t\tif (typeof layer.getLatLng == \"function\") {\r\n\t\t\t\t\t\tll = layer.getLatLng();\r\n\t\t\t\t\t\tdistance = L.GeometryUtil.distance(map, latlng, ll);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tll = L.GeometryUtil.closest(map, layer, latlng);\r\n\t\t\t\t\t\tif (ll) distance = ll.distance; // Can return null if layer has no points.\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (distance < mindist) {\r\n\t\t\t\t\t\tmindist = distance;\r\n\t\t\t\t\t\tresult = { layer: layer, latlng: ll, distance: distance };\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn result;\r\n\t\t},\r\n\r\n\t\t/**\r\n        Returns the n closest layers to latlng among a list of input layers.\r\n\r\n        @param {L.Map} map - Leaflet map to be used for this method\r\n        @param {Array<L.ILayer>} layers - Set of layers\r\n        @param {L.LatLng} latlng - The position to search\r\n        @param {?Number} [n=layers.length] - the expected number of output layers.\r\n        @returns {Array<object>} an array of objects ``{layer, latlng, distance}`` or ``null`` if the input is invalid (empty list or negative n)\r\n    */\r\n\t\tnClosestLayers: function (map, layers, latlng, n) {\r\n\t\t\tn = typeof n === \"number\" ? n : layers.length;\r\n\r\n\t\t\tif (n < 1 || layers.length < 1) {\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\r\n\t\t\tvar results = [];\r\n\t\t\tvar distance, ll;\r\n\r\n\t\t\tfor (var i = 0, m = layers.length; i < m; i++) {\r\n\t\t\t\tvar layer = layers[i];\r\n\t\t\t\tif (layer instanceof L.LayerGroup) {\r\n\t\t\t\t\t// recursive\r\n\t\t\t\t\tvar subResult = L.GeometryUtil.closestLayer(\r\n\t\t\t\t\t\tmap,\r\n\t\t\t\t\t\tlayer.getLayers(),\r\n\t\t\t\t\t\tlatlng\r\n\t\t\t\t\t);\r\n\t\t\t\t\tresults.push(subResult);\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// Single dimension, snap on points, else snap on closest\r\n\t\t\t\t\tif (typeof layer.getLatLng == \"function\") {\r\n\t\t\t\t\t\tll = layer.getLatLng();\r\n\t\t\t\t\t\tdistance = L.GeometryUtil.distance(map, latlng, ll);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tll = L.GeometryUtil.closest(map, layer, latlng);\r\n\t\t\t\t\t\tif (ll) distance = ll.distance; // Can return null if layer has no points.\r\n\t\t\t\t\t}\r\n\t\t\t\t\tresults.push({ layer: layer, latlng: ll, distance: distance });\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tresults.sort(function (a, b) {\r\n\t\t\t\treturn a.distance - b.distance;\r\n\t\t\t});\r\n\r\n\t\t\tif (results.length > n) {\r\n\t\t\t\treturn results.slice(0, n);\r\n\t\t\t} else {\r\n\t\t\t\treturn results;\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/**\r\n     * Returns all layers within a radius of the given position, in an ascending order of distance.\r\n       @param {L.Map} map Leaflet map to be used for this method\r\n       @param {Array<ILayer>} layers - A list of layers.\r\n       @param {L.LatLng} latlng - The position to search\r\n       @param {?Number} [radius=Infinity] - Search radius in pixels\r\n       @return {object[]} an array of objects including layer within the radius, closest latlng, and distance\r\n     */\r\n\t\tlayersWithin: function (map, layers, latlng, radius) {\r\n\t\t\tradius = typeof radius == \"number\" ? radius : Infinity;\r\n\r\n\t\t\tvar results = [];\r\n\t\t\tvar ll = null;\r\n\t\t\tvar distance = 0;\r\n\r\n\t\t\tfor (var i = 0, n = layers.length; i < n; i++) {\r\n\t\t\t\tvar layer = layers[i];\r\n\r\n\t\t\t\tif (typeof layer.getLatLng == \"function\") {\r\n\t\t\t\t\tll = layer.getLatLng();\r\n\t\t\t\t\tdistance = L.GeometryUtil.distance(map, latlng, ll);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tll = L.GeometryUtil.closest(map, layer, latlng);\r\n\t\t\t\t\tif (ll) distance = ll.distance; // Can return null if layer has no points.\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (ll && distance < radius) {\r\n\t\t\t\t\tresults.push({ layer: layer, latlng: ll, distance: distance });\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tvar sortedResults = results.sort(function (a, b) {\r\n\t\t\t\treturn a.distance - b.distance;\r\n\t\t\t});\r\n\r\n\t\t\treturn sortedResults;\r\n\t\t},\r\n\r\n\t\t/**\r\n        Returns the closest position from specified {LatLng} among specified layers,\r\n        with a maximum tolerance in pixels, providing snapping behaviour.\r\n\r\n        @tutorial closest\r\n\r\n        @param {L.Map} map Leaflet map to be used for this method\r\n        @param {Array<ILayer>} layers - A list of layers to snap on.\r\n        @param {L.LatLng} latlng - The position to snap\r\n        @param {?Number} [tolerance=Infinity] - Maximum number of pixels.\r\n        @param {?boolean} [withVertices=true] - Snap to layers vertices or segment points (not only vertex)\r\n        @returns {object} with snapped {LatLng} and snapped {Layer} or null if tolerance exceeded.\r\n    */\r\n\t\tclosestLayerSnap: function (map, layers, latlng, tolerance, withVertices) {\r\n\t\t\ttolerance = typeof tolerance == \"number\" ? tolerance : Infinity;\r\n\t\t\twithVertices = typeof withVertices == \"boolean\" ? withVertices : true;\r\n\r\n\t\t\tvar result = L.GeometryUtil.closestLayer(map, layers, latlng);\r\n\t\t\tif (!result || result.distance > tolerance) return null;\r\n\r\n\t\t\t// If snapped layer is linear, try to snap on vertices (extremities and middle points)\r\n\t\t\tif (withVertices && typeof result.layer.getLatLngs == \"function\") {\r\n\t\t\t\tvar closest = L.GeometryUtil.closest(\r\n\t\t\t\t\tmap,\r\n\t\t\t\t\tresult.layer,\r\n\t\t\t\t\tresult.latlng,\r\n\t\t\t\t\ttrue\r\n\t\t\t\t);\r\n\t\t\t\tif (closest.distance < tolerance) {\r\n\t\t\t\t\tresult.latlng = closest;\r\n\t\t\t\t\tresult.distance = L.GeometryUtil.distance(map, closest, latlng);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn result;\r\n\t\t},\r\n\r\n\t\t/**\r\n        Returns the Point located on a segment at the specified ratio of the segment length.\r\n        @param {L.Point} pA coordinates of point A\r\n        @param {L.Point} pB coordinates of point B\r\n        @param {Number} the length ratio, expressed as a decimal between 0 and 1, inclusive.\r\n        @returns {L.Point} the interpolated point.\r\n    */\r\n\t\tinterpolateOnPointSegment: function (pA, pB, ratio) {\r\n\t\t\treturn L.point(\r\n\t\t\t\tpA.x * (1 - ratio) + ratio * pB.x,\r\n\t\t\t\tpA.y * (1 - ratio) + ratio * pB.y\r\n\t\t\t);\r\n\t\t},\r\n\r\n\t\t/**\r\n        Returns the coordinate of the point located on a line at the specified ratio of the line length.\r\n        @param {L.Map} map Leaflet map to be used for this method\r\n        @param {Array<L.LatLng>|L.PolyLine} latlngs Set of geographical points\r\n        @param {Number} ratio the length ratio, expressed as a decimal between 0 and 1, inclusive\r\n        @returns {Object} an object with latLng ({LatLng}) and predecessor ({Number}), the index of the preceding vertex in the Polyline\r\n        (-1 if the interpolated point is the first vertex)\r\n    */\r\n\t\tinterpolateOnLine: function (map, latLngs, ratio) {\r\n\t\t\tlatLngs = latLngs instanceof L.Polyline ? latLngs.getLatLngs() : latLngs;\r\n\t\t\tvar n = latLngs.length;\r\n\t\t\tif (n < 2) {\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\r\n\t\t\t// ensure the ratio is between 0 and 1;\r\n\t\t\tratio = Math.max(Math.min(ratio, 1), 0);\r\n\r\n\t\t\tif (ratio === 0) {\r\n\t\t\t\treturn {\r\n\t\t\t\t\tlatLng:\r\n\t\t\t\t\t\tlatLngs[0] instanceof L.LatLng ? latLngs[0] : L.latLng(latLngs[0]),\r\n\t\t\t\t\tpredecessor: -1,\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t\tif (ratio == 1) {\r\n\t\t\t\treturn {\r\n\t\t\t\t\tlatLng:\r\n\t\t\t\t\t\tlatLngs[latLngs.length - 1] instanceof L.LatLng\r\n\t\t\t\t\t\t\t? latLngs[latLngs.length - 1]\r\n\t\t\t\t\t\t\t: L.latLng(latLngs[latLngs.length - 1]),\r\n\t\t\t\t\tpredecessor: latLngs.length - 2,\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\t// project the LatLngs as Points,\r\n\t\t\t// and compute total planar length of the line at max precision\r\n\t\t\tvar maxzoom = map.getMaxZoom();\r\n\t\t\tif (maxzoom === Infinity) maxzoom = map.getZoom();\r\n\t\t\tvar pts = [];\r\n\t\t\tvar lineLength = 0;\r\n\t\t\tfor (var i = 0; i < n; i++) {\r\n\t\t\t\tpts[i] = map.project(latLngs[i], maxzoom);\r\n\t\t\t\tif (i > 0) lineLength += pts[i - 1].distanceTo(pts[i]);\r\n\t\t\t}\r\n\r\n\t\t\tvar ratioDist = lineLength * ratio;\r\n\r\n\t\t\t// follow the line segments [ab], adding lengths,\r\n\t\t\t// until we find the segment where the points should lie on\r\n\t\t\tvar cumulativeDistanceToA = 0,\r\n\t\t\t\tcumulativeDistanceToB = 0;\r\n\t\t\tfor (var i = 0; cumulativeDistanceToB < ratioDist; i++) {\r\n\t\t\t\tvar pointA = pts[i],\r\n\t\t\t\t\tpointB = pts[i + 1];\r\n\r\n\t\t\t\tcumulativeDistanceToA = cumulativeDistanceToB;\r\n\t\t\t\tcumulativeDistanceToB += pointA.distanceTo(pointB);\r\n\t\t\t}\r\n\r\n\t\t\tif (pointA == undefined && pointB == undefined) {\r\n\t\t\t\t// Happens when line has no length\r\n\t\t\t\tvar pointA = pts[0],\r\n\t\t\t\t\tpointB = pts[1],\r\n\t\t\t\t\ti = 1;\r\n\t\t\t}\r\n\r\n\t\t\t// compute the ratio relative to the segment [ab]\r\n\t\t\tvar segmentRatio =\r\n\t\t\t\tcumulativeDistanceToB - cumulativeDistanceToA !== 0\r\n\t\t\t\t\t? (ratioDist - cumulativeDistanceToA) /\r\n\t\t\t\t\t  (cumulativeDistanceToB - cumulativeDistanceToA)\r\n\t\t\t\t\t: 0;\r\n\t\t\tvar interpolatedPoint = L.GeometryUtil.interpolateOnPointSegment(\r\n\t\t\t\tpointA,\r\n\t\t\t\tpointB,\r\n\t\t\t\tsegmentRatio\r\n\t\t\t);\r\n\t\t\treturn {\r\n\t\t\t\tlatLng: map.unproject(interpolatedPoint, maxzoom),\r\n\t\t\t\tpredecessor: i - 1,\r\n\t\t\t};\r\n\t\t},\r\n\r\n\t\t/**\r\n        Returns a float between 0 and 1 representing the location of the\r\n        closest point on polyline to the given latlng, as a fraction of total line length.\r\n        (opposite of L.GeometryUtil.interpolateOnLine())\r\n        @param {L.Map} map Leaflet map to be used for this method\r\n        @param {L.PolyLine} polyline Polyline on which the latlng will be search\r\n        @param {L.LatLng} latlng The position to search\r\n        @returns {Number} Float between 0 and 1\r\n    */\r\n\t\tlocateOnLine: function (map, polyline, latlng) {\r\n\t\t\tvar latlngs = polyline.getLatLngs();\r\n\t\t\tif (latlng.equals(latlngs[0])) return 0.0;\r\n\t\t\tif (latlng.equals(latlngs[latlngs.length - 1])) return 1.0;\r\n\r\n\t\t\tvar point = L.GeometryUtil.closest(map, polyline, latlng, false),\r\n\t\t\t\tlengths = L.GeometryUtil.accumulatedLengths(latlngs),\r\n\t\t\t\ttotal_length = lengths[lengths.length - 1],\r\n\t\t\t\tportion = 0,\r\n\t\t\t\tfound = false;\r\n\t\t\tfor (var i = 0, n = latlngs.length - 1; i < n; i++) {\r\n\t\t\t\tvar l1 = latlngs[i],\r\n\t\t\t\t\tl2 = latlngs[i + 1];\r\n\t\t\t\tportion = lengths[i];\r\n\t\t\t\tif (L.GeometryUtil.belongsSegment(point, l1, l2, 0.001)) {\r\n\t\t\t\t\tportion += l1.distanceTo(point);\r\n\t\t\t\t\tfound = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (!found) {\r\n\t\t\t\tthrow (\r\n\t\t\t\t\t\"Could not interpolate \" +\r\n\t\t\t\t\tlatlng.toString() +\r\n\t\t\t\t\t\" within \" +\r\n\t\t\t\t\tpolyline.toString()\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t\treturn portion / total_length;\r\n\t\t},\r\n\r\n\t\t/**\r\n        Returns a clone with reversed coordinates.\r\n        @param {L.PolyLine} polyline polyline to reverse\r\n        @returns {L.PolyLine} polyline reversed\r\n    */\r\n\t\treverse: function (polyline) {\r\n\t\t\treturn L.polyline(polyline.getLatLngs().slice(0).reverse());\r\n\t\t},\r\n\r\n\t\t/**\r\n        Returns a sub-part of the polyline, from start to end.\r\n        If start is superior to end, returns extraction from inverted line.\r\n        @param {L.Map} map Leaflet map to be used for this method\r\n        @param {L.PolyLine} polyline Polyline on which will be extracted the sub-part\r\n        @param {Number} start ratio, expressed as a decimal between 0 and 1, inclusive\r\n        @param {Number} end ratio, expressed as a decimal between 0 and 1, inclusive\r\n        @returns {Array<L.LatLng>} new polyline\r\n     */\r\n\t\textract: function (map, polyline, start, end) {\r\n\t\t\tif (start > end) {\r\n\t\t\t\treturn L.GeometryUtil.extract(\r\n\t\t\t\t\tmap,\r\n\t\t\t\t\tL.GeometryUtil.reverse(polyline),\r\n\t\t\t\t\t1.0 - start,\r\n\t\t\t\t\t1.0 - end\r\n\t\t\t\t);\r\n\t\t\t}\r\n\r\n\t\t\t// Bound start and end to [0-1]\r\n\t\t\tstart = Math.max(Math.min(start, 1), 0);\r\n\t\t\tend = Math.max(Math.min(end, 1), 0);\r\n\r\n\t\t\tvar latlngs = polyline.getLatLngs(),\r\n\t\t\t\tstartpoint = L.GeometryUtil.interpolateOnLine(map, polyline, start),\r\n\t\t\t\tendpoint = L.GeometryUtil.interpolateOnLine(map, polyline, end);\r\n\t\t\t// Return single point if start == end\r\n\t\t\tif (start == end) {\r\n\t\t\t\tvar point = L.GeometryUtil.interpolateOnLine(map, polyline, end);\r\n\t\t\t\treturn [point.latLng];\r\n\t\t\t}\r\n\t\t\t// Array.slice() works indexes at 0\r\n\t\t\tif (startpoint.predecessor == -1) startpoint.predecessor = 0;\r\n\t\t\tif (endpoint.predecessor == -1) endpoint.predecessor = 0;\r\n\t\t\tvar result = latlngs.slice(\r\n\t\t\t\tstartpoint.predecessor + 1,\r\n\t\t\t\tendpoint.predecessor + 1\r\n\t\t\t);\r\n\t\t\tresult.unshift(startpoint.latLng);\r\n\t\t\tresult.push(endpoint.latLng);\r\n\t\t\treturn result;\r\n\t\t},\r\n\r\n\t\t/**\r\n        Returns true if first polyline ends where other second starts.\r\n        @param {L.PolyLine} polyline First polyline\r\n        @param {L.PolyLine} other Second polyline\r\n        @returns {bool}\r\n    */\r\n\t\tisBefore: function (polyline, other) {\r\n\t\t\tif (!other) return false;\r\n\t\t\tvar lla = polyline.getLatLngs(),\r\n\t\t\t\tllb = other.getLatLngs();\r\n\t\t\treturn lla[lla.length - 1].equals(llb[0]);\r\n\t\t},\r\n\r\n\t\t/**\r\n        Returns true if first polyline starts where second ends.\r\n        @param {L.PolyLine} polyline First polyline\r\n        @param {L.PolyLine} other Second polyline\r\n        @returns {bool}\r\n    */\r\n\t\tisAfter: function (polyline, other) {\r\n\t\t\tif (!other) return false;\r\n\t\t\tvar lla = polyline.getLatLngs(),\r\n\t\t\t\tllb = other.getLatLngs();\r\n\t\t\treturn lla[0].equals(llb[llb.length - 1]);\r\n\t\t},\r\n\r\n\t\t/**\r\n        Returns true if first polyline starts where second ends or start.\r\n        @param {L.PolyLine} polyline First polyline\r\n        @param {L.PolyLine} other Second polyline\r\n        @returns {bool}\r\n    */\r\n\t\tstartsAtExtremity: function (polyline, other) {\r\n\t\t\tif (!other) return false;\r\n\t\t\tvar lla = polyline.getLatLngs(),\r\n\t\t\t\tllb = other.getLatLngs(),\r\n\t\t\t\tstart = lla[0];\r\n\t\t\treturn start.equals(llb[0]) || start.equals(llb[llb.length - 1]);\r\n\t\t},\r\n\r\n\t\t/**\r\n        Returns horizontal angle in degres between two points.\r\n        @param {L.Point} a Coordinates of point A\r\n        @param {L.Point} b Coordinates of point B\r\n        @returns {Number} horizontal angle\r\n     */\r\n\t\tcomputeAngle: function (a, b) {\r\n\t\t\treturn (Math.atan2(b.y - a.y, b.x - a.x) * 180) / Math.PI;\r\n\t\t},\r\n\r\n\t\t/**\r\n       Returns slope (Ax+B) between two points.\r\n        @param {L.Point} a Coordinates of point A\r\n        @param {L.Point} b Coordinates of point B\r\n        @returns {Object} with ``a`` and ``b`` properties.\r\n     */\r\n\t\tcomputeSlope: function (a, b) {\r\n\t\t\tvar s = (b.y - a.y) / (b.x - a.x),\r\n\t\t\t\to = a.y - s * a.x;\r\n\t\t\treturn { a: s, b: o };\r\n\t\t},\r\n\r\n\t\t/**\r\n       Returns LatLng of rotated point around specified LatLng center.\r\n        @param {L.LatLng} latlngPoint: point to rotate\r\n        @param {double} angleDeg: angle to rotate in degrees\r\n        @param {L.LatLng} latlngCenter: center of rotation\r\n        @returns {L.LatLng} rotated point\r\n     */\r\n\t\trotatePoint: function (map, latlngPoint, angleDeg, latlngCenter) {\r\n\t\t\tvar maxzoom = map.getMaxZoom();\r\n\t\t\tif (maxzoom === Infinity) maxzoom = map.getZoom();\r\n\t\t\tvar angleRad = (angleDeg * Math.PI) / 180,\r\n\t\t\t\tpPoint = map.project(latlngPoint, maxzoom),\r\n\t\t\t\tpCenter = map.project(latlngCenter, maxzoom),\r\n\t\t\t\tx2 =\r\n\t\t\t\t\tMath.cos(angleRad) * (pPoint.x - pCenter.x) -\r\n\t\t\t\t\tMath.sin(angleRad) * (pPoint.y - pCenter.y) +\r\n\t\t\t\t\tpCenter.x,\r\n\t\t\t\ty2 =\r\n\t\t\t\t\tMath.sin(angleRad) * (pPoint.x - pCenter.x) +\r\n\t\t\t\t\tMath.cos(angleRad) * (pPoint.y - pCenter.y) +\r\n\t\t\t\t\tpCenter.y;\r\n\t\t\treturn map.unproject(new L.Point(x2, y2), maxzoom);\r\n\t\t},\r\n\r\n\t\t/**\r\n       Returns the bearing in degrees clockwise from north (0 degrees)\r\n       from the first L.LatLng to the second, at the first LatLng\r\n       @param {L.LatLng} latlng1: origin point of the bearing\r\n       @param {L.LatLng} latlng2: destination point of the bearing\r\n       @returns {float} degrees clockwise from north.\r\n    */\r\n\t\tbearing: function (latlng1, latlng2) {\r\n\t\t\tvar rad = Math.PI / 180,\r\n\t\t\t\tlat1 = latlng1.lat * rad,\r\n\t\t\t\tlat2 = latlng2.lat * rad,\r\n\t\t\t\tlon1 = latlng1.lng * rad,\r\n\t\t\t\tlon2 = latlng2.lng * rad,\r\n\t\t\t\ty = Math.sin(lon2 - lon1) * Math.cos(lat2),\r\n\t\t\t\tx =\r\n\t\t\t\t\tMath.cos(lat1) * Math.sin(lat2) -\r\n\t\t\t\t\tMath.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);\r\n\r\n\t\t\tvar bearing = ((Math.atan2(y, x) * 180) / Math.PI + 360) % 360;\r\n\t\t\treturn bearing >= 180 ? bearing - 360 : bearing;\r\n\t\t},\r\n\r\n\t\t/**\r\n       Returns the point that is a distance and heading away from\r\n       the given origin point.\r\n       @param {L.LatLng} latlng: origin point\r\n       @param {float} heading: heading in degrees, clockwise from 0 degrees north.\r\n       @param {float} distance: distance in meters\r\n       @returns {L.latLng} the destination point.\r\n       Many thanks to Chris Veness at http://www.movable-type.co.uk/scripts/latlong.html\r\n       for a great reference and examples.\r\n    */\r\n\t\tdestination: function (latlng, heading, distance) {\r\n\t\t\theading = (heading + 360) % 360;\r\n\t\t\tvar rad = Math.PI / 180,\r\n\t\t\t\tradInv = 180 / Math.PI,\r\n\t\t\t\tR = 6378137, // approximation of Earth's radius\r\n\t\t\t\tlon1 = latlng.lng * rad,\r\n\t\t\t\tlat1 = latlng.lat * rad,\r\n\t\t\t\trheading = heading * rad,\r\n\t\t\t\tsinLat1 = Math.sin(lat1),\r\n\t\t\t\tcosLat1 = Math.cos(lat1),\r\n\t\t\t\tcosDistR = Math.cos(distance / R),\r\n\t\t\t\tsinDistR = Math.sin(distance / R),\r\n\t\t\t\tlat2 = Math.asin(\r\n\t\t\t\t\tsinLat1 * cosDistR + cosLat1 * sinDistR * Math.cos(rheading)\r\n\t\t\t\t),\r\n\t\t\t\tlon2 =\r\n\t\t\t\t\tlon1 +\r\n\t\t\t\t\tMath.atan2(\r\n\t\t\t\t\t\tMath.sin(rheading) * sinDistR * cosLat1,\r\n\t\t\t\t\t\tcosDistR - sinLat1 * Math.sin(lat2)\r\n\t\t\t\t\t);\r\n\t\t\tlon2 = lon2 * radInv;\r\n\t\t\tlon2 = lon2 > 180 ? lon2 - 360 : lon2 < -180 ? lon2 + 360 : lon2;\r\n\t\t\treturn L.latLng([lat2 * radInv, lon2]);\r\n\t\t},\r\n\r\n\t\t/**\r\n       Returns the the angle of the given segment and the Equator in degrees,\r\n       clockwise from 0 degrees north.\r\n       @param {L.Map} map: Leaflet map to be used for this method\r\n       @param {L.LatLng} latlngA: geographical point A of the segment\r\n       @param {L.LatLng} latlngB: geographical point B of the segment\r\n       @returns {Float} the angle in degrees.\r\n    */\r\n\t\tangle: function (map, latlngA, latlngB) {\r\n\t\t\tvar pointA = map.latLngToContainerPoint(latlngA),\r\n\t\t\t\tpointB = map.latLngToContainerPoint(latlngB),\r\n\t\t\t\tangleDeg =\r\n\t\t\t\t\t(Math.atan2(pointB.y - pointA.y, pointB.x - pointA.x) * 180) /\r\n\t\t\t\t\t\tMath.PI +\r\n\t\t\t\t\t90;\r\n\t\t\tangleDeg += angleDeg < 0 ? 360 : 0;\r\n\t\t\treturn angleDeg;\r\n\t\t},\r\n\r\n\t\t/**\r\n       Returns a point snaps on the segment and heading away from the given origin point a distance.\r\n       @param {L.Map} map: Leaflet map to be used for this method\r\n       @param {L.LatLng} latlngA: geographical point A of the segment\r\n       @param {L.LatLng} latlngB: geographical point B of the segment\r\n       @param {float} distance: distance in meters\r\n       @returns {L.latLng} the destination point.\r\n    */\r\n\t\tdestinationOnSegment: function (map, latlngA, latlngB, distance) {\r\n\t\t\tvar angleDeg = L.GeometryUtil.angle(map, latlngA, latlngB),\r\n\t\t\t\tlatlng = L.GeometryUtil.destination(latlngA, angleDeg, distance);\r\n\t\t\treturn L.GeometryUtil.closestOnSegment(map, latlng, latlngA, latlngB);\r\n\t\t},\r\n\r\n\t\t// @method isVersion07x(): boolean\r\n\t\t// Returns true if the Leaflet version is 0.7.x, false otherwise.\r\n\t\tisVersion07x: function () {\r\n\t\t\tvar version = L.version.split(\".\");\r\n\t\t\t//If Version is == 0.7.*\r\n\t\t\treturn parseInt(version[0], 10) === 0 && parseInt(version[1], 10) === 7;\r\n\t\t},\r\n\t});\r\n\r\n\treturn L.GeometryUtil;\r\n});\r\n","/**\r\n * @class L.LineUtil\r\n * @aka Util\r\n * @aka L.Utils\r\n */\r\nL.Util.extend(L.LineUtil, {\r\n\r\n\t// @method segmentsIntersect(): boolean\r\n\t// Checks to see if two line segments intersect. Does not handle degenerate cases.\r\n\t// http://compgeom.cs.uiuc.edu/~jeffe/teaching/373/notes/x06-sweepline.pdf\r\n\tsegmentsIntersect: function (/*Point*/ p, /*Point*/ p1, /*Point*/ p2, /*Point*/ p3) {\r\n\t\treturn this._checkCounterclockwise(p, p2, p3) !==\r\n\t\t\tthis._checkCounterclockwise(p1, p2, p3) &&\r\n\t\t\tthis._checkCounterclockwise(p, p1, p2) !==\r\n\t\t\tthis._checkCounterclockwise(p, p1, p3);\r\n\t},\r\n\r\n\t// check to see if points are in counterclockwise order\r\n\t_checkCounterclockwise: function (/*Point*/ p, /*Point*/ p1, /*Point*/ p2) {\r\n\t\treturn (p2.y - p.y) * (p1.x - p.x) > (p1.y - p.y) * (p2.x - p.x);\r\n\t}\r\n});\r\n","/**\r\n * @class L.Polyline\r\n * @aka Polyline\r\n */\r\nL.Polyline.include({\r\n\r\n\t// @method intersects(): boolean\r\n\t// Check to see if this polyline has any linesegments that intersect.\r\n\t// NOTE: does not support detecting intersection for degenerate cases.\r\n\tintersects: function () {\r\n\t\tvar points = this._getProjectedPoints(),\r\n\t\t\tlen = points ? points.length : 0,\r\n\t\t\ti, p, p1;\r\n\r\n\t\tif (this._tooFewPointsForIntersection()) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tfor (i = len - 1; i >= 3; i--) {\r\n\t\t\tp = points[i - 1];\r\n\t\t\tp1 = points[i];\r\n\r\n\r\n\t\t\tif (this._lineSegmentsIntersectsRange(p, p1, i - 2)) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t},\r\n\r\n\t// @method newLatLngIntersects(): boolean\r\n\t// Check for intersection if new latlng was added to this polyline.\r\n\t// NOTE: does not support detecting intersection for degenerate cases.\r\n\tnewLatLngIntersects: function (latlng, skipFirst) {\r\n\t\t// Cannot check a polyline for intersecting lats/lngs when not added to the map\r\n\t\tif (!this._map) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\treturn this.newPointIntersects(this._map.latLngToLayerPoint(latlng), skipFirst);\r\n\t},\r\n\r\n\t// @method newPointIntersects(): boolean\r\n\t// Check for intersection if new point was added to this polyline.\r\n\t// newPoint must be a layer point.\r\n\t// NOTE: does not support detecting intersection for degenerate cases.\r\n\tnewPointIntersects: function (newPoint, skipFirst) {\r\n\t\tvar points = this._getProjectedPoints(),\r\n\t\t\tlen = points ? points.length : 0,\r\n\t\t\tlastPoint = points ? points[len - 1] : null,\r\n\t\t\t// The previous previous line segment. Previous line segment doesn't need testing.\r\n\t\t\tmaxIndex = len - 2;\r\n\r\n\t\tif (this._tooFewPointsForIntersection(1)) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\treturn this._lineSegmentsIntersectsRange(lastPoint, newPoint, maxIndex, skipFirst ? 1 : 0);\r\n\t},\r\n\r\n\t// Polylines with 2 sides can only intersect in cases where points are collinear (we don't support detecting these).\r\n\t// Cannot have intersection when < 3 line segments (< 4 points)\r\n\t_tooFewPointsForIntersection: function (extraPoints) {\r\n\t\tvar points = this._getProjectedPoints(),\r\n\t\t\tlen = points ? points.length : 0;\r\n\t\t// Increment length by extraPoints if present\r\n\t\tlen += extraPoints || 0;\r\n\r\n\t\treturn !points || len <= 3;\r\n\t},\r\n\r\n\t// Checks a line segment intersections with any line segments before its predecessor.\r\n\t// Don't need to check the predecessor as will never intersect.\r\n\t_lineSegmentsIntersectsRange: function (p, p1, maxIndex, minIndex) {\r\n\t\tvar points = this._getProjectedPoints(),\r\n\t\t\tp2, p3;\r\n\r\n\t\tminIndex = minIndex || 0;\r\n\r\n\t\t// Check all previous line segments (beside the immediately previous) for intersections\r\n\t\tfor (var j = maxIndex; j > minIndex; j--) {\r\n\t\t\tp2 = points[j - 1];\r\n\t\t\tp3 = points[j];\r\n\r\n\t\t\tif (L.LineUtil.segmentsIntersect(p, p1, p2, p3)) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t},\r\n\r\n\t_getProjectedPoints: function () {\r\n\t\tif (!this._defaultShape) {\r\n\t\t\treturn this._originalPoints;\r\n\t\t}\r\n\t\tvar points = [],\r\n\t\t\t_shape = this._defaultShape();\r\n\r\n\t\tfor (var i = 0; i < _shape.length; i++) {\r\n\t\t\tpoints.push(this._map.latLngToLayerPoint(_shape[i]));\r\n\t\t}\r\n\t\treturn points;\r\n\t}\r\n});\r\n","/**\r\n * @class L.Polygon\r\n * @aka Polygon\r\n */\r\nL.Polygon.include({\r\n\r\n\t// @method intersects(): boolean\r\n\t// Checks a polygon for any intersecting line segments. Ignores holes.\r\n\tintersects: function () {\r\n\t\tvar polylineIntersects,\r\n\t\t\tpoints = this._getProjectedPoints(),\r\n\t\t\tlen, firstPoint, lastPoint, maxIndex;\r\n\r\n\t\tif (this._tooFewPointsForIntersection()) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tpolylineIntersects = L.Polyline.prototype.intersects.call(this);\r\n\r\n\t\t// If already found an intersection don't need to check for any more.\r\n\t\tif (polylineIntersects) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\tlen = points.length;\r\n\t\tfirstPoint = points[0];\r\n\t\tlastPoint = points[len - 1];\r\n\t\tmaxIndex = len - 2;\r\n\r\n\t\t// Check the line segment between last and first point. Don't need to check the first line segment (minIndex = 1)\r\n\t\treturn this._lineSegmentsIntersectsRange(lastPoint, firstPoint, maxIndex, 1);\r\n\t}\r\n});\r\n","/**\r\n * @class L.Control.Draw\r\n * @aka L.Draw\r\n */\r\nL.Control.Draw = L.Control.extend({\r\n\t// Options\r\n\toptions: {\r\n\t\tposition: \"topleft\",\r\n\t\tdraw: {},\r\n\t\tedit: false,\r\n\t},\r\n\r\n\t// @method initialize(): void\r\n\t// Initializes draw control, toolbars from the options\r\n\tinitialize: function (options) {\r\n\t\tif (L.version < \"0.7\") {\r\n\t\t\tthrow new Error(\r\n\t\t\t\t\"Leaflet.draw 0.2.3+ requires Leaflet 0.7.0+. Download latest from https://github.com/Leaflet/Leaflet/\"\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\tL.Control.prototype.initialize.call(this, options);\r\n\r\n\t\tvar toolbar;\r\n\r\n\t\tthis._toolbars = {};\r\n\r\n\t\t// Initialize toolbars\r\n\t\tif (L.DrawToolbar && this.options.draw) {\r\n\t\t\ttoolbar = new L.DrawToolbar(this.options.draw);\r\n\r\n\t\t\tthis._toolbars[L.DrawToolbar.TYPE] = toolbar;\r\n\r\n\t\t\t// Listen for when toolbar is enabled\r\n\t\t\tthis._toolbars[L.DrawToolbar.TYPE].on(\r\n\t\t\t\t\"enable\",\r\n\t\t\t\tthis._toolbarEnabled,\r\n\t\t\t\tthis\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\tif (L.EditToolbar && this.options.edit) {\r\n\t\t\ttoolbar = new L.EditToolbar(this.options.edit);\r\n\r\n\t\t\tthis._toolbars[L.EditToolbar.TYPE] = toolbar;\r\n\r\n\t\t\t// Listen for when toolbar is enabled\r\n\t\t\tthis._toolbars[L.EditToolbar.TYPE].on(\r\n\t\t\t\t\"enable\",\r\n\t\t\t\tthis._toolbarEnabled,\r\n\t\t\t\tthis\r\n\t\t\t);\r\n\t\t}\r\n\t\tL.toolbar = this; //set global var for editing the toolbar\r\n\t},\r\n\r\n\t// @method onAdd(): container\r\n\t// Adds the toolbar container to the map\r\n\tonAdd: function (map) {\r\n\t\tvar container = L.DomUtil.create(\"div\", \"leaflet-draw\"),\r\n\t\t\taddedTopClass = false,\r\n\t\t\ttopClassName = \"leaflet-draw-toolbar-top\",\r\n\t\t\ttoolbarContainer;\r\n\r\n\t\tfor (var toolbarId in this._toolbars) {\r\n\t\t\tif (this._toolbars.hasOwnProperty(toolbarId)) {\r\n\t\t\t\ttoolbarContainer = this._toolbars[toolbarId].addToolbar(map);\r\n\r\n\t\t\t\tif (toolbarContainer) {\r\n\t\t\t\t\t// Add class to the first toolbar to remove the margin\r\n\t\t\t\t\tif (!addedTopClass) {\r\n\t\t\t\t\t\tif (!L.DomUtil.hasClass(toolbarContainer, topClassName)) {\r\n\t\t\t\t\t\t\tL.DomUtil.addClass(toolbarContainer.childNodes[0], topClassName);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\taddedTopClass = true;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tcontainer.appendChild(toolbarContainer);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn container;\r\n\t},\r\n\r\n\t// @method onRemove(): void\r\n\t// Removes the toolbars from the map toolbar container\r\n\tonRemove: function () {\r\n\t\tfor (var toolbarId in this._toolbars) {\r\n\t\t\tif (this._toolbars.hasOwnProperty(toolbarId)) {\r\n\t\t\t\tthis._toolbars[toolbarId].removeToolbar();\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t// @method setDrawingOptions(options): void\r\n\t// Sets options to all toolbar instances\r\n\tsetDrawingOptions: function (options) {\r\n\t\tfor (var toolbarId in this._toolbars) {\r\n\t\t\tif (this._toolbars[toolbarId] instanceof L.DrawToolbar) {\r\n\t\t\t\tthis._toolbars[toolbarId].setOptions(options);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_toolbarEnabled: function (e) {\r\n\t\tvar enabledToolbar = e.target;\r\n\r\n\t\tfor (var toolbarId in this._toolbars) {\r\n\t\t\tif (this._toolbars[toolbarId] !== enabledToolbar) {\r\n\t\t\t\tthis._toolbars[toolbarId].disable();\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n});\r\n\r\nL.Map.mergeOptions({\r\n\tdrawControlTooltips: true,\r\n\tdrawControl: false,\r\n});\r\n\r\nL.Map.addInitHook(function () {\r\n\tif (this.options.drawControl) {\r\n\t\tthis.drawControl = new L.Control.Draw();\r\n\t\tthis.addControl(this.drawControl);\r\n\t}\r\n});\r\n","/**\r\n * @class L.Draw.Toolbar\r\n * @aka Toolbar\r\n *\r\n * The toolbar class of the API — it is used to create the ui\r\n * This will be depreciated\r\n *\r\n * @example\r\n *\r\n * ```js\r\n *    var toolbar = L.Toolbar();\r\n *    toolbar.addToolbar(map);\r\n * ```\r\n *\r\n * ### Disabling a toolbar\r\n *\r\n * If you do not want a particular toolbar in your app you can turn it off by setting the toolbar to false.\r\n *\r\n * ```js\r\n *      var drawControl = new L.Control.Draw({\r\n *          draw: false,\r\n *          edit: {\r\n *              featureGroup: editableLayers\r\n *          }\r\n *      });\r\n * ```\r\n *\r\n * ### Disabling a toolbar item\r\n *\r\n * If you want to turn off a particular toolbar item, set it to false. The following disables drawing polygons and\r\n * markers. It also turns off the ability to edit layers.\r\n *\r\n * ```js\r\n *      var drawControl = new L.Control.Draw({\r\n *          draw: {\r\n *              polygon: false,\r\n *              marker: false\r\n *          },\r\n *          edit: {\r\n *              featureGroup: editableLayers,\r\n *              edit: false\r\n *          }\r\n *      });\r\n * ```\r\n */\r\nL.Toolbar = L.Class.extend({\r\n\t// @section Methods for modifying the toolbar\r\n\r\n\t// @method initialize(options): void\r\n\t// Toolbar constructor\r\n\tinitialize: function (options) {\r\n\t\tL.setOptions(this, options);\r\n\r\n\t\tthis._modes = {};\r\n\t\tthis._actionButtons = [];\r\n\t\tthis._activeMode = null;\r\n\r\n\t\tvar version = L.version.split(\".\");\r\n\t\t//If Version is >= 1.2.0\r\n\t\tif (parseInt(version[0], 10) === 1 && parseInt(version[1], 10) >= 2) {\r\n\t\t\tL.Toolbar.include(L.Evented.prototype);\r\n\t\t} else {\r\n\t\t\tL.Toolbar.include(L.Mixin.Events);\r\n\t\t}\r\n\t},\r\n\r\n\t// @method enabled(): boolean\r\n\t// Gets a true/false of whether the toolbar is enabled\r\n\tenabled: function () {\r\n\t\treturn this._activeMode !== null;\r\n\t},\r\n\r\n\t// @method disable(): void\r\n\t// Disables the toolbar\r\n\tdisable: function () {\r\n\t\tif (!this.enabled()) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis._activeMode.handler.disable();\r\n\t},\r\n\r\n\t// @method addToolbar(map): L.DomUtil\r\n\t// Adds the toolbar to the map and returns the toolbar dom element\r\n\taddToolbar: function (map) {\r\n\t\tvar container = L.DomUtil.create(\"div\", \"leaflet-draw-section\"),\r\n\t\t\tbuttonIndex = 0,\r\n\t\t\tbuttonClassPrefix = this._toolbarClass || \"\",\r\n\t\t\tmodeHandlers = this.getModeHandlers(map),\r\n\t\t\ti;\r\n\r\n\t\tthis._toolbarContainer = L.DomUtil.create(\r\n\t\t\t\"div\",\r\n\t\t\t\"leaflet-draw-toolbar leaflet-bar\"\r\n\t\t);\r\n\t\tthis._map = map;\r\n\r\n\t\tfor (i = 0; i < modeHandlers.length; i++) {\r\n\t\t\tif (modeHandlers[i].enabled) {\r\n\t\t\t\tthis._initModeHandler(\r\n\t\t\t\t\tmodeHandlers[i].handler,\r\n\t\t\t\t\tthis._toolbarContainer,\r\n\t\t\t\t\tbuttonIndex++,\r\n\t\t\t\t\tbuttonClassPrefix,\r\n\t\t\t\t\tmodeHandlers[i].title\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// if no buttons were added, do not add the toolbar\r\n\t\tif (!buttonIndex) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Save button index of the last button, -1 as we would have ++ after the last button\r\n\t\tthis._lastButtonIndex = --buttonIndex;\r\n\r\n\t\t// Create empty actions part of the toolbar\r\n\t\tthis._actionsContainer = L.DomUtil.create(\"ul\", \"leaflet-draw-actions\");\r\n\r\n\t\t// Add draw and cancel containers to the control container\r\n\t\tcontainer.appendChild(this._toolbarContainer);\r\n\t\tcontainer.appendChild(this._actionsContainer);\r\n\r\n\t\treturn container;\r\n\t},\r\n\r\n\t// @method removeToolbar(): void\r\n\t// Removes the toolbar and drops the handler event listeners\r\n\tremoveToolbar: function () {\r\n\t\t// Dispose each handler\r\n\t\tfor (var handlerId in this._modes) {\r\n\t\t\tif (this._modes.hasOwnProperty(handlerId)) {\r\n\t\t\t\t// Unbind handler button\r\n\t\t\t\tthis._disposeButton(\r\n\t\t\t\t\tthis._modes[handlerId].button,\r\n\t\t\t\t\tthis._modes[handlerId].handler.enable,\r\n\t\t\t\t\tthis._modes[handlerId].handler\r\n\t\t\t\t);\r\n\r\n\t\t\t\t// Make sure is disabled\r\n\t\t\t\tthis._modes[handlerId].handler.disable();\r\n\r\n\t\t\t\t// Unbind handler\r\n\t\t\t\tthis._modes[handlerId].handler\r\n\t\t\t\t\t.off(\"enabled\", this._handlerActivated, this)\r\n\t\t\t\t\t.off(\"disabled\", this._handlerDeactivated, this);\r\n\t\t\t}\r\n\t\t}\r\n\t\tthis._modes = {};\r\n\r\n\t\t// Dispose the actions toolbar\r\n\t\tfor (var i = 0, l = this._actionButtons.length; i < l; i++) {\r\n\t\t\tthis._disposeButton(\r\n\t\t\t\tthis._actionButtons[i].button,\r\n\t\t\t\tthis._actionButtons[i].callback,\r\n\t\t\t\tthis\r\n\t\t\t);\r\n\t\t}\r\n\t\tthis._actionButtons = [];\r\n\t\tthis._actionsContainer = null;\r\n\t},\r\n\r\n\t_initModeHandler: function (\r\n\t\thandler,\r\n\t\tcontainer,\r\n\t\tbuttonIndex,\r\n\t\tclassNamePredix,\r\n\t\tbuttonTitle\r\n\t) {\r\n\t\tvar type = handler.type;\r\n\r\n\t\tthis._modes[type] = {};\r\n\r\n\t\tthis._modes[type].handler = handler;\r\n\r\n\t\tthis._modes[type].button = this._createButton({\r\n\t\t\ttype: type,\r\n\t\t\ttitle: buttonTitle,\r\n\t\t\tclassName: classNamePredix + \"-\" + type,\r\n\t\t\tcontainer: container,\r\n\t\t\tcallback: this._modes[type].handler.enable,\r\n\t\t\tcontext: this._modes[type].handler,\r\n\t\t});\r\n\r\n\t\tthis._modes[type].buttonIndex = buttonIndex;\r\n\r\n\t\tthis._modes[type].handler\r\n\t\t\t.on(\"enabled\", this._handlerActivated, this)\r\n\t\t\t.on(\"disabled\", this._handlerDeactivated, this);\r\n\t},\r\n\r\n\t/* Detect iOS based on browser User Agent, based on:\r\n\t * http://stackoverflow.com/a/9039885 */\r\n\t_detectIOS: function () {\r\n\t\tvar iOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\r\n\t\treturn iOS;\r\n\t},\r\n\r\n\t_createButton: function (options) {\r\n\t\tvar link = L.DomUtil.create(\r\n\t\t\t\"a\",\r\n\t\t\toptions.className || \"\",\r\n\t\t\toptions.container\r\n\t\t);\r\n\t\t// Screen reader tag\r\n\t\tvar sr = L.DomUtil.create(\"span\", \"sr-only\", options.container);\r\n\r\n\t\tlink.href = \"#\";\r\n\t\tlink.appendChild(sr);\r\n\r\n\t\tif (options.title) {\r\n\t\t\tlink.title = options.title;\r\n\t\t\tsr.innerHTML = options.title;\r\n\t\t}\r\n\r\n\t\tif (options.text) {\r\n\t\t\tlink.innerHTML = options.text;\r\n\t\t\tsr.innerHTML = options.text;\r\n\t\t}\r\n\r\n\t\t/* iOS does not use click events */\r\n\t\tvar buttonEvent = this._detectIOS() ? \"touchstart\" : \"click\";\r\n\r\n\t\tL.DomEvent.on(link, \"click\", L.DomEvent.stopPropagation)\r\n\t\t\t.on(link, \"mousedown\", L.DomEvent.stopPropagation)\r\n\t\t\t.on(link, \"dblclick\", L.DomEvent.stopPropagation)\r\n\t\t\t.on(link, \"touchstart\", L.DomEvent.stopPropagation)\r\n\t\t\t.on(link, \"click\", L.DomEvent.preventDefault)\r\n\t\t\t.on(link, buttonEvent, options.callback, options.context);\r\n\r\n\t\treturn link;\r\n\t},\r\n\r\n\t_disposeButton: function (button, callback) {\r\n\t\t/* iOS does not use click events */\r\n\t\tvar buttonEvent = this._detectIOS() ? \"touchstart\" : \"click\";\r\n\r\n\t\tL.DomEvent.off(button, \"click\", L.DomEvent.stopPropagation)\r\n\t\t\t.off(button, \"mousedown\", L.DomEvent.stopPropagation)\r\n\t\t\t.off(button, \"dblclick\", L.DomEvent.stopPropagation)\r\n\t\t\t.off(button, \"touchstart\", L.DomEvent.stopPropagation)\r\n\t\t\t.off(button, \"click\", L.DomEvent.preventDefault)\r\n\t\t\t.off(button, buttonEvent, callback);\r\n\t},\r\n\r\n\t_handlerActivated: function (e) {\r\n\t\t// Disable active mode (if present)\r\n\t\tthis.disable();\r\n\r\n\t\t// Cache new active feature\r\n\t\tthis._activeMode = this._modes[e.handler];\r\n\r\n\t\tL.DomUtil.addClass(\r\n\t\t\tthis._activeMode.button,\r\n\t\t\t\"leaflet-draw-toolbar-button-enabled\"\r\n\t\t);\r\n\r\n\t\tthis._showActionsToolbar();\r\n\r\n\t\tthis.fire(\"enable\");\r\n\t},\r\n\r\n\t_handlerDeactivated: function () {\r\n\t\tthis._hideActionsToolbar();\r\n\r\n\t\tL.DomUtil.removeClass(\r\n\t\t\tthis._activeMode.button,\r\n\t\t\t\"leaflet-draw-toolbar-button-enabled\"\r\n\t\t);\r\n\r\n\t\tthis._activeMode = null;\r\n\r\n\t\tthis.fire(\"disable\");\r\n\t},\r\n\r\n\t_createActions: function (handler) {\r\n\t\tvar container = this._actionsContainer,\r\n\t\t\tbuttons = this.getActions(handler),\r\n\t\t\tl = buttons.length,\r\n\t\t\tli,\r\n\t\t\tdi,\r\n\t\t\tdl,\r\n\t\t\tbutton;\r\n\r\n\t\t// Dispose the actions toolbar (todo: dispose only not used buttons)\r\n\t\tfor (di = 0, dl = this._actionButtons.length; di < dl; di++) {\r\n\t\t\tthis._disposeButton(\r\n\t\t\t\tthis._actionButtons[di].button,\r\n\t\t\t\tthis._actionButtons[di].callback\r\n\t\t\t);\r\n\t\t}\r\n\t\tthis._actionButtons = [];\r\n\r\n\t\t// Remove all old buttons\r\n\t\twhile (container.firstChild) {\r\n\t\t\tcontainer.removeChild(container.firstChild);\r\n\t\t}\r\n\r\n\t\tfor (var i = 0; i < l; i++) {\r\n\t\t\tif (\"enabled\" in buttons[i] && !buttons[i].enabled) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tli = L.DomUtil.create(\"li\", \"\", container);\r\n\r\n\t\t\tbutton = this._createButton({\r\n\t\t\t\ttitle: buttons[i].title,\r\n\t\t\t\ttext: buttons[i].text,\r\n\t\t\t\tcontainer: li,\r\n\t\t\t\tcallback: buttons[i].callback,\r\n\t\t\t\tcontext: buttons[i].context,\r\n\t\t\t});\r\n\r\n\t\t\tthis._actionButtons.push({\r\n\t\t\t\tbutton: button,\r\n\t\t\t\tcallback: buttons[i].callback,\r\n\t\t\t});\r\n\t\t}\r\n\t},\r\n\r\n\t_showActionsToolbar: function () {\r\n\t\tvar buttonIndex = this._activeMode.buttonIndex,\r\n\t\t\tlastButtonIndex = this._lastButtonIndex,\r\n\t\t\ttoolbarPosition = this._activeMode.button.offsetTop - 1;\r\n\r\n\t\t// Recreate action buttons on every click\r\n\t\tthis._createActions(this._activeMode.handler);\r\n\r\n\t\t// Correctly position the cancel button\r\n\t\tthis._actionsContainer.style.top = toolbarPosition + \"px\";\r\n\r\n\t\tif (buttonIndex === 0) {\r\n\t\t\tL.DomUtil.addClass(this._toolbarContainer, \"leaflet-draw-toolbar-notop\");\r\n\t\t\tL.DomUtil.addClass(this._actionsContainer, \"leaflet-draw-actions-top\");\r\n\t\t}\r\n\r\n\t\tif (buttonIndex === lastButtonIndex) {\r\n\t\t\tL.DomUtil.addClass(\r\n\t\t\t\tthis._toolbarContainer,\r\n\t\t\t\t\"leaflet-draw-toolbar-nobottom\"\r\n\t\t\t);\r\n\t\t\tL.DomUtil.addClass(this._actionsContainer, \"leaflet-draw-actions-bottom\");\r\n\t\t}\r\n\r\n\t\tthis._actionsContainer.style.display = \"block\";\r\n\t\tthis._map.fire(L.Draw.Event.TOOLBAROPENED);\r\n\t},\r\n\r\n\t_hideActionsToolbar: function () {\r\n\t\tthis._actionsContainer.style.display = \"none\";\r\n\r\n\t\tL.DomUtil.removeClass(this._toolbarContainer, \"leaflet-draw-toolbar-notop\");\r\n\t\tL.DomUtil.removeClass(\r\n\t\t\tthis._toolbarContainer,\r\n\t\t\t\"leaflet-draw-toolbar-nobottom\"\r\n\t\t);\r\n\t\tL.DomUtil.removeClass(this._actionsContainer, \"leaflet-draw-actions-top\");\r\n\t\tL.DomUtil.removeClass(\r\n\t\t\tthis._actionsContainer,\r\n\t\t\t\"leaflet-draw-actions-bottom\"\r\n\t\t);\r\n\t\tthis._map.fire(L.Draw.Event.TOOLBARCLOSED);\r\n\t},\r\n});\r\n","L.Draw = L.Draw || {};\r\n/**\r\n * @class L.Draw.Tooltip\r\n * @aka Tooltip\r\n *\r\n * The tooltip class — it is used to display the tooltip while drawing\r\n * This will be depreciated\r\n *\r\n * @example\r\n *\r\n * ```js\r\n *    var tooltip = L.Draw.Tooltip();\r\n * ```\r\n *\r\n */\r\nL.Draw.Tooltip = L.Class.extend({\r\n\r\n\t// @section Methods for modifying draw state\r\n\r\n\t// @method initialize(map): void\r\n\t// Tooltip constructor\r\n\tinitialize: function (map) {\r\n\t\tthis._map = map;\r\n\t\tthis._popupPane = map._panes.popupPane;\r\n\t\tthis._visible = false;\r\n\r\n\t\tthis._container = map.options.drawControlTooltips ?\r\n\t\t\tL.DomUtil.create('div', 'leaflet-draw-tooltip', this._popupPane) : null;\r\n\t\tthis._singleLineLabel = false;\r\n\r\n\t\tthis._map.on('mouseout', this._onMouseOut, this);\r\n\t},\r\n\r\n\t// @method dispose(): void\r\n\t// Remove Tooltip DOM and unbind events\r\n\tdispose: function () {\r\n\t\tthis._map.off('mouseout', this._onMouseOut, this);\r\n\r\n\t\tif (this._container) {\r\n\t\t\tthis._popupPane.removeChild(this._container);\r\n\t\t\tthis._container = null;\r\n\t\t}\r\n\t},\r\n\r\n\t// @method updateContent(labelText): this\r\n\t// Changes the tooltip text to string in function call\r\n\tupdateContent: function (labelText) {\r\n\t\tif (!this._container) {\r\n\t\t\treturn this;\r\n\t\t}\r\n\t\tlabelText.subtext = labelText.subtext || '';\r\n\r\n\t\t// update the vertical position (only if changed)\r\n\t\tif (labelText.subtext.length === 0 && !this._singleLineLabel) {\r\n\t\t\tL.DomUtil.addClass(this._container, 'leaflet-draw-tooltip-single');\r\n\t\t\tthis._singleLineLabel = true;\r\n\t\t}\r\n\t\telse if (labelText.subtext.length > 0 && this._singleLineLabel) {\r\n\t\t\tL.DomUtil.removeClass(this._container, 'leaflet-draw-tooltip-single');\r\n\t\t\tthis._singleLineLabel = false;\r\n\t\t}\r\n\r\n\t\tthis._container.innerHTML =\r\n\t\t\t(labelText.subtext.length > 0 ?\r\n\t\t\t\t'<span class=\"leaflet-draw-tooltip-subtext\">' + labelText.subtext + '</span>' + '<br />' : '') +\r\n\t\t\t'<span>' + labelText.text + '</span>';\r\n\r\n\t\tif (!labelText.text && !labelText.subtext) {\r\n\t\t\tthis._visible = false;\r\n\t\t\tthis._container.style.visibility = 'hidden';\r\n\t\t} else {\r\n\t\t\tthis._visible = true;\r\n\t\t\tthis._container.style.visibility = 'inherit';\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// @method updatePosition(latlng): this\r\n\t// Changes the location of the tooltip\r\n\tupdatePosition: function (latlng) {\r\n\t\tvar pos = this._map.latLngToLayerPoint(latlng),\r\n\t\t\ttooltipContainer = this._container;\r\n\r\n\t\tif (this._container) {\r\n\t\t\tif (this._visible) {\r\n\t\t\t\ttooltipContainer.style.visibility = 'inherit';\r\n\t\t\t}\r\n\t\t\tL.DomUtil.setPosition(tooltipContainer, pos);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// @method showAsError(): this\r\n\t// Applies error class to tooltip\r\n\tshowAsError: function () {\r\n\t\tif (this._container) {\r\n\t\t\tL.DomUtil.addClass(this._container, 'leaflet-error-draw-tooltip');\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// @method removeError(): this\r\n\t// Removes the error class from the tooltip\r\n\tremoveError: function () {\r\n\t\tif (this._container) {\r\n\t\t\tL.DomUtil.removeClass(this._container, 'leaflet-error-draw-tooltip');\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_onMouseOut: function () {\r\n\t\tif (this._container) {\r\n\t\t\tthis._container.style.visibility = 'hidden';\r\n\t\t}\r\n\t}\r\n});\r\n","/**\r\n * @class L.DrawToolbar\r\n * @aka Toolbar\r\n */\r\nL.DrawToolbar = L.Toolbar.extend({\r\n\tstatics: {\r\n\t\tTYPE: \"draw\",\r\n\t},\r\n\r\n\toptions: {\r\n\t\trole: {},\r\n\t\tthanhCai: {},\r\n\t\tmayBienAp: {},\r\n\t\tduongDay: {},\r\n\t\tpolyline: {},\r\n\t\t// polygon: {},\r\n\t\t// rectangle: {},\r\n\t\t// circle: {},\r\n\t\t// marker: {},\r\n\t\t// circlemarker: {},\r\n\t},\r\n\r\n\t// @method initialize(): void\r\n\tinitialize: function (options) {\r\n\t\t// Ensure that the options are merged correctly since L.extend is only shallow\r\n\t\tfor (var type in this.options) {\r\n\t\t\tif (this.options.hasOwnProperty(type)) {\r\n\t\t\t\tif (options[type]) {\r\n\t\t\t\t\toptions[type] = L.extend({}, this.options[type], options[type]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis._toolbarClass = \"leaflet-draw-draw\";\r\n\t\tL.Toolbar.prototype.initialize.call(this, options);\r\n\t},\r\n\r\n\t// @method getModeHandlers(): object\r\n\t// Get mode handlers information\r\n\tgetModeHandlers: function (map) {\r\n\t\treturn [\r\n\t\t\t{\r\n\t\t\t\tenabled: this.options.role,\r\n\t\t\t\thandler: new L.Draw.Role(map, this.options.role),\r\n\t\t\t\ttitle: L.drawLocal.draw.toolbar.buttons.role,\r\n\t\t\t},\r\n\t\t\t{\r\n\t\t\t\tenabled: this.options.thanhCai,\r\n\t\t\t\thandler: new L.Draw.ThanhCai(map, this.options.thanhCai),\r\n\t\t\t\ttitle: L.drawLocal.draw.toolbar.buttons.thanhCai,\r\n\t\t\t},\r\n\t\t\t{\r\n\t\t\t\tenabled: this.options.mayBienAp,\r\n\t\t\t\thandler: new L.Draw.MayBienAp(map, this.options.mayBienAp),\r\n\t\t\t\ttitle: L.drawLocal.draw.toolbar.buttons.mayBienAp,\r\n\t\t\t},\r\n\t\t\t{\r\n\t\t\t\tenabled: this.options.duongDay,\r\n\t\t\t\thandler: new L.Draw.DuongDay(map, this.options.duongDay),\r\n\t\t\t\ttitle: L.drawLocal.draw.toolbar.buttons.duongDay,\r\n\t\t\t},\r\n\t\t\t{\r\n\t\t\t\tenabled: this.options.polyline,\r\n\t\t\t\thandler: new L.Draw.Polyline(map, this.options.polyline),\r\n\t\t\t\ttitle: L.drawLocal.draw.toolbar.buttons.polyline,\r\n\t\t\t},\r\n\t\t\t// {\r\n\t\t\t// \tenabled: this.options.polygon,\r\n\t\t\t// \thandler: new L.Draw.Polygon(map, this.options.polygon),\r\n\t\t\t// \ttitle: L.drawLocal.draw.toolbar.buttons.polygon,\r\n\t\t\t// },\r\n\t\t\t// {\r\n\t\t\t// \tenabled: this.options.rectangle,\r\n\t\t\t// \thandler: new L.Draw.Rectangle(map, this.options.rectangle),\r\n\t\t\t// \ttitle: L.drawLocal.draw.toolbar.buttons.rectangle,\r\n\t\t\t// },\r\n\t\t\t// {\r\n\t\t\t// \tenabled: this.options.circle,\r\n\t\t\t// \thandler: new L.Draw.Circle(map, this.options.circle),\r\n\t\t\t// \ttitle: L.drawLocal.draw.toolbar.buttons.circle,\r\n\t\t\t// },\r\n\t\t\t// {\r\n\t\t\t// \tenabled: this.options.marker,\r\n\t\t\t// \thandler: new L.Draw.Marker(map, this.options.marker),\r\n\t\t\t// \ttitle: L.drawLocal.draw.toolbar.buttons.marker,\r\n\t\t\t// },\r\n\t\t\t// {\r\n\t\t\t// \tenabled: this.options.circlemarker,\r\n\t\t\t// \thandler: new L.Draw.CircleMarker(map, this.options.circlemarker),\r\n\t\t\t// \ttitle: L.drawLocal.draw.toolbar.buttons.circlemarker,\r\n\t\t\t// },\r\n\t\t];\r\n\t},\r\n\r\n\t// @method getActions(): object\r\n\t// Get action information\r\n\tgetActions: function (handler) {\r\n\t\treturn [\r\n\t\t\t{\r\n\t\t\t\tenabled: handler.completeShape,\r\n\t\t\t\ttitle: L.drawLocal.draw.toolbar.finish.title,\r\n\t\t\t\ttext: L.drawLocal.draw.toolbar.finish.text,\r\n\t\t\t\tcallback: handler.completeShape,\r\n\t\t\t\tcontext: handler,\r\n\t\t\t},\r\n\t\t\t{\r\n\t\t\t\tenabled: handler.deleteLastVertex,\r\n\t\t\t\ttitle: L.drawLocal.draw.toolbar.undo.title,\r\n\t\t\t\ttext: L.drawLocal.draw.toolbar.undo.text,\r\n\t\t\t\tcallback: handler.deleteLastVertex,\r\n\t\t\t\tcontext: handler,\r\n\t\t\t},\r\n\t\t\t{\r\n\t\t\t\ttitle: L.drawLocal.draw.toolbar.actions.title,\r\n\t\t\t\ttext: L.drawLocal.draw.toolbar.actions.text,\r\n\t\t\t\tcallback: this.disable,\r\n\t\t\t\tcontext: this,\r\n\t\t\t},\r\n\t\t];\r\n\t},\r\n\r\n\t// @method setOptions(): void\r\n\t// Sets the options to the toolbar\r\n\tsetOptions: function (options) {\r\n\t\tL.setOptions(this, options);\r\n\r\n\t\tfor (var type in this._modes) {\r\n\t\t\tif (this._modes.hasOwnProperty(type) && options.hasOwnProperty(type)) {\r\n\t\t\t\tthis._modes[type].handler.setOptions(options[type]);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n});\r\n","/*L.Map.mergeOptions({\r\n editControl: true\r\n });*/\r\n/**\r\n * @class L.EditToolbar\r\n * @aka EditToolbar\r\n */\r\nL.EditToolbar = L.Toolbar.extend({\r\n\tstatics: {\r\n\t\tTYPE: \"edit\",\r\n\t},\r\n\r\n\toptions: {\r\n\t\tedit: {\r\n\t\t\tselectedPathOptions: {\r\n\t\t\t\tdashArray: \"10, 10\",\r\n\r\n\t\t\t\tfill: true,\r\n\t\t\t\tfillColor: \"#fe57a1\",\r\n\t\t\t\tfillOpacity: 0.1,\r\n\r\n\t\t\t\t// Whether to user the existing layers color\r\n\t\t\t\tmaintainColor: false,\r\n\t\t\t},\r\n\t\t},\r\n\t\tremove: {},\r\n\t\tpoly: null,\r\n\t\tfeatureGroup:\r\n\t\t\tnull /* REQUIRED! TODO: perhaps if not set then all layers on the map are selectable? */,\r\n\t},\r\n\r\n\t// @method intialize(): void\r\n\tinitialize: function (options, drawItems) {\r\n\t\t// Need to set this manually since null is an acceptable value here\r\n\t\tif (options.edit) {\r\n\t\t\tif (typeof options.edit.selectedPathOptions === \"undefined\") {\r\n\t\t\t\toptions.edit.selectedPathOptions =\r\n\t\t\t\t\tthis.options.edit.selectedPathOptions;\r\n\t\t\t}\r\n\t\t\toptions.edit.selectedPathOptions = L.extend(\r\n\t\t\t\t{},\r\n\t\t\t\tthis.options.edit.selectedPathOptions,\r\n\t\t\t\toptions.edit.selectedPathOptions\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\tif (options.remove) {\r\n\t\t\toptions.remove = L.extend({}, this.options.remove, options.remove);\r\n\t\t}\r\n\r\n\t\tif (options.poly) {\r\n\t\t\toptions.poly = L.extend({}, this.options.poly, options.poly);\r\n\t\t}\r\n\r\n\t\tthis._toolbarClass = \"leaflet-draw-edit\";\r\n\t\tL.Toolbar.prototype.initialize.call(this, options);\r\n\r\n\t\tthis._selectedFeatureCount = 0;\r\n\t},\r\n\r\n\t// @method getModeHandlers(): object\r\n\t// Get mode handlers information\r\n\tgetModeHandlers: function (map) {\r\n\t\tvar featureGroup = this.options.featureGroup;\r\n\t\treturn [\r\n\t\t\t{\r\n\t\t\t\tenabled: this.options.edit,\r\n\t\t\t\thandler: new L.EditToolbar.Edit(map, {\r\n\t\t\t\t\tfeatureGroup: featureGroup,\r\n\t\t\t\t\tselectedPathOptions: this.options.edit.selectedPathOptions,\r\n\t\t\t\t\tpoly: this.options.poly,\r\n\t\t\t\t}),\r\n\t\t\t\ttitle: L.drawLocal.edit.toolbar.buttons.edit,\r\n\t\t\t},\r\n\t\t\t{\r\n\t\t\t\tenabled: this.options.remove,\r\n\t\t\t\thandler: new L.EditToolbar.Delete(map, {\r\n\t\t\t\t\tfeatureGroup: featureGroup,\r\n\t\t\t\t}),\r\n\t\t\t\ttitle: L.drawLocal.edit.toolbar.buttons.remove,\r\n\t\t\t},\r\n\t\t];\r\n\t},\r\n\r\n\t// @method getActions(): object\r\n\t// Get actions information\r\n\tgetActions: function (handler) {\r\n\t\tvar actions = [\r\n\t\t\t{\r\n\t\t\t\ttitle: L.drawLocal.edit.toolbar.actions.save.title,\r\n\t\t\t\ttext: L.drawLocal.edit.toolbar.actions.save.text,\r\n\t\t\t\tcallback: this._save,\r\n\t\t\t\tcontext: this,\r\n\t\t\t},\r\n\t\t\t{\r\n\t\t\t\ttitle: L.drawLocal.edit.toolbar.actions.cancel.title,\r\n\t\t\t\ttext: L.drawLocal.edit.toolbar.actions.cancel.text,\r\n\t\t\t\tcallback: this.disable,\r\n\t\t\t\tcontext: this,\r\n\t\t\t},\r\n\t\t];\r\n\r\n\t\tif (handler.removeAllLayers) {\r\n\t\t\tactions.push({\r\n\t\t\t\ttitle: L.drawLocal.edit.toolbar.actions.clearAll.title,\r\n\t\t\t\ttext: L.drawLocal.edit.toolbar.actions.clearAll.text,\r\n\t\t\t\tcallback: this._clearAllLayers,\r\n\t\t\t\tcontext: this,\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\treturn actions;\r\n\t},\r\n\r\n\t// @method addToolbar(map): L.DomUtil\r\n\t// Adds the toolbar to the map\r\n\taddToolbar: function (map) {\r\n\t\tvar container = L.Toolbar.prototype.addToolbar.call(this, map);\r\n\r\n\t\tthis._checkDisabled();\r\n\r\n\t\tthis.options.featureGroup.on(\r\n\t\t\t\"layeradd layerremove\",\r\n\t\t\tthis._checkDisabled,\r\n\t\t\tthis\r\n\t\t);\r\n\r\n\t\treturn container;\r\n\t},\r\n\r\n\t// @method removeToolbar(): void\r\n\t// Removes the toolbar from the map\r\n\tremoveToolbar: function () {\r\n\t\tthis.options.featureGroup.off(\r\n\t\t\t\"layeradd layerremove\",\r\n\t\t\tthis._checkDisabled,\r\n\t\t\tthis\r\n\t\t);\r\n\r\n\t\tL.Toolbar.prototype.removeToolbar.call(this);\r\n\t},\r\n\r\n\t// @method disable(): void\r\n\t// Disables the toolbar\r\n\tdisable: function () {\r\n\t\tif (!this.enabled()) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis._activeMode.handler.revertLayers();\r\n\r\n\t\tL.Toolbar.prototype.disable.call(this);\r\n\t},\r\n\r\n\t_save: function () {\r\n\t\tthis._activeMode.handler.save();\r\n\t\tif (this._activeMode) {\r\n\t\t\tthis._activeMode.handler.disable();\r\n\t\t}\r\n\t},\r\n\r\n\t_clearAllLayers: function () {\r\n\t\tthis._activeMode.handler.removeAllLayers();\r\n\t\tif (this._activeMode) {\r\n\t\t\tthis._activeMode.handler.disable();\r\n\t\t}\r\n\t},\r\n\r\n\t_checkDisabled: function () {\r\n\t\tvar featureGroup = this.options.featureGroup,\r\n\t\t\thasLayers = featureGroup.getLayers().length !== 0,\r\n\t\t\tbutton;\r\n\r\n\t\tif (this.options.edit) {\r\n\t\t\tbutton = this._modes[L.EditToolbar.Edit.TYPE].button;\r\n\r\n\t\t\tif (hasLayers) {\r\n\t\t\t\tL.DomUtil.removeClass(button, \"leaflet-disabled\");\r\n\t\t\t} else {\r\n\t\t\t\tL.DomUtil.addClass(button, \"leaflet-disabled\");\r\n\t\t\t}\r\n\r\n\t\t\tbutton.setAttribute(\r\n\t\t\t\t\"title\",\r\n\t\t\t\thasLayers\r\n\t\t\t\t\t? L.drawLocal.edit.toolbar.buttons.edit\r\n\t\t\t\t\t: L.drawLocal.edit.toolbar.buttons.editDisabled\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\tif (this.options.remove) {\r\n\t\t\tbutton = this._modes[L.EditToolbar.Delete.TYPE].button;\r\n\r\n\t\t\tif (hasLayers) {\r\n\t\t\t\tL.DomUtil.removeClass(button, \"leaflet-disabled\");\r\n\t\t\t} else {\r\n\t\t\t\tL.DomUtil.addClass(button, \"leaflet-disabled\");\r\n\t\t\t}\r\n\r\n\t\t\tbutton.setAttribute(\r\n\t\t\t\t\"title\",\r\n\t\t\t\thasLayers\r\n\t\t\t\t\t? L.drawLocal.edit.toolbar.buttons.remove\r\n\t\t\t\t\t: L.drawLocal.edit.toolbar.buttons.removeDisabled\r\n\t\t\t);\r\n\t\t}\r\n\t},\r\n});\r\n","/**\r\n * @class L.EditToolbar.Edit\r\n * @aka EditToolbar.Edit\r\n */\r\nL.EditToolbar.Edit = L.Handler.extend({\r\n\tstatics: {\r\n\t\tTYPE: \"edit\",\r\n\t},\r\n\r\n\t// @method intialize(): void\r\n\tinitialize: function (map, options) {\r\n\t\tL.Handler.prototype.initialize.call(this, map);\r\n\r\n\t\tL.setOptions(this, options);\r\n\r\n\t\t// Store the selectable layer group for ease of access\r\n\t\tthis._featureGroup = options.featureGroup;\r\n\r\n\t\tif (!(this._featureGroup instanceof L.FeatureGroup)) {\r\n\t\t\tthrow new Error(\"options.featureGroup must be a L.FeatureGroup\");\r\n\t\t}\r\n\r\n\t\tthis._uneditedLayerProps = {};\r\n\r\n\t\t// Save the type so super can fire, need to do this as cannot do this.TYPE :(\r\n\t\tthis.type = L.EditToolbar.Edit.TYPE;\r\n\r\n\t\tvar version = L.version.split(\".\");\r\n\t\t//If Version is >= 1.2.0\r\n\t\tif (parseInt(version[0], 10) === 1 && parseInt(version[1], 10) >= 2) {\r\n\t\t\tL.EditToolbar.Edit.include(L.Evented.prototype);\r\n\t\t} else {\r\n\t\t\tL.EditToolbar.Edit.include(L.Mixin.Events);\r\n\t\t}\r\n\t},\r\n\r\n\t// @method enable(): void\r\n\t// Enable the edit toolbar\r\n\tenable: function () {\r\n\t\tif (this._enabled || !this._hasAvailableLayers()) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tthis.fire(\"enabled\", { handler: this.type });\r\n\t\t//this disable other handlers\r\n\r\n\t\tthis._map.fire(L.Draw.Event.EDITSTART, { handler: this.type });\r\n\t\t//allow drawLayer to be updated before beginning edition.\r\n\r\n\t\tL.Handler.prototype.enable.call(this);\r\n\t\tthis._featureGroup\r\n\t\t\t.on(\"layeradd\", this._enableLayerEdit, this)\r\n\t\t\t.on(\"layerremove\", this._disableLayerEdit, this);\r\n\t},\r\n\r\n\t// @method disable(): void\r\n\t// Disable the edit toolbar\r\n\tdisable: function () {\r\n\t\tif (!this._enabled) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tthis._featureGroup\r\n\t\t\t.off(\"layeradd\", this._enableLayerEdit, this)\r\n\t\t\t.off(\"layerremove\", this._disableLayerEdit, this);\r\n\t\tL.Handler.prototype.disable.call(this);\r\n\t\tthis._map.fire(L.Draw.Event.EDITSTOP, { handler: this.type });\r\n\t\tthis.fire(\"disabled\", { handler: this.type });\r\n\t},\r\n\r\n\t// @method addHooks(): void\r\n\t// Add listener hooks for this handler\r\n\taddHooks: function () {\r\n\t\tvar map = this._map;\r\n\r\n\t\tif (map) {\r\n\t\t\tmap.getContainer().focus();\r\n\r\n\t\t\tthis._featureGroup.eachLayer(this._enableLayerEdit, this);\r\n\r\n\t\t\tthis._tooltip = new L.Draw.Tooltip(this._map);\r\n\t\t\tthis._tooltip.updateContent({\r\n\t\t\t\ttext: L.drawLocal.edit.handlers.edit.tooltip.text,\r\n\t\t\t\tsubtext: L.drawLocal.edit.handlers.edit.tooltip.subtext,\r\n\t\t\t});\r\n\r\n\t\t\t// Quickly access the tooltip to update for intersection checking\r\n\t\t\tmap._editTooltip = this._tooltip;\r\n\r\n\t\t\tthis._updateTooltip();\r\n\r\n\t\t\tthis._map\r\n\t\t\t\t.on(\"mousemove\", this._onMouseMove, this)\r\n\t\t\t\t.on(\"touchmove\", this._onMouseMove, this)\r\n\t\t\t\t.on(\"MSPointerMove\", this._onMouseMove, this)\r\n\t\t\t\t.on(L.Draw.Event.EDITVERTEX, this._updateTooltip, this);\r\n\t\t}\r\n\t},\r\n\r\n\t// @method removeHooks(): void\r\n\t// Remove listener hooks for this handler\r\n\tremoveHooks: function () {\r\n\t\tif (this._map) {\r\n\t\t\t// Clean up selected layers.\r\n\t\t\tthis._featureGroup.eachLayer(this._disableLayerEdit, this);\r\n\r\n\t\t\t// Clear the backups of the original layers\r\n\t\t\tthis._uneditedLayerProps = {};\r\n\r\n\t\t\tthis._tooltip.dispose();\r\n\t\t\tthis._tooltip = null;\r\n\r\n\t\t\tthis._map\r\n\t\t\t\t.off(\"mousemove\", this._onMouseMove, this)\r\n\t\t\t\t.off(\"touchmove\", this._onMouseMove, this)\r\n\t\t\t\t.off(\"MSPointerMove\", this._onMouseMove, this)\r\n\t\t\t\t.off(L.Draw.Event.EDITVERTEX, this._updateTooltip, this);\r\n\t\t}\r\n\t},\r\n\r\n\t// @method revertLayers(): void\r\n\t// Revert each layer's geometry changes\r\n\trevertLayers: function () {\r\n\t\tthis._featureGroup.eachLayer(function (layer) {\r\n\t\t\tthis._revertLayer(layer);\r\n\t\t}, this);\r\n\t},\r\n\r\n\t// @method save(): void\r\n\t// Save the layer geometries\r\n\tsave: function () {\r\n\t\tvar editedLayers = new L.LayerGroup();\r\n\t\tthis._featureGroup.eachLayer(function (layer) {\r\n\t\t\tif (layer.edited) {\r\n\t\t\t\tvar options = layer.options;\r\n\t\t\t\tif (layer instanceof L.Role) {\r\n\t\t\t\t\toptions.original.chieuDai = options.chieuDai;\r\n\t\t\t\t\toptions.original.chieuRong = options.chieuRong;\r\n\t\t\t\t\toptions.original.gocXoay = options.gocXoay;\r\n\t\t\t\t} else if (layer instanceof L.ThanhCai) {\r\n\t\t\t\t\toptions.original.chieuDai = options.chieuDai;\r\n\t\t\t\t\toptions.original.gocXoay = options.gocXoay;\r\n\t\t\t\t} else if (layer instanceof L.MayBienAp) {\r\n\t\t\t\t\toptions.original.chieuDai = options.chieuDai;\r\n\t\t\t\t\toptions.original.gocXoay = options.gocXoay;\r\n\t\t\t\t} else if (layer instanceof L.DuongDay) {\r\n\t\t\t\t}\r\n\t\t\t\teditedLayers.addLayer(layer);\r\n\t\t\t\tlayer.edited = false;\r\n\t\t\t}\r\n\t\t});\r\n\t\tthis._map.fire(L.Draw.Event.EDITED, {\r\n\t\t\tlayers: editedLayers,\r\n\t\t});\r\n\t},\r\n\r\n\t_backupLayer: function (layer) {\r\n\t\tconst id = L.Util.stamp(layer);\r\n\t\tif (!this._uneditedLayerProps[id]) {\r\n\t\t\tconst options = layer.options;\r\n\t\t\tif (layer instanceof L.Role) {\r\n\t\t\t\tthis._uneditedLayerProps[id] = {\r\n\t\t\t\t\tlatlngs: L.LatLngUtil.cloneLatLngs(layer.getLatLngs()),\r\n\t\t\t\t\toptions: {\r\n\t\t\t\t\t\tchieuDai: options.chieuDai,\r\n\t\t\t\t\t\tchieuRong: options.chieuRong,\r\n\t\t\t\t\t\tgocXoay: options.gocXoay,\r\n\t\t\t\t\t},\r\n\t\t\t\t};\r\n\t\t\t} else if (layer instanceof L.ThanhCai) {\r\n\t\t\t\tthis._uneditedLayerProps[id] = {\r\n\t\t\t\t\tlatlngs: L.LatLngUtil.cloneLatLngs(layer.getLatLngs()),\r\n\t\t\t\t\toptions: {\r\n\t\t\t\t\t\tchieuDai: options.chieuDai,\r\n\t\t\t\t\t\tgocXoay: options.gocXoay,\r\n\t\t\t\t\t},\r\n\t\t\t\t};\r\n\t\t\t} else if (layer instanceof L.MayBienAp) {\r\n\t\t\t\tconst latLng = layer.getLatLng();\r\n\t\t\t\tthis._uneditedLayerProps[id] = {\r\n\t\t\t\t\tlatlng: L.latLng(latLng.lat, latLng.lng),\r\n\t\t\t\t\toptions: {\r\n\t\t\t\t\t\tchieuDai: options.chieuDai,\r\n\t\t\t\t\t\tgocXoay: options.gocXoay,\r\n\t\t\t\t\t},\r\n\t\t\t\t};\r\n\t\t\t} else if (layer instanceof L.DuongDay) {\r\n\t\t\t\tthis._uneditedLayerProps[id] = {\r\n\t\t\t\t\tlatlngs: L.LatLngUtil.cloneLatLngs(layer.getLatLngs()),\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_getTooltipText: function () {\r\n\t\treturn {\r\n\t\t\ttext: L.drawLocal.edit.handlers.edit.tooltip.text,\r\n\t\t\tsubtext: L.drawLocal.edit.handlers.edit.tooltip.subtext,\r\n\t\t};\r\n\t},\r\n\r\n\t_updateTooltip: function () {\r\n\t\tthis._tooltip.updateContent(this._getTooltipText());\r\n\t},\r\n\r\n\t_revertLayer: function (layer) {\r\n\t\tconst id = L.Util.stamp(layer);\r\n\t\tlayer.edited = false;\r\n\t\tif (this._uneditedLayerProps.hasOwnProperty(id)) {\r\n\t\t\tL.setOptions(layer, this._uneditedLayerProps[id].options);\r\n\t\t\tif (\r\n\t\t\t\tlayer instanceof L.Role ||\r\n\t\t\t\tlayer instanceof L.ThanhCai ||\r\n\t\t\t\tlayer instanceof L.DuongDay\r\n\t\t\t) {\r\n\t\t\t\tlayer.setLatLngs(this._uneditedLayerProps[id].latlngs);\r\n\t\t\t} else if (layer instanceof L.MayBienAp) {\r\n\t\t\t\tlayer.setLatLng(this._uneditedLayerProps[id].latlng);\r\n\t\t\t}\r\n\t\t\tlayer.fire(\"revert-edited\", { layer: layer });\r\n\t\t}\r\n\t},\r\n\r\n\t_enableLayerEdit: function (e) {\r\n\t\tvar layer = e.layer || e.target || e,\r\n\t\t\tpathOptions,\r\n\t\t\tpoly;\r\n\r\n\t\t// Back up this layer (if haven't before)\r\n\t\tthis._backupLayer(layer);\r\n\r\n\t\tif (this.options.poly) {\r\n\t\t\tpoly = L.Util.extend({}, this.options.poly);\r\n\t\t\tlayer.options.poly = poly;\r\n\t\t}\r\n\r\n\t\t// Set different style for editing mode\r\n\t\tif (this.options.selectedPathOptions) {\r\n\t\t\tpathOptions = L.Util.extend({}, this.options.selectedPathOptions);\r\n\r\n\t\t\t// Use the existing color of the layer\r\n\t\t\tif (pathOptions.maintainColor) {\r\n\t\t\t\tpathOptions.color = layer.options.color;\r\n\t\t\t\tpathOptions.fillColor = layer.options.fillColor;\r\n\t\t\t}\r\n\t\t\tlayer.options.original = L.extend({}, layer.options);\r\n\t\t\tlayer.options.editing = pathOptions;\r\n\t\t}\r\n\r\n\t\tif (layer instanceof L.Marker) {\r\n\t\t\tif (layer.editing) {\r\n\t\t\t\tlayer.editing.enable();\r\n\t\t\t}\r\n\t\t\tlayer.dragging.enable();\r\n\t\t\tlayer\r\n\t\t\t\t.on(\"dragend\", this._onMarkerDragEnd)\r\n\t\t\t\t// #TODO: remove when leaflet finally fixes their draggable so it's touch friendly again.\r\n\t\t\t\t.on(\"touchmove\", this._onTouchMove, this)\r\n\t\t\t\t.on(\"MSPointerMove\", this._onTouchMove, this)\r\n\t\t\t\t.on(\"touchend\", this._onMarkerDragEnd, this)\r\n\t\t\t\t.on(\"MSPointerUp\", this._onMarkerDragEnd, this);\r\n\t\t} else {\r\n\t\t\tlayer.editing.enable();\r\n\t\t}\r\n\t},\r\n\r\n\t_disableLayerEdit: function (e) {\r\n\t\tvar layer = e.layer || e.target || e;\r\n\r\n\t\tlayer.edited = false;\r\n\t\tif (layer.editing) {\r\n\t\t\tlayer.editing.disable();\r\n\t\t}\r\n\r\n\t\tdelete layer.options.editing;\r\n\t\tdelete layer.options.original;\r\n\t\t// Reset layer styles to that of before select\r\n\t\tif (this._selectedPathOptions) {\r\n\t\t\tif (layer instanceof L.Marker) {\r\n\t\t\t\tthis._toggleMarkerHighlight(layer);\r\n\t\t\t} else {\r\n\t\t\t\t// reset the layer style to what is was before being selected\r\n\t\t\t\tlayer.setStyle(layer.options.previousOptions);\r\n\t\t\t\t// remove the cached options for the layer object\r\n\t\t\t\tdelete layer.options.previousOptions;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (layer instanceof L.Marker) {\r\n\t\t\tlayer.dragging.disable();\r\n\t\t\tlayer\r\n\t\t\t\t.off(\"dragend\", this._onMarkerDragEnd, this)\r\n\t\t\t\t.off(\"touchmove\", this._onTouchMove, this)\r\n\t\t\t\t.off(\"MSPointerMove\", this._onTouchMove, this)\r\n\t\t\t\t.off(\"touchend\", this._onMarkerDragEnd, this)\r\n\t\t\t\t.off(\"MSPointerUp\", this._onMarkerDragEnd, this);\r\n\t\t} else {\r\n\t\t\tlayer.editing.disable();\r\n\t\t}\r\n\t},\r\n\r\n\t_onMouseMove: function (e) {\r\n\t\tthis._tooltip.updatePosition(e.latlng);\r\n\t},\r\n\r\n\t_onMarkerDragEnd: function (e) {\r\n\t\tvar layer = e.target;\r\n\t\tlayer.edited = true;\r\n\t\tthis._map.fire(L.Draw.Event.EDITMOVE, { layer: layer });\r\n\t},\r\n\r\n\t_onTouchMove: function (e) {\r\n\t\tvar touchEvent = e.originalEvent.changedTouches[0],\r\n\t\t\tlayerPoint = this._map.mouseEventToLayerPoint(touchEvent),\r\n\t\t\tlatlng = this._map.layerPointToLatLng(layerPoint);\r\n\t\te.target.setLatLng(latlng);\r\n\t},\r\n\r\n\t_hasAvailableLayers: function () {\r\n\t\treturn this._featureGroup.getLayers().length !== 0;\r\n\t},\r\n});\r\n","/**\r\n * @class L.EditToolbar.Delete\r\n * @aka EditToolbar.Delete\r\n */\r\nL.EditToolbar.Delete = L.Handler.extend({\r\n\tstatics: {\r\n\t\tTYPE: 'remove' // not delete as delete is reserved in js\r\n\t},\r\n\r\n\t// @method intialize(): void\r\n\tinitialize: function (map, options) {\r\n\t\tL.Handler.prototype.initialize.call(this, map);\r\n\r\n\t\tL.Util.setOptions(this, options);\r\n\r\n\t\t// Store the selectable layer group for ease of access\r\n\t\tthis._deletableLayers = this.options.featureGroup;\r\n\r\n\t\tif (!(this._deletableLayers instanceof L.FeatureGroup)) {\r\n\t\t\tthrow new Error('options.featureGroup must be a L.FeatureGroup');\r\n\t\t}\r\n\r\n\t\t// Save the type so super can fire, need to do this as cannot do this.TYPE :(\r\n\t\tthis.type = L.EditToolbar.Delete.TYPE;\r\n\r\n\t\tvar version = L.version.split('.');\r\n\t\t//If Version is >= 1.2.0\r\n\t\tif (parseInt(version[0], 10) === 1 && parseInt(version[1], 10) >= 2) {\r\n\t\t\tL.EditToolbar.Delete.include(L.Evented.prototype);\r\n\t\t} else {\r\n\t\t\tL.EditToolbar.Delete.include(L.Mixin.Events);\r\n\t\t}\r\n\r\n\t},\r\n\r\n\t// @method enable(): void\r\n\t// Enable the delete toolbar\r\n\tenable: function () {\r\n\t\tif (this._enabled || !this._hasAvailableLayers()) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tthis.fire('enabled', {handler: this.type});\r\n\r\n\t\tthis._map.fire(L.Draw.Event.DELETESTART, {handler: this.type});\r\n\r\n\t\tL.Handler.prototype.enable.call(this);\r\n\r\n\t\tthis._deletableLayers\r\n\t\t\t.on('layeradd', this._enableLayerDelete, this)\r\n\t\t\t.on('layerremove', this._disableLayerDelete, this);\r\n\t},\r\n\r\n\t// @method disable(): void\r\n\t// Disable the delete toolbar\r\n\tdisable: function () {\r\n\t\tif (!this._enabled) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis._deletableLayers\r\n\t\t\t.off('layeradd', this._enableLayerDelete, this)\r\n\t\t\t.off('layerremove', this._disableLayerDelete, this);\r\n\r\n\t\tL.Handler.prototype.disable.call(this);\r\n\r\n\t\tthis._map.fire(L.Draw.Event.DELETESTOP, {handler: this.type});\r\n\r\n\t\tthis.fire('disabled', {handler: this.type});\r\n\t},\r\n\r\n\t// @method addHooks(): void\r\n\t// Add listener hooks to this handler\r\n\taddHooks: function () {\r\n\t\tvar map = this._map;\r\n\r\n\t\tif (map) {\r\n\t\t\tmap.getContainer().focus();\r\n\r\n\t\t\tthis._deletableLayers.eachLayer(this._enableLayerDelete, this);\r\n\t\t\tthis._deletedLayers = new L.LayerGroup();\r\n\r\n\t\t\tthis._tooltip = new L.Draw.Tooltip(this._map);\r\n\t\t\tthis._tooltip.updateContent({text: L.drawLocal.edit.handlers.remove.tooltip.text});\r\n\r\n\t\t\tthis._map.on('mousemove', this._onMouseMove, this);\r\n\t\t}\r\n\t},\r\n\r\n\t// @method removeHooks(): void\r\n\t// Remove listener hooks from this handler\r\n\tremoveHooks: function () {\r\n\t\tif (this._map) {\r\n\t\t\tthis._deletableLayers.eachLayer(this._disableLayerDelete, this);\r\n\t\t\tthis._deletedLayers = null;\r\n\r\n\t\t\tthis._tooltip.dispose();\r\n\t\t\tthis._tooltip = null;\r\n\r\n\t\t\tthis._map.off('mousemove', this._onMouseMove, this);\r\n\t\t}\r\n\t},\r\n\r\n\t// @method revertLayers(): void\r\n\t// Revert the deleted layers back to their prior state.\r\n\trevertLayers: function () {\r\n\t\t// Iterate of the deleted layers and add them back into the featureGroup\r\n\t\tthis._deletedLayers.eachLayer(function (layer) {\r\n\t\t\tthis._deletableLayers.addLayer(layer);\r\n\t\t\tlayer.fire('revert-deleted', {layer: layer});\r\n\t\t}, this);\r\n\t},\r\n\r\n\t// @method save(): void\r\n\t// Save deleted layers\r\n\tsave: function () {\r\n\t\tthis._map.fire(L.Draw.Event.DELETED, {layers: this._deletedLayers});\r\n\t},\r\n\r\n\t// @method removeAllLayers(): void\r\n\t// Remove all delateable layers\r\n\tremoveAllLayers: function () {\r\n\t\t// Iterate of the delateable layers and add remove them\r\n\t\tthis._deletableLayers.eachLayer(function (layer) {\r\n\t\t\tthis._removeLayer({layer: layer});\r\n\t\t}, this);\r\n\t\tthis.save();\r\n\t},\r\n\r\n\t_enableLayerDelete: function (e) {\r\n\t\tvar layer = e.layer || e.target || e;\r\n\r\n\t\tlayer.on('click', this._removeLayer, this);\r\n\t},\r\n\r\n\t_disableLayerDelete: function (e) {\r\n\t\tvar layer = e.layer || e.target || e;\r\n\r\n\t\tlayer.off('click', this._removeLayer, this);\r\n\r\n\t\t// Remove from the deleted layers so we can't accidentally revert if the user presses cancel\r\n\t\tthis._deletedLayers.removeLayer(layer);\r\n\t},\r\n\r\n\t_removeLayer: function (e) {\r\n\t\tvar layer = e.layer || e.target || e;\r\n\r\n\t\tthis._deletableLayers.removeLayer(layer);\r\n\r\n\t\tthis._deletedLayers.addLayer(layer);\r\n\r\n\t\tlayer.fire('deleted');\r\n\t},\r\n\r\n\t_onMouseMove: function (e) {\r\n\t\tthis._tooltip.updatePosition(e.latlng);\r\n\t},\r\n\r\n\t_hasAvailableLayers: function () {\r\n\t\treturn this._deletableLayers.getLayers().length !== 0;\r\n\t}\r\n});\r\n"]}